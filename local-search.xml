<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>趣学架构</title>
    <link href="/2024/01/25/%E8%B6%A3%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/01/25/%E8%B6%A3%E5%AD%A6%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1pz4y1j72C">https://www.bilibili.com/video/BV1pz4y1j72C</a></p><h2 id="1-大学学点啥"><a href="#1-大学学点啥" class="headerlink" title="1.大学学点啥"></a>1.大学学点啥</h2><p>学习能力</p><ul><li>知识多</li><li>更新换代快</li><li>时间约束</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202402292125524.png" alt="image-20240118150913790"></p><h2 id="2-搭建系统先搭架子"><a href="#2-搭建系统先搭架子" class="headerlink" title="2.搭建系统先搭架子"></a>2.搭建系统先搭架子</h2><h3 id="1-用户首页"><a href="#1-用户首页" class="headerlink" title="1.用户首页"></a>1.用户首页</h3><p>（用户信息、余额、消费等）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202402292125135.png" alt="image-20240118152725304"></p><h3 id="2-新需求"><a href="#2-新需求" class="headerlink" title="2.新需求"></a>2.新需求</h3><p>需要添加用户修改功能；<strong>存在许多重复代码</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403151317860.png" alt="image-20240118152826760"></p><p>解决方案1：添加工具类</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403151413979.png" alt="image-20240118152927534"></p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>统一逻辑，标准化流程</p><p>解决方案2：<strong>模板方法模式</strong>；保证必须要调用以及调用顺序；通用部分直接一起升级（log、error）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403151413316.png" alt="image-20240118152954535"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.base.Stopwatch;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceTemplate</span>&lt;T, R&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggerImpl</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模板统一暴露执行入口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">process</span><span class="hljs-params">(T request)</span> &#123;<br>        <span class="hljs-comment">// 1.打印入口日志</span><br>        logger.info(<span class="hljs-string">&quot;start invoke, request=&quot;</span> + request);<br>        <span class="hljs-comment">// 开始计时，用于日志记录耗时</span><br>        <span class="hljs-type">Stopwatch</span> <span class="hljs-variable">stopwatch</span> <span class="hljs-operator">=</span> Stopwatch.createStarted();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 2. 校验参数</span><br>            validParam(request);<br>            <span class="hljs-comment">// 3. 子类实现逻辑</span><br>            <span class="hljs-type">R</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> doProcess(request);<br>            <span class="hljs-comment">// 4.打印出口日志</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">timeCost</span> <span class="hljs-operator">=</span> stopwatch.elapsed(TimeUnit.MILLISECONDS);<br>            logger.info(<span class="hljs-string">&quot;end invoke, response=&quot;</span> + response + <span class="hljs-string">&quot;, costTime=&quot;</span> + timeCost);<br>            <span class="hljs-keyword">return</span> response;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 打印异常日志</span><br>            logger.error(<span class="hljs-string">&quot;error invoke, exception:&quot;</span> + Arrays.toString(e.getStackTrace()));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 参数校验(交给子类实现)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validParam</span><span class="hljs-params">(T request)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行业务逻辑(交给子类实现)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> R <span class="hljs-title function_">doProcess</span><span class="hljs-params">(T request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 模拟的Logger类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;INFO: &quot;</span> + msg);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ERROR: &quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">get</span><span class="hljs-params">(Integer userId)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceTemplate</span>&lt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validParam</span><span class="hljs-params">(Integer request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (request == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Request cannot be null&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">doProcess</span><span class="hljs-params">(Integer request)</span> &#123;<br>        <span class="hljs-comment">// 具体业务 获取用户信息、消费情况、余额</span><br>        <span class="hljs-keyword">return</span> request * request;<br>    &#125;<br>&#125;.process(userId);<br></code></pre></td></tr></table></figure><p>再进一步：如果子需求再次变化，例如添加优惠券信息、消费记录查询限制时间、只有授权才返回余额</p><p>这样代码越来越长，并且子业务之间相互影响；<strong>耦合</strong></p><h2 id="3-搭完架子串珠子"><a href="#3-搭完架子串珠子" class="headerlink" title="3.搭完架子串珠子"></a>3.搭完架子串珠子</h2><h3 id="流程引擎"><a href="#流程引擎" class="headerlink" title="流程引擎"></a>流程引擎</h3><p>逻辑拆分、边界组装</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118161401411.png" alt="image-20240118161401411"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118155403367.png" alt="image-20240118155403367"></p><p>其实就是实习中遇到的模板引擎玩法</p><p>在活动中，就是处理器就是 获取活动信息  过活动人群  过任务人群  过风控  处理业务  （首次进入任务就是添加一次任务记录，然后发一次抽奖机会；抽奖就是消耗抽奖机会，然后执行抽奖流程）</p><h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><h4 id="造珠子（定义组件）"><a href="#造珠子（定义组件）" class="headerlink" title="造珠子（定义组件）"></a>造珠子（定义组件）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-comment">// 包含两个参数  </span><br>    <span class="hljs-comment">// 1.入参 本次请求需要的参数，这个也可也定义一个函数来获取</span><br>    <span class="hljs-comment">// 2.上下文 处理器之间的信息传递 也是最后结果的返回数据源</span><br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needExecute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span>; <span class="hljs-comment">// 灰度</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span>;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoQueryProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserBaseInfoRepository userBaseInfoRepository; <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserSpecialInfoRepository userSpecialInfoRepository;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needExecute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        <span class="hljs-comment">// 实现具体的判断逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 示例，默认总是执行</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        <span class="hljs-comment">// 实现具体的处理逻辑</span><br>        <span class="hljs-type">UserBaseInfoVO</span> <span class="hljs-variable">userBaseInfoVo</span> <span class="hljs-operator">=</span> userBaseInfoRepository.getUserBaseInfo(request.getUserId());<br>        <span class="hljs-type">UserSpecialInfoVO</span> <span class="hljs-variable">userSpecialInfoVo</span> <span class="hljs-operator">=</span> userSpecialInfoRepository.getUserSpecialInfo(request.getUserId());<br>        <br>        <span class="hljs-comment">// ... 更新context状态或处理其他业务逻辑</span><br>        context.setUserBaseInfo(userBaseInfoVo);<br>        context.setUserSpecialInfo(userSpecialInfoVo);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="串珠子（编排组件）"><a href="#串珠子（编排组件）" class="headerlink" title="串珠子（编排组件）"></a>串珠子（编排组件）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引擎接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProcessEngine</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span>;<br>&#125;<br><br><span class="hljs-comment">// 引擎核心</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProcessEngineImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProcessEngine</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Logger logger;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;ProcessEngine start, request:&quot;</span> + request);<br>        <br>        <span class="hljs-comment">// 获取执行器列表</span><br>        List&lt;ProcessNameEnum&gt; processors = getProcessors();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 逐个运行执行器</span><br>            <span class="hljs-keyword">for</span> (ProcessNameEnum processorName : processors) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> applicationContext.getBean(processorName.getName());<br>                <span class="hljs-keyword">if</span> (!(bean <span class="hljs-keyword">instanceof</span> Processor)) &#123;<br>                    logger.error(<span class="hljs-string">&quot;Processor: &quot;</span> + processorName + <span class="hljs-string">&quot; not exist or type is incorrect&quot;</span>);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 执行器开始日志标注</span><br>                logger.info(<span class="hljs-string">&quot;Processor: &quot;</span> + processorName + <span class="hljs-string">&quot; start&quot;</span>);<br>                <br>                <span class="hljs-type">Processor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> (Processor) bean;<br>                <span class="hljs-comment">// 判断执行器是否符合执行条件</span><br>                <span class="hljs-keyword">if</span> (!processor.needExecute(request, context)) &#123;<br>                    logger.info(<span class="hljs-string">&quot;Processor: &quot;</span> + processorName + <span class="hljs-string">&quot; skipped&quot;</span>);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 执行器执行</span><br>                processor.execute(request, context);<br>                <br>                <span class="hljs-comment">// 执行器结束日志标注</span><br>                logger.info(<span class="hljs-string">&quot;Processor: &quot;</span> + processorName + <span class="hljs-string">&quot; end&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 执行异常中断日志打印</span><br>            logger.error(<span class="hljs-string">&quot;ProcessEngine interrupted, exception: &quot;</span> + Arrays.toString(e.getStackTrace()));<br>            <span class="hljs-comment">// 继续抛出异常</span><br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 打印引擎执行完成日志</span><br>        logger.info(<span class="hljs-string">&quot;ProcessEngine end, context: &quot;</span> + context);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> List&lt;ProcessNameEnum&gt; <span class="hljs-title function_">getProcessors</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体引擎</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoQueryProcessEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessEngineImpl</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;ProcessNameEnum&gt; processorList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        processorList.add(ProcessNameEnum.USER_INFO_QUERY_PROCESSOR);<br>        processorList.add(ProcessNameEnum.MONEY_PROCESSOR);<br>        processorList.add(ProcessNameEnum.CONSUME_RECORD_PROCESSOR);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> List&lt;ProcessNameEnum&gt; <span class="hljs-title function_">getProcessors</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> processorList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调用（启动流程）"><a href="#调用（启动流程）" class="headerlink" title="调用（启动流程）"></a>调用（启动流程）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> UserInfoDTO <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;userId&quot;)</span> String userId)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceTemplate</span>&lt;String, UserInfoDTO&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validParam</span><span class="hljs-params">(String request)</span> &#123;<br>            <span class="hljs-comment">// ... 参数校验逻辑</span><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> UserInfoDTO <span class="hljs-title function_">doProcess</span><span class="hljs-params">(String request)</span> &#123;<br>            <span class="hljs-comment">// ... 初始化请求和上下文对象</span><br>            <span class="hljs-type">ProcessRequest</span> <span class="hljs-variable">processRequest</span> <span class="hljs-operator">=</span> ProcessRequest.builder().userId(userId).build();<br>            <span class="hljs-type">ProcessContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> ProcessContext.builder().build();<br>            <br>            <span class="hljs-comment">// 启动引擎</span><br>            userInfoQueryProcessEngine.start(processRequest, ctx);<br>            <br>            <span class="hljs-comment">// 从上下文对象中获取数据并填充返回对象</span><br>            <span class="hljs-keyword">return</span> UserInfoDTO.builder()<br>                              .totalMoney(ctx.getTotalMoney())<br>                              .maxAmount(ctx.getMaxAmount())<br>                              .build();<br>        &#125;<br>    &#125;).process(userId);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="复杂流程编排"><a href="#复杂流程编排" class="headerlink" title="复杂流程编排"></a>复杂流程编排</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118162350908.png" alt="image-20240118162350908"></p><p>amunda, JBPM, 或Activiti  轻量级框架：LiteFlow</p><p>0.JSON</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;initialProcessor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;UserInfoQueryProcessor&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;processMap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;UserInfoQueryProcessor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MoneyProcessor&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;failed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ErrorHandlingProcessor&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;MoneyProcessor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ConsumeRecordProcessor&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;failed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ErrorHandlingProcessor&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ConsumeRecordProcessor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;failed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ErrorHandlingProcessor&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>1.返回string，决定着next</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needExecute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span>;<br>    String <span class="hljs-title function_">execute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoQueryProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserBaseInfoRepository userBaseInfoRepository; <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserSpecialInfoRepository userSpecialInfoRepository;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needExecute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        <span class="hljs-comment">// 实现具体的判断逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 示例，默认总是执行</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        <span class="hljs-comment">// 实现具体的处理逻辑</span><br>        <span class="hljs-type">UserBaseInfoVO</span> <span class="hljs-variable">userBaseInfoVo</span> <span class="hljs-operator">=</span> userBaseInfoRepository.getUserBaseInfo(request.getUserId());<br>        <span class="hljs-type">UserSpecialInfoVO</span> <span class="hljs-variable">userSpecialInfoVo</span> <span class="hljs-operator">=</span> userSpecialInfoRepository.getUserSpecialInfo(request.getUserId());<br>        <br>        <span class="hljs-comment">// 业务异常返回失败状态</span><br>        <span class="hljs-keyword">if</span> (userSpecialInfoVo == <span class="hljs-literal">null</span>)&#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;failed&quot;</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// ... 更新context状态或处理其他业务逻辑</span><br>        context.setUserBaseInfo(userBaseInfoVo);<br>        context.setUserSpecialInfo(userSpecialInfoVo);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.编排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigurableProcessEngineImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProcessEngine</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Logger logger;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, Map&lt;String, String&gt;&gt; processMap;<br>    <span class="hljs-keyword">private</span> String initialProcessorName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConfigurableProcessEngineImpl</span><span class="hljs-params">(String jsonFilePath)</span> &#123;<br>        init(jsonFilePath);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(String jsonFilePath)</span> &#123;<br>        <span class="hljs-comment">// 读取JSON文件并解析为processMap和initialProcessorName</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonContent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Files.readAllBytes(Paths.get(jsonFilePath)));<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonConfig</span> <span class="hljs-operator">=</span> JSON.parseObject(jsonContent);<br>        <span class="hljs-built_in">this</span>.initialProcessorName = jsonConfig.getString(<span class="hljs-string">&quot;initialProcessor&quot;</span>);<br>        <span class="hljs-built_in">this</span>.processMap = parseProcessMap(jsonConfig.getJSONObject(<span class="hljs-string">&quot;processMap&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">currentProcessorName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.initialProcessorName;<br>        Processor currentProcessor;<br><br>        <span class="hljs-keyword">while</span> (currentProcessorName != <span class="hljs-literal">null</span>) &#123;<br>            currentProcessor = (Processor) applicationContext.getBean(currentProcessorName);<br>            String result;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (currentProcessor.needExecute(request, context)) &#123;<br>                    result = currentProcessor.execute(request, context);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    logger.info(<span class="hljs-string">&quot;Processor: &quot;</span> + currentProcessorName + <span class="hljs-string">&quot; skipped&quot;</span>);<br>                    result = <span class="hljs-string">&quot;Skipped&quot;</span>; <span class="hljs-comment">// 或者其他表示跳过的结果</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                result = <span class="hljs-string">&quot;Failed&quot;</span>; <span class="hljs-comment">// 或者其他表示失败的结果</span><br>                logger.error(<span class="hljs-string">&quot;Processor: &quot;</span> + currentProcessorName + <span class="hljs-string">&quot; failed, exception: &quot;</span> + Arrays.toString(e.getStackTrace()));<br>            &#125;<br><br>            currentProcessorName = determineNextProcessor(currentProcessorName, result);<br>        &#125;<br><br>        logger.info(<span class="hljs-string">&quot;ProcessEngine end, context: &quot;</span> + context);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">determineNextProcessor</span><span class="hljs-params">(String currentProcessorName, String result)</span> &#123;<br>        Map&lt;String, String&gt; decisionMap = processMap.get(currentProcessorName);<br>        <span class="hljs-keyword">if</span> (decisionMap == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> decisionMap.get(result);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析processMap</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, Map&lt;String, String&gt;&gt; <span class="hljs-title function_">parseProcessMap</span><span class="hljs-params">(JsonObject processMapJson)</span> &#123;<br>        <span class="hljs-comment">// 实现processMap的解析逻辑</span><br>        <span class="hljs-keyword">return</span> JSONObject.parseObject(processMapJson.toJSONString(),<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;Map&lt;String, Map&lt;String, String&gt;&gt;&gt;() &#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> UserInfoDTO <span class="hljs-title function_">doProcess</span><span class="hljs-params">(String request)</span> &#123;<br>    <span class="hljs-comment">// 创建流程引擎</span><br>    <span class="hljs-type">ConfigurableProcessEngineImpl</span> <span class="hljs-variable">processEngine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurableProcessEngineImpl</span>(<span class="hljs-string">&quot;/path/to/your/process-flow.json&quot;</span>);<br><br>    <span class="hljs-comment">// 启动流程引擎</span><br>    processEngine.start(request, context);<br><br><br>    <span class="hljs-comment">// ... 初始化请求和上下文对象</span><br>    <span class="hljs-type">ProcessRequest</span> <span class="hljs-variable">processRequest</span> <span class="hljs-operator">=</span> ProcessRequest.builder().userId(userId).build();<br>    <span class="hljs-type">ProcessContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> ProcessContext.builder().build();<br><br>    <span class="hljs-comment">// 启动引擎</span><br>    processEngine.start(processRequest, ctx);<br><br>    <span class="hljs-comment">// 从上下文对象中获取数据并填充返回对象</span><br>    <span class="hljs-keyword">return</span> UserInfoDTO.builder()<br>        .totalMoney(ctx.getTotalMoney())<br>        .maxAmount(ctx.getMaxAmount())<br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118172157467.png" alt="image-20240118172157467"></p><p>责任链：沿着这条链传递请求，直到有一个对象处理它为止，具体由哪个对象处理则在运行时动态决定的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">protected</span> Handler successor;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDiscountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;No discount applied.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowDiscountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">1000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Low discount applied. Amount: &quot;</span> + amount);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handleRequest(amount);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighDiscountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount &gt;= <span class="hljs-number">1000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;High discount applied. Amount: &quot;</span> + amount);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handleRequest(amount);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-keyword">private</span> Handler head;<br>    <span class="hljs-keyword">private</span> Handler tail;<br><br>    <span class="hljs-keyword">public</span> HandlerChain <span class="hljs-title function_">add</span><span class="hljs-params">(Handler handler)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = handler;<br>            tail = handler;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.setSuccessor(handler);<br>            tail = handler;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            head.handleRequest(amount);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChainDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>        chain.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LowDiscountHandler</span>())<br>             .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HighDiscountHandler</span>())<br>             .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NoDiscountHandler</span>());<br><br>        <span class="hljs-comment">// Making requests</span><br>        chain.handleRequest(<span class="hljs-number">500</span>);<br>        chain.handleRequest(<span class="hljs-number">1500</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-系统是个三明治"><a href="#4-系统是个三明治" class="headerlink" title="4.系统是个三明治"></a>4.系统是个三明治</h2><ul><li>提高复用性</li><li>降低耦合</li><li>提高可读性</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118195836506.png" alt="image-20240118195836506" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118195851875.png" alt="image-20240118195851875" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118200142854.png" alt="image-20240118200142854"></p><ul><li>[接口层] :对出入参仅做格式上的校验，不能涉及“例如用户是否在黑名单中”这样的校验。</li><li>[服务层] :负责编排流程、处理rpc请求、控制同异步。不能涉及领域概念。</li><li>[领域层] :针对领域规则来实现具体的能力。</li><li>[数据层] :仅对数据做CRUD,不能涉及对数据的额外加工。</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119160910358.png" alt="image-20240119160910358"></p><h2 id="5-DDD"><a href="#5-DDD" class="headerlink" title="5.DDD"></a>5.DDD</h2><p>复杂度提升</p><ul><li>满足基本需求</li><li>良好的扩展性</li><li>稳定性、性能</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119171329282.png" alt="image-20240119171329282"></p><p>设计策略：</p><ul><li>搞清功能</li><li>分析建模</li><li>便于拆分</li></ul><p><strong>case</strong>：卖家可以在网上挂商品售卖，买家可以选择商品并购买，购买后卖家会发快递，买家收到货后确认收货，网站把款项结算给卖家。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119172529042.png" alt="image-20240119172529042"></p><h3 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h3><p>解释业务，建立业务模型，划分业务边界</p><h4 id="事件风暴"><a href="#事件风暴" class="headerlink" title="事件风暴"></a>事件风暴</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119165000678.png" alt="image-20240119165000678"></p><p>事件：行为的结果（业务的重点），再通过事件反推整个流程</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119164946344.png" alt="image-20240119164946344"></p><h4 id="领域建模"><a href="#领域建模" class="headerlink" title="领域建模"></a><strong>领域建模</strong></h4><h5 id="分析领域模型"><a href="#分析领域模型" class="headerlink" title="分析领域模型"></a><strong>分析领域模型</strong></h5><ul><li><p>找出事件风暴中的名词</p></li><li><p>连接名词</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119172209854.png" alt="image-20240119172209854" style="zoom:50%;" /></li></ul><h5 id="找聚合："><a href="#找聚合：" class="headerlink" title="找聚合："></a><strong>找聚合</strong>：</h5><p>直接关系最多的节点</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119172306137.png" alt="image-20240119172306137"></p><h5 id="划分（限界上下文）"><a href="#划分（限界上下文）" class="headerlink" title="划分（限界上下文）"></a><strong>划分（限界上下文）</strong></h5><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119172428922.png" alt="image-20240119172428922" style="zoom: 67%;" /><p>1.整理出了重要的业务概念和规则.<br>2.所有角色都对概念对齐了认知<br>3.识别了重要的领域模型，继而指导了系统模型<br>4.做了系统划分</p><p>丛业务嘴里的模糊描述 -&gt;清晰的业务概念(多方认知)具体系统建设的内容</p><h3 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119173515013.png" alt="image-20240119173515013"></p><p><strong>领域模型</strong>：提供了基本的能力，包含业务规则（如类文件对外暴露的方法） </p><p><strong>领域服务</strong>：就是<strong>命令</strong>（动作），由多个领域模型聚合</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119173056903.png" alt="image-20240119173056903"></p><p>应用层：编排领域服务；同时需要处理消息（例如下单后的邮件通知通过事件驱动实现）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119173900690.png" alt="image-20240119173900690"></p><p>目录结构：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119174138306.png" alt="image-20240119174138306"></p><h2 id="6-0铁三角"><a href="#6-0铁三角" class="headerlink" title="6.0铁三角"></a>6.0铁三角</h2><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120125313890.png" alt="image-20240120125313890"></p><h2 id="6-还得是设计模式（扩展-功能扩展）"><a href="#6-还得是设计模式（扩展-功能扩展）" class="headerlink" title="6.还得是设计模式（扩展-功能扩展）"></a>6.还得是设计模式（扩展-功能扩展）</h2><ul><li>功能扩展</li><li>流量扩展</li></ul><p>看不懂 改不动 风险高</p><p>会写代码的人很多，写好的代码的人少</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120125646682.png" alt="image-20240120125646682" style="zoom:67%;" /><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转账服务</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> payer 付款方</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> payee 收款方</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> money 转账金额</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 是否转账成功</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String payer, String payee, String money)</span> &#123;<br>    Log.info(<span class="hljs-string">&quot;transfer start, payer=&#123;&#125;, payee=&#123;&#125;, money=&#123;&#125;&quot;</span>, payer, payee, money);<br><br>    <span class="hljs-comment">// 1.检查参数</span><br>    <span class="hljs-keyword">if</span> (!isValidUser(payer) || !isValidUser(payee) || !isValidMoney(money)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.调用转账服务</span><br>    <span class="hljs-type">TransferResult</span> <span class="hljs-variable">transferResult</span> <span class="hljs-operator">=</span> transferService.transfer(payer, payee, money);<br>    <span class="hljs-keyword">if</span> (!transferResult.isSuccess()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.查询用户通知方式</span><br>    <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> userInfoService.getUserInfo(payee);<br>    <span class="hljs-keyword">if</span> (userInfo.getNotifyType() == NotifyTypeEnum.SMS) &#123;<br>        <span class="hljs-comment">// smsNotifyService是第三方jar包</span><br>        smsClient.sendSms(payee, NOTIFY_CONTENT);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userInfo.getNotifyType() == NotifyTypeEnum.MAIL) &#123;<br>        <span class="hljs-comment">// mailNotifyService是第三方jar包</span><br>        mailClient.sendMail(payee, NOTIFY_CONTENT);<br>    &#125;<br><br>    <span class="hljs-comment">// 记录转账账单(发送事件给转账系统)</span><br>    billService.sendBill(transferResult);<br>    <span class="hljs-comment">// 转账监控打点(调用监控jdk)</span><br>    monitorService.sendRecord(transferResult);<br>    <span class="hljs-comment">// 记录转账额度(调用额度中心)</span><br>    quotaService.recordQuota(transferResult);<br><br>    Log.info(<span class="hljs-string">&quot;transfer success&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>入参出参不具备扩展性，可以考虑使用对象参数</p></li><li><p>参数的校验可以使用<strong>责任链</strong>优化，所有校验方法都添加到一个list中 <code>context.getBeansOfTypeParamValidator.class)</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120150550932.png" alt="image-20240120150550932"></p></li><li><p>通知方式，使用<strong>多态替换条件表达式</strong>  策略模式或适配器；和上面最大区别在于只执行一个而不是都执行 所以要一个一个添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotifyServiceManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SmsNotifyService smsNotifyService;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MailNotifyService mailNotifyService;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;NotifyTypeEnum, NotifyService&gt; notifyServiceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 注册通知类型到通知服务的映射关系</span><br>        notifyServiceMap.put(NotifyTypeEnum.SMS, smsNotifyService);<br>        notifyServiceMap.put(NotifyTypeEnum.MAIL, mailNotifyService);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(NotifyTypeEnum notifyTypeEnum, String userId, String content)</span> &#123;<br>        <span class="hljs-type">NotifyService</span> <span class="hljs-variable">notifyService</span> <span class="hljs-operator">=</span> notifyServiceMap.get(notifyTypeEnum);<br>        <span class="hljs-keyword">if</span> (notifyService == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Notify service not exist for type: &quot;</span> + notifyTypeEnum);<br>        &#125;<br>        notifyService.notifyMessage(userId, content);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后<strong>非主链路</strong>的统计、打点，使用<strong>观察者模式</strong>实现；并结合线<strong>程池加速及错误隔离</strong>；和校验器区别在于这是非主链路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransferObserver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(TransferResult transferResult)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BillServiceObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferObserver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(TransferResult transferResult)</span> &#123;<br>        billService.sendBill(transferResult);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorServiceObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferObserver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(TransferResult transferResult)</span> &#123;<br>        monitorService.sendRecord(transferResult);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;TransferObserver&gt; transferObserverList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 异步线程池</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Map&lt;String, TransferObserver&gt; transferObserverMap = applicationContext.getBeansOfType(TransferObserver.class);<br>        transferObserverMap.values().forEach(<span class="hljs-built_in">this</span>::addObserver);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 触发观察者</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(TransferResult transferResult)</span> &#123;<br>        transferObserverList.forEach(transferObserver -&gt; &#123;<br>            <span class="hljs-comment">// 异步执行</span><br>            executorService.execute(() -&gt; transferObserver.update(transferResult));<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加观察者</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(TransferObserver transferObserver)</span> &#123;<br>        transferObserverList.add(transferObserver);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>至此新增参数校验、通知类型、后处理等，<code>transfer</code>方法不用修改</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120153221074.png" alt="image-20240120153221074"></p><h2 id="7-没有扛不住的流量（扩展-流量扩展）"><a href="#7-没有扛不住的流量（扩展-流量扩展）" class="headerlink" title="7.没有扛不住的流量（扩展-流量扩展）"></a>7.没有扛不住的流量（扩展-流量扩展）</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>可能存在的问题： </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120180511652.png" alt="image-20240120180511652"></p><p>此外，还需要拦截恶意的流量，并在特殊情况下对部分有效流量进行降级</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120180655965.png" alt="image-20240120180655965"></p><h3 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h3><ul><li><p>流量的路由（负载均衡，直接平均或者按照机器性能，实际上机器同样，所以直接平均，降低负载均衡时的复杂度）</p><ol><li>DNS</li><li>NGINX  没有自动服务发现的能力</li><li>Eueka Nacos Consul</li></ol><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120181702521.png" alt="image-20240120181702521"></p></li><li><p>服务器间的数据共享问题（实现无状态）</p><ol><li><p>最简单的方式：复制或者拆分；；引入额外的效率 复杂度 一致性问题</p></li><li><p>数据中心化：缓存以及磁盘都放到中心化的服务上</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120182017970.png" alt="image-20240120182017970"></p></li></ol></li></ul><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120182133557.png" alt="image-20240120182133557" style="zoom:50%;" /><p>也就是微服务拆分，使得服务间不受到影响，隔离风险；灵活配置合理分配资源</p><h3 id="单元化部署"><a href="#单元化部署" class="headerlink" title="单元化部署"></a>单元化部署</h3><p>通常情况下前两种够了，但：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120183320165.png" alt="image-20240120183320165"></p><p>根据用户的id，在服务上以及数据（sharding）上都进行拆分</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120183309123.png" alt="image-20240120183309123"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120183359206.png" alt="image-20240120183359206" style="zoom: 67%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120184018167.png" alt="image-20240120184018167"></p><h2 id="8-读的慢有妙招（性能）"><a href="#8-读的慢有妙招（性能）" class="headerlink" title="8.读的慢有妙招（性能）"></a>8.读的慢有妙招（性能）</h2><p>性能：</p><ul><li>读性能</li><li>写性能</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120192800027.png" alt="image-20240120192800027"></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="使用层面"><a href="#使用层面" class="headerlink" title="使用层面"></a>使用层面</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120185031580.png" alt="image-20240120185031580"></p><h4 id="本地-vs-中心"><a href="#本地-vs-中心" class="headerlink" title="本地 vs 中心"></a>本地 vs 中心</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120185122795.png" alt="image-20240120185122795"></p><p>甚至于同时使用多级缓存</p><h4 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h4><ol><li>添加过期时间</li><li><strong>先更新DB再删除缓存</strong>cache aside pattern（小概率：B来的时候没有缓存，B读取数据库，A更新数据并删除redis，B写脏数据到redis）<ul><li><strong>更新DB再更新缓存、更新缓存再更新db</strong>：<ol><li>同时更新时顺序问题  </li><li>多次更新时重复无效的更新</li><li>此外更新缓存再更新db，如果更新db失败，缓存不好回滚</li></ol></li><li><strong>删除缓存再更新db</strong>：A删完缓存来了查询B，B查询完成后写入脏数据到redis</li></ul></li><li>延时双删：先更新DB再删除缓存，再异步删除   （实际上网上资料都是先删除缓存再更新DB，再异步删除）</li><li>缓存永不过期，并且周期性全量刷新</li></ol><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>DB的访问做读写分离，写在主，binlog等方式同步到从</p><p><strong>一致性问题</strong>：</p><ul><li><p>大部分时间忽略</p></li><li><p>前端直接短暂延时</p></li><li><p>强一致场景强制读主</p></li><li><p>路由标记，引入了一个标记（过期时间大于同步时间）作为同步标记，会导致多一次读缓存，巧妙但不推荐</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120191525962.png" alt="image-20240120191525962" style="zoom:67%;" /></li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>一个通用的思路，针对性能问题通用解决方案</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120191900959.png" alt="image-20240120191900959"></p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120192137793.png" alt="image-20240120192137793"></p><p>其实就是之前提到的转载后的打点使用异步线程池实现，主线程直接返回</p><h3 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h3><ul><li>分页</li><li>递进展示</li><li>降低极致的准确性要求，允许短暂的不一致</li><li>峰值流量降级非重要功能</li><li>控制主动（点击重试）或被动（超时重试）重试</li></ul><p>其他    优化协议、流量拦截、静态缓存、数据压缩等等</p><h2 id="9-写性能难提升（性能）"><a href="#9-写性能难提升（性能）" class="headerlink" title="9.写性能难提升（性能）"></a>9.写性能难提升（性能）</h2><p>为什么难？</p><ol><li>写的<strong>丢失代价</strong>大</li><li>写<strong>必须要磁盘</strong>（可靠性场景），而读可以是缓存</li><li>写时常需要<strong>加锁</strong></li><li><strong>资损</strong></li></ol><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121204714055.png" alt="image-20240121204714055"></p><h3 id="合理加锁"><a href="#合理加锁" class="headerlink" title="合理加锁"></a>合理加锁</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121205243774.png" alt="image-20240121205243774"></p><h3 id="异步-1"><a href="#异步-1" class="headerlink" title="异步"></a>异步</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121222045378.png" alt="image-20240121222045378"></p><p>优化方案的轮询是查询缓存的，放置数据库压力过大</p><p>TODO：添加一个<strong>缓存标记</strong>，可以用在判题请求中，这样轮询时就不用查询数据库</p><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><ul><li><p>db批量操作快、减少加锁释放锁时间</p></li><li><p>缺点：更新存在延时<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121222926648.png" alt="image-20240121222926648"></p></li><li><p>方案二（<strong>缓冲记账</strong>）引入了流水数据库表，实现持久化了数据但不用加锁</p></li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p><strong>文件系统的写入通常比数据库写入要快</strong>，之后再把文件同步到db，同步时可以使用拆分思想并发处理</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121223503832.png" alt="image-20240121223503832"></p><h3 id="缓存-1"><a href="#缓存-1" class="headerlink" title="缓存"></a>缓存</h3><p>并不需要百分百正确，缓存挂了就捞取redis自带的持久化数据，或者自己定时任务捞取缓存持久化到数据库</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121223646419.png" alt="image-20240121223646419"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121224327937.png" alt="image-20240121224327937"></p><h2 id="10-稳定性引入"><a href="#10-稳定性引入" class="headerlink" title="10.稳定性引入"></a>10.稳定性引入</h2><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121225347286.png" alt="image-20240121225347286"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121225544326.png" alt="image-20240121225544326"></p><p>核心服务4个9：52.6 mins 一年不可用时间</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121231622560.png" alt="image-20240121231622560"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121231642209.png" alt="image-20240121231642209"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121231724254.png" alt="image-20240121231724254"></p><h3 id="总结引入"><a href="#总结引入" class="headerlink" title="总结引入"></a>总结引入</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121232021199.png" alt="image-20240121232021199"></p><h2 id="11-稳定性之设计时"><a href="#11-稳定性之设计时" class="headerlink" title="11.稳定性之设计时"></a>11.稳定性之设计时</h2><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><ol><li><p>请求携带唯一ID（可以前端生成也可也后端生成返回）</p></li><li><p>后端流水数据库唯一ID key，业务前需要先落库流水数据库实现幂等</p></li><li><p>更进一步，添加分布式锁</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122122058300.png" alt="image-20240122122058300"></p></li></ol><h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122123053045.png" alt="image-20240122123053045"></p><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>避免被下游影响；强依赖变成弱依赖，账单服务失败不能影响查询余额接口；</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122123255388.png" alt="image-20240122123255388"></p><ol><li>前端直接拆分成两个请求</li><li>直接try catch，这里还是会对下游发起请求，如果下游返回时间比较长，还需要等待</li><li>通过配置中心（一般会缓存到本地，配置变更再推送），根据配置决定是否请求</li></ol><h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><p>避免被上游影响</p><ul><li>限制流量</li><li>控制速度</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122123755636.png" alt="image-20240122123755636"></p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122124816983.png" alt="image-20240122124816983"></p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>旧接口进行了改造，字段发生了变化</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122124959078.png" alt="image-20240122124959078"></p><p><strong>标准方法</strong>：后端逻辑需要<strong>兼容旧逻辑</strong>，前端字段冗余，新旧逻辑都要传递；之后定时清理</p><p>因此在该变更场景中，实际上是先新增一个字段，再清理时删除原字段</p><h3 id="打日志"><a href="#打日志" class="headerlink" title="打日志"></a>打日志</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122130621494.png" alt="image-20240122130621494"></p><ul><li>可以接受的错误，存在降级策略：warn</li><li>预期之外、会终端流程：error</li><li>大厂最佳实践通常是异步打印日志：磁盘 -&gt; 发送到队列，由别的线程负责</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240124152012901.png" alt="image-20240124152012901"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240124154346120.png" alt="image-20240124154346120"></p><h4 id="摘要日志"><a href="#摘要日志" class="headerlink" title="摘要日志"></a>摘要日志</h4><p>可以结合工具做统计，可视化等</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240124154157858.png" alt="image-20240124154157858"></p><h2 id="12-稳定性之变更时"><a href="#12-稳定性之变更时" class="headerlink" title="12.稳定性之变更时"></a>12.稳定性之变更时</h2><p>升级产品功能、修复产品缺陷；80%故障</p><ul><li>代码发布</li><li>配置变更</li><li>数据库修改</li><li>库表变化</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122132115071.png" alt="image-20240122132115071"></p><p>兼容性和前面说的类似，<strong>下游同时兼容上游新旧代码</strong>  a调用b：a旧-b新、a新-b新、甚至于a新-b旧</p><h3 id="对比流量"><a href="#对比流量" class="headerlink" title="对比流量"></a>对比流量</h3><h4 id="流量复制"><a href="#流量复制" class="headerlink" title="流量复制"></a>流量复制</h4><p>预发布环境DB、Cache相同，因此只能针对读服务</p><ul><li>方法1. 线上在业务执行完成后转发到预发布环境，存在入侵</li><li>方法2. 在网关同时转发到两个环境</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122133710703.png" alt="image-20240122133710703"></p><h4 id="线下环境流量回放"><a href="#线下环境流量回放" class="headerlink" title="线下环境流量回放"></a>线下环境流量回放</h4><ul><li>将请求、RPC、中间件、DB都录制（框架实现线上录制功能，如果让你设计这个框架，如何实现？）</li><li>回放时全部mock掉</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122134112992.png" alt="image-20240122134112992"></p><h3 id="发布顺序"><a href="#发布顺序" class="headerlink" title="发布顺序"></a>发布顺序</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122134845701.png" alt="image-20240122134845701"></p><h3 id="容量评估（压测）"><a href="#容量评估（压测）" class="headerlink" title="容量评估（压测）"></a>容量评估（压测）</h3><p>唯一方法：压测</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122135140022.png" alt="image-20240122135140022"></p><h3 id="可监控"><a href="#可监控" class="headerlink" title="可监控"></a>可监控</h3><p>埋点、日志、异常、机器指标、成功率、RT</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122135710503.png" alt="image-20240122135710503"></p><h3 id="可灰度"><a href="#可灰度" class="headerlink" title="可灰度"></a>可灰度</h3><p>变更逐步生效</p><p>实现灰度：用户ID后两位</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122140351961.png" alt="image-20240122140351961"></p><h4 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h4><p>开关变量实现灰度，多次请求中途变更了开关</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122140557705.png" alt="image-20240122140557705"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122140708294.png" alt="image-20240122140708294"></p><h3 id="可回滚"><a href="#可回滚" class="headerlink" title="可回滚"></a>可回滚</h3><p>回滚不难，如何快速回滚，并且有时候存在新数据了，旧代码是否能够兼容或者数据回滚</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122141222095.png" alt="image-20240122141222095"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122141402267.png" alt="image-20240122141402267"></p><h2 id="13-稳定性之运行时"><a href="#13-稳定性之运行时" class="headerlink" title="13.稳定性之运行时"></a>13.稳定性之运行时</h2><p>跑着跑着出错了；真正故障时能做的事情很少，重点需要前期准备好</p><h3 id="监控-报警"><a href="#监控-报警" class="headerlink" title="监控+报警"></a>监控+报警</h3><p>包含日志的采集 &amp; 报警</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122163959159.png" alt="image-20240122163959159"></p><h3 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h3><p>主动模拟请求，周期性执行</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122164316168.png" alt="image-20240122164316168"></p><h3 id="对账系统"><a href="#对账系统" class="headerlink" title="对账系统"></a>对账系统</h3><p><a href="https://tech.meituan.com/2018/03/21/balance-accounts.html">美团配送资金安全治理之对账体系建设 - 美团技术团队 (meituan.com)</a></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122164445756.png" alt="image-20240122164445756"></p><h4 id="实时"><a href="#实时" class="headerlink" title="实时"></a>实时</h4><ul><li>植入到链路中，失败立马进行拦截</li><li>影响核心链路性能</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122164531241.png" alt="image-20240122164531241"></p><h4 id="准实时"><a href="#准实时" class="headerlink" title="准实时"></a>准实时</h4><ul><li>通过异步发送消息或者监听binlog</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122164731540.png" alt="image-20240122164731540"></p><h4 id="离线"><a href="#离线" class="headerlink" title="离线"></a>离线</h4><p>定时拉取数据并做校验</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122164920770.png" alt="image-20240122164920770"></p><h3 id="分布式trance"><a href="#分布式trance" class="headerlink" title="分布式trance"></a>分布式trance</h3><p>还原链路的调用关系</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122165049137.png" alt="image-20240122165049137"></h3><h2 id="14-错误处理显真功（细节）"><a href="#14-错误处理显真功（细节）" class="headerlink" title="14.错误处理显真功（细节）"></a>14.错误处理显真功（细节）</h2><p>某些因素导致流程没有按照预期执行完成</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123151905647.png" alt="image-20240123151905647"></p><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><ul><li>入参校验（电话、金额）</li><li>中间用户信息结果判断</li><li>业务返回判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TransferResponse <span class="hljs-title function_">transfer</span><span class="hljs-params">(Transferparam transferparam)</span> &#123;<br>    <span class="hljs-comment">// 1.查询用户信息并校验</span><br>    <span class="hljs-type">UserInfoResult</span> <span class="hljs-variable">payerUserInfoResult</span> <span class="hljs-operator">=</span> userInfoService.queryUserInfo(transferParam.getPayerPhoneNo());<br>    <span class="hljs-type">UserInfoResult</span> <span class="hljs-variable">payeeUserInfoResult</span> <span class="hljs-operator">=</span> userInfoService.queryUserInfo(transferParam.getPayeePhoneNo());<br><br>    <span class="hljs-comment">// 2.转账</span><br>    <span class="hljs-type">TransferRequest</span> <span class="hljs-variable">transferRequest</span> <span class="hljs-operator">=</span> TransferRequest.builder()<br>        .payerId(payerUserInfoResult.getData().getUserId())<br>        .payeeId(payeeUserInfoResult.getData().getUserId())<br>        .money(transferParam.getMoney())<br>        .build(); <br>    transferService.transfer(transferRequest);<br><br>    <span class="hljs-comment">// 3. 记录额度</span><br>    quatoService.recordQuato(payerUserInfoResult.getData().getUserId(), transferParam.getMoney());<br><br>    <span class="hljs-keyword">return</span> TransferResponse.builder().retCode(SUCCESS_CODE).build();<br>&#125;<br><br><span class="hljs-keyword">public</span> TransferResponse <span class="hljs-title function_">transfer</span><span class="hljs-params">(Transferparam transferparam)</span> &#123;<br>    <span class="hljs-comment">// 输入参数校验</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">payerPhoneNo</span> <span class="hljs-operator">=</span> transferParam.getPayerPhoneNo();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">payeePhoneNo</span> <span class="hljs-operator">=</span> transferParam.getPayeePhoneNo();<br>    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> transferParam.getMoney();<br><br>    <span class="hljs-keyword">if</span> (!isValidPhoneNo(payerPhoneNo) || !isValidPhoneNo(payeePhoneNo)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid phone number&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (money == <span class="hljs-literal">null</span> || money.compareTo(BigDecimal.ZERO) &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid transfer amount&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 1.查询用户信息并校验</span><br>    <span class="hljs-type">UserInfoResult</span> <span class="hljs-variable">payerUserInfoResult</span> <span class="hljs-operator">=</span> userInfoService.queryUserInfo(payerPhoneNo);<br>    <span class="hljs-type">UserInfoResult</span> <span class="hljs-variable">payeeUserInfoResult</span> <span class="hljs-operator">=</span> userInfoService.queryUserInfo(payeePhoneNo);<br><br>    <span class="hljs-keyword">if</span> (payerUserInfoResult == <span class="hljs-literal">null</span> || payerUserInfoResult.getData() == <span class="hljs-literal">null</span> || payeeUserInfoResult == <span class="hljs-literal">null</span> || payeeUserInfoResult.getData() == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid user information&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2.转账</span><br>    <span class="hljs-type">TransferRequest</span> <span class="hljs-variable">transferRequest</span> <span class="hljs-operator">=</span> TransferRequest.builder()<br>        .payerId(payerUserInfoResult.getData().getUserId())<br>        .payeeId(payeeUserInfoResult.getData().getUserId())<br>        .money(money)<br>        .build(); <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">transferResult</span> <span class="hljs-operator">=</span> transferService.transfer(transferRequest);<br><br>    <span class="hljs-keyword">if</span> (!transferResult) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Transfer failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 记录额度</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">recordResult</span> <span class="hljs-operator">=</span> quatoService.recordQuato(payerUserInfoResult.getData().getUserId(), money);<br><br>    <span class="hljs-keyword">if</span> (!recordResult) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Failed to record quota&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TransferResponse.builder().retCode(SUCCESS_CODE).build();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="错误处理方式"><a href="#错误处理方式" class="headerlink" title="错误处理方式"></a>错误处理方式</h3><ul><li>返回<strong>错误码</strong> 可以包含更加复杂的信息；无性能损耗</li><li><strong>抛出异常</strong>  写起来简单 （目前主流rpc都支持异常传递）</li><li>都无法用于异步场景！</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123144451520.png" alt="image-20240123144451520"></p><p><strong>推荐</strong>：系统内使用中断，PRC接口交互错误码</p><h3 id="异步异常"><a href="#异步异常" class="headerlink" title="异步异常"></a>异步异常</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123145901501.png" alt="image-20240123145901501"></p><h3 id="错误码设计"><a href="#错误码设计" class="headerlink" title="错误码设计"></a>错误码设计</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123152917587.png" alt="image-20240123152917587"></p><p>这里是代码写死，也可也配置中心配置</p><h3 id="异常设计方式"><a href="#异常设计方式" class="headerlink" title="异常设计方式"></a>异常设计方式</h3><p>CommonException+枚举</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123152134856.png" alt="image-20240123152134856"></p><p>各种不同异常+上面：可以通过异常类型进行不同处理（降级等）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123152341699.png" alt="image-20240123152341699"></p><h3 id="异常映射错误码"><a href="#异常映射错误码" class="headerlink" title="异常映射错误码"></a>异常映射错误码</h3><p>由于内部是使用异常，返回给上游是状态码，最后需要catch将异常转换为外部状态码</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123153212173.png" alt="image-20240123153212173"></p><ul><li><p>不要吃掉异常，一定要打日志</p></li><li><p>调用方不要感知错误码，否则沟通更新成本高，需要和全部上游对齐</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123153725656.png" alt="image-20240123153725656"></p></li></ul><h2 id="15-打日志是技术活"><a href="#15-打日志是技术活" class="headerlink" title="15.打日志是技术活"></a>15.打日志是技术活</h2><p><a href="#%E6%89%93%E6%97%A5%E5%BF%97">打日志</a></p><h2 id="16-技术文档"><a href="#16-技术文档" class="headerlink" title="16.技术文档"></a>16.技术文档</h2><p>目的：</p><ul><li>确保方案可行</li><li>提早识别风险</li><li>对齐系统修改</li><li>评估工时投入</li></ul><h3 id="金币提现场景"><a href="#金币提现场景" class="headerlink" title="金币提现场景"></a>金币提现场景</h3><p><a href="https://www.yuque.com/codingbetterlife/lession/pka2nhb3yqoiqbhl?singleDoc">https://www.yuque.com/codingbetterlife/lession/pka2nhb3yqoiqbhl?singleDoc</a><br>密码：wsg3</p><h4 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h4><p>功能点：用户提现金币到银行卡，有每天的限额</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240125134907012.png" alt="image-20240125134907012"></p><ul><li>页面展示：总金币、可提现金币、额度、银行卡</li><li>准备提现：输入金额，并调取后端查询收费</li><li>确认提现：扣减金币到银行卡</li></ul><h4 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240125134931139.png" alt="image-20240125134931139"></p><p>其中具体的每一个具体服务使用流程引擎实现</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240125135035515.png" alt="image-20240125135035515"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>架构</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手学深度学习NLP</title>
    <link href="/2023/12/27/%E9%AB%98%E6%80%A7%E8%83%BD%E7%9F%AD%E9%93%BE%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/12/27/%E9%AB%98%E6%80%A7%E8%83%BD%E7%9F%AD%E9%93%BE%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>手动阀</p><p>原文链接：<a href="https://juejin.cn/post/6844904090602848270">高性能短链设计 - 掘金 (juejin.cn)</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>将长连接转为一个短连接，并且再访问时再转换回来</p><p>短链：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318150323802.png" alt="image-20240318150323802" style="zoom:50%;" /><p>最终长链</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318150335744.png" alt="image-20240318150335744"></p><p>可以看到，短信中的是短链，但最后变成了长链；使用短链的好处</p><ol><li>再具有文字限制的地方（微博），用短链可以占据更少的文字</li><li>短链对应转的二维码不密集，更容易识别</li></ol><p>跳转的基本实现：请求短链时，会返回状态码302（临时重定向：每次都使用短链请求，易于点击数统计）以及长链的地址</p><h2 id="生成算法"><a href="#生成算法" class="headerlink" title="生成算法"></a>生成算法</h2><h3 id="1-HASH"><a href="#1-HASH" class="headerlink" title="1.HASH"></a>1.HASH</h3><h4 id="生成hash"><a href="#生成hash" class="headerlink" title="生成hash"></a>生成hash</h4><p>将长信息转为断信息，最简单有效的方式就是hash</p><ol><li><strong>加密哈希函数（Cryptographic Hash Functions）</strong>：这些函数被设计为具有一系列加密属性，包括抗碰撞性（collision-resistant）、隐藏性（hiding）和抗篡改性（tamper-evident）。它们用于密码学安全、数据完整性验证等场合。常见的加密哈希算法有SHA-256、SHA-3、MD5（现在被认为是不安全的）等。</li><li><strong>非加密哈希函数（Non-cryptographic Hash Functions）</strong>：这些函数主要用于数据结构（如哈希表）中快速数据检索、数据压缩、负载均衡等非安全相关的场合。它们的设计重点在于速度和效率，而不是安全性。常见的非加密哈希函数包括MurmurHash、CityHash等。</li></ol><p>这里我们当然选择非加密的Hash算法，例如MurmurHash</p><p>MurmurHash 提供了两种长度的哈希值，32 bit，128 bit，为了让网址尽可通地短，我们选择 32 bit 的哈希值，32 bit 能表示的最大值近 43 亿，对于中小型公司的业务而言绰绰有余。对上文提到的极客长链做 MurmurHash 计算，得到的哈希值为 3002604296</p><h4 id="缩短长度："><a href="#缩短长度：" class="headerlink" title="缩短长度："></a>缩短长度：</h4><p>这里的数字都是十进制的表示，我们可以将10进制转为62进制（10+26+26；比base64少 + 和 &#x2F;，以及填充字符&#x3D;）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318151541698.png" alt="image-20240318151541698"></p><h4 id="解决哈希冲突并存储"><a href="#解决哈希冲突并存储" class="headerlink" title="解决哈希冲突并存储"></a>解决哈希冲突并存储</h4><p>短链映射长链：使用mysql 或 redis，配合唯一索引</p><p>此外，为了同一个长链不重复生成短链，需要将长链建议索引，为了索引不要太长使用长链的MD5建索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `short_url_map` (<br>  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,<br>  `lurl` varchar(160) DEFAULT NULL COMMENT &#x27;长地址&#x27;,<br>   `md5` char(32) DEFAULT NULL COMMENT &#x27;长链md5&#x27;,<br>  `surl` varchar(10) DEFAULT NULL COMMENT &#x27;短地址&#x27;,<br>  `gmt_create` int(11) DEFAULT NULL COMMENT &#x27;创建时间&#x27;,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><ol><li><p>查询长链的MD5是否已经存在，存在直接返回</p></li><li><p>将长链（lurl）经过 MurmurHash 后得到短链。</p></li><li><p>将长短链对应关系插入 db 中，如果 db 里不含有此短链的记录，则插入，如果包含了，说明违反了唯一性索引，此时只要给长链再加上我们上文说的自定义字段「DUPLICATE」,重新 hash 再插入即可，看起来在违反唯一性索引的情况下是多执行了步骤，但我们要知道 MurmurHash 发生冲突的概率是非常低的，基本上不太可能发生，所以这种方案是可以接受的。</p></li></ol><p>此外，快速有效判断一个元素是否存在可以使用布隆过滤器，先经过布隆过滤器再插入数据库</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318152646488.png" alt="image-20240318152646488" style="zoom:67%;" /><h3 id="2-自增序列"><a href="#2-自增序列" class="headerlink" title="2.自增序列"></a>2.自增序列</h3><h4 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318154514607.png" alt="image-20240318154514607" style="zoom:67%;" /><ol><li><p><strong>uuid</strong></p><p>UUID(Universally Unique Identifier)全局唯一标识符,是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的，但这种方式生成的 id 比较长，且无序，在插入 db 时可能会频繁导致<strong>页分裂</strong>，影响插入性能。<strong>无需中心化管理</strong></p></li><li><p><strong>redis</strong></p><p><code>INCR</code>：性能好，单机可支撑 10 w+ 请求，还可以做分布式</p><p>缺点：需要考虑持久化（短链 ID 总不能一样吧），灾备，成本有点高。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318153824226.png" alt="image-20240318153824226"></p></li><li><p><strong>Snowflake</strong></p><p>时钟回拨：抛出异常；延时等待（阻塞3ms）；序列号（增加序列号避免冲突）</p></li><li><p><strong>Mysql</strong> 自增</p><p>简单方便</p></li></ol><h4 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h4><p>如果用 Mysql 自增 id 作为短链 ID，在高并发下，db 的写压力会很大，这种情况该怎么办呢。</p><p>考虑一下，一定要在用到的时候去生成 id 吗，是否可以提前生成这些自增 id ?</p><p>发号表：代表已经发出去的id，每行为一个区间，给一台机器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318154839222.png" alt="image-20240318154839222"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318155037597.png" alt="image-20240318155037597"></p>]]></content>
    
    
    <categories>
      
      <category>文章精度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>文章精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU故障排查</title>
    <link href="/2023/12/17/CPU%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/"/>
    <url>/2023/12/17/CPU%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU故障排查"><a href="#CPU故障排查" class="headerlink" title="CPU故障排查"></a>CPU故障排查</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在压测考试的时候，无意间看到resource、teacher-admin等微服务CPU利用率百分之百，询问相关负责同学并不了解，于是自己寻找了一下原因。</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312251349397.png" alt="image-20231225130326585" style="zoom:50%;" /><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>​jstack可以定位线程的执行情况，因此直接进入pod内部执行，发现并没有找到此命令，查看dockerfile打包文件发现打包时是基于jre镜像构建的，并没有jdk中的其他工具，因此需要先安装工具。此外TOP等命令也没有，需要安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">// 先配置镜像<br><span class="hljs-keyword">echo</span> <span class="hljs-comment">&quot;deb http://mirrors.aliyun.com/debian/ buster main non-free contrib</span><br><span class="hljs-keyword">deb</span>-src http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian/ buster main non-free contrib<br><span class="hljs-keyword">deb</span> http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian-security buster/updates main<br><span class="hljs-keyword">deb</span>-src http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian-security buster/updates main<br><span class="hljs-keyword">deb</span> http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian/ buster-updates main non-free contrib<br><span class="hljs-keyword">deb</span>-src http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian/ buster-updates main non-free contrib<br><span class="hljs-keyword">deb</span> http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian/ buster-backports main non-free contrib<br><span class="hljs-keyword">deb</span>-src http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian/ buster-backports main non-free contrib<span class="hljs-comment">&quot; &gt; /etc/apt/sources.list</span><br><br><br>apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br><br>apt-<span class="hljs-built_in">get</span> install -<span class="hljs-keyword">y</span> procps<br>apt-<span class="hljs-built_in">get</span> install -<span class="hljs-keyword">y</span> curl<br><br><span class="hljs-built_in">mkdir</span> -<span class="hljs-keyword">p</span> /usr/share/man/man1<br>apt-<span class="hljs-built_in">get</span> install -<span class="hljs-keyword">y</span> openjdk-<span class="hljs-number">11</span>-jdk<br></code></pre></td></tr></table></figure><ul><li>执行TOP命令，定位微服务pid</li><li>执行 <code>ps H -eo pid, tid, %cpu | grep pid</code>  搜索出线程id以及cpu</li><li><code>printf &#39;0x%x\n&#39; pid</code>  将线程id转为16进制</li><li><code>jstack pid | grep  线程id</code>  查看线程执行的情况</li></ul><p>最后jstack定位发现该线程为守护进程，并没有给出具体的代码行以及其他信息，因此转向其他工具</p><h3 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -O https:<span class="hljs-regexp">//</span>arthas.aliyun.com/arthas-boot.jar<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/jvm/</span>java-<span class="hljs-number">1.11</span>.<span class="hljs-number">0</span>-openjdk-amd64<span class="hljs-regexp">/bin/</span>java -jar arthas-boot.jar <span class="hljs-comment"># 这里执行需要指定刚刚安装的jdk，否则默认只有jre会报错</span><br></code></pre></td></tr></table></figure><p>arthas给出了线程执行的代码行，直接定位到了错误代码，如下图</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312251349398.png" alt="image-20231225133834955"></p><p>至此错误的原因找到了。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这段代码的目的是为nacos添加一个推送变更配置，当dataid发生变化时，执行listener保存下最新的配置，官方文档如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">serverAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;serverAddr&#125;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;dataId&#125;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;group&#125;&quot;</span>;<br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.put(<span class="hljs-string">&quot;serverAddr&quot;</span>, serverAddr);<br><span class="hljs-type">ConfigService</span> <span class="hljs-variable">configService</span> <span class="hljs-operator">=</span> NacosFactory.createConfigService(properties);<br><span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> configService.getConfig(dataId, group, <span class="hljs-number">5000</span>);<br>System.out.println(content);<br>configService.addListener(dataId, group, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;recieve1:&quot;</span> + configInfo);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;);<br><br><span class="hljs-comment">// 测试让主线程不退出，因为订阅配置是守护线程，主线程退出守护线程就会退出。 正式代码中无需下面代码</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​但编码的同学理解错误了文档中while true的作用，当执行完<code>addListener</code>后，nacos会自动创建守护进程监听配置变化，如果<strong>所有非守护进程结束该守护进程才会结束</strong>，所以正式部署中并不需要执行<code>addListener</code>的线程一直存活，整个微服务当然会有非守护进程在执行，这段代码直接删去即可。</p><p>​此外，如果没有删除官方文档中的<code>Thread.sleep(1000);</code> 即便编码是错误的方式，其实也不会导致cpu直接占满</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>该段代码是在某些类的static代码块中调用，只有类被加载时才会导致该bug触发，所以可以看到图中有少部分pod并没有占满cpu</li><li>这个bug直接导致pod上cpu利用率占满（如果addListener两次，CPU直接会到200%），并且会触发动态扩容策略，导致第一张图中的一群pod中cpu都占满；</li><li>该代码编写在common中，导致用到的所有微服务（如resource、course）都会触发</li><li>修复后k8s集群整体cpu大幅度下降，弹性伸缩关闭了3台4核16G机器<br><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312251349400.png" alt="image-20231225133944117"></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
      <tag>优化</tag>
      
      <tag>水杉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考试重构-压测</title>
    <link href="/2023/11/23/%E8%80%83%E8%AF%95%E9%87%8D%E6%9E%84-%E5%8E%8B%E6%B5%8B/"/>
    <url>/2023/11/23/%E8%80%83%E8%AF%95%E9%87%8D%E6%9E%84-%E5%8E%8B%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>11&#x2F;10 ~ 11&#x2F;23</p><h3 id="重构原因"><a href="#重构原因" class="headerlink" title="重构原因"></a>重构原因</h3><ul><li>原来考试系统bug很多，redis使用也不合理，30人的考试就可能存在有人进不去考试、交不了卷的情况</li><li>原来的代码耦合性高，练习模式、考试模式可能开始考试用的不同函数、进入考试用的不同的函数，有时候改一个地方的功能影响到了另外的地方</li></ul><h3 id="重构基本思想"><a href="#重构基本思想" class="headerlink" title="重构基本思想"></a>重构基本思想</h3><ul><li>考试数据分为共享数据（题目、考试等）和个人做题数据，共享数据使用redis进行缓存，缓存时间可以小一点，个人做题数据时间需要改大一些，至少要超过考试的时间，防止学生答案丢失</li><li>原来代码做了预热逻辑，该部分对系统整体提升不大，删去；redis判活部分没有必要，redis可靠性还是很高的，如果想做redis开关也不应该用threadlocal，应该是一个统一开关</li><li>原来缓存答案逻辑是定时缓存，定时缓存系统负载很大，很多请求都是无效的请求，改成上下题切换时进行缓存</li><li>目前系统支持的考试类型包含：练习、考试、模拟考试、课程评价。不同的模式有不同的处理，使用多态来优化代码结构；《以多态取代条件表达式》</li><li>缓存答案有两种思想：一题一个key-value，一个key保存一个answerList，最终选择方案为answerList，可以避免进入考试时对redis的遍历插入以及考试结束时的遍历读取</li></ul><h3 id="重构步骤"><a href="#重构步骤" class="headerlink" title="重构步骤"></a>重构步骤</h3><ol><li>删除原来所有有关redis缓存的全部代码，测试</li><li>编写redis缓存通用类，将 （redis缓存不存在时，自动取数据库读取并插回redis）封装</li><li>编写公共缓存管理类，全部有关缓存的代码都在此进行，包括缓存不存在时的mybatisplus数据库读取操作，service必须使用这里暴露的公共方法（使用缓存），禁止在service中直接查询数据库。</li><li>在考试模式跑通测试后，编写多态代码扩展到（练习、考试、模拟考试、课程评价）模式</li><li>引入消息队列对交卷进行优化</li></ol><h4 id="redis通用类"><a href="#redis通用类" class="headerlink" title="redis通用类"></a>redis通用类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 序列化方式 GenericFastJsonRedisSerializer 可以直接强转</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCache</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> defaultExpiration;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TimeUnit defaultExpirationUnit;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisCache</span><span class="hljs-params">(RedisTemplate&lt;String, Object&gt; redisTemplate, <span class="hljs-type">long</span> defaultExpiration, TimeUnit defaultExpirationUnit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.defaultExpiration = defaultExpiration;<br>        <span class="hljs-built_in">this</span>.defaultExpirationUnit = defaultExpirationUnit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) redisTemplate.opsForValue().get(key);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(String key, Supplier&lt;T&gt; supplier, <span class="hljs-type">long</span> expiration, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (T) redisTemplate.opsForValue().get(key);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            value = supplier.get();<br>            put(key, value, expiration, unit);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公共缓存管理类"><a href="#公共缓存管理类" class="headerlink" title="公共缓存管理类"></a>公共缓存管理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonRedisCacheBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXAM_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;v2Exam:resourceId:%s&quot;</span>;<br><br>RedisTemplate&lt;String, Object&gt; objectRedisTemplate;<br>    <br>    <span class="hljs-keyword">public</span> RedisCache&lt;Exam&gt; EXAM_CACHE;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CommonRedisCacheBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;objectRedisTemplate&quot;)</span> RedisTemplate&lt;String, Object&gt; objectRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.objectRedisTemplate = objectRedisTemplate;<br>        <span class="hljs-built_in">this</span>.EXAM_CACHE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisCache</span>&lt;&gt;(objectRedisTemplate, <span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Exam <span class="hljs-title function_">getExam</span><span class="hljs-params">(String resourceId)</span>&#123;<br>        <span class="hljs-keyword">return</span> EXAM_CACHE.get(String.format(EXAM_KEY, resourceId),<br>                () -&gt; examMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;Exam&gt;().eq(Exam::getResourceId, resourceId)));<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseExamHandler</span> &#123;<br>    <span class="hljs-comment">// 获取提示getNotice 不实现，交给子类</span><br> <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getNotice</span><span class="hljs-params">(Exam exam)</span>&#123; <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;This method is not implemented&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 很多都一样，定义在父类</span><br>    <span class="hljs-keyword">public</span> ExamDataRes <span class="hljs-title function_">getExamInfo</span><span class="hljs-params">(String resourceId)</span> &#123;<br><span class="hljs-comment">// code</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExerciseHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseExamHandler</span>&#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 具体自己的实现</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getNotice</span><span class="hljs-params">(Exam exam)</span> &#123;<br>        Map&lt;String, Object&gt; noticeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">return</span> noticeMap;<br>    &#125;<br><span class="hljs-comment">// 直接调用父</span><br>    <span class="hljs-keyword">public</span> ExamDataRes <span class="hljs-title function_">getExamInfo</span><span class="hljs-params">(String resourceId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getExamInfo(resourceId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamHandlerFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, BaseExamHandler&gt; handlerMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ExamHandlerFactory</span><span class="hljs-params">(</span><br><span class="hljs-params">            ExerciseHandler exerciseHandler,</span><br><span class="hljs-params">            ExamHandler examHandler,</span><br><span class="hljs-params">            SimulationHandler simulationHandler,</span><br><span class="hljs-params">            EvaluateHandler evaluateHandler)</span> &#123;<br>        handlerMap.put(ExamType.EXERCISE, exerciseHandler);<br>        handlerMap.put(ExamType.EXAM, examHandler);<br>        handlerMap.put(ExamType.EXAM_SIMULATION, simulationHandler);<br>        handlerMap.put(ExamType.Evaluate, evaluateHandler);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BaseExamHandler <span class="hljs-title function_">getHandler</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> &#123;<br>        <span class="hljs-type">BaseExamHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> handlerMap.get(type);<br>        <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid exam type&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> handler;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BaseExamHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> examHandlerFactory.getHandler(exam.getType());<br>handler.startExam(resourceId, exam);<br></code></pre></td></tr></table></figure><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>​引入原因：考试有两个并发峰值：进入考试阶段以及交卷阶段，进入考试阶段设计数据库的读取操作（考生是否进入过考试，进入过需要取出答案），提交阶段涉及数据库的插入操作。海量的数据库插入操作会影响系统的并发，使用mq来优化可以减轻系统压力，削峰</p><p>mq使用逻</p><ul><li>在学生提交交卷请求时，立马更新redis，之后直接返回。redis更新成功代表考试交卷成功，并同时发送一个mq请求</li><li>mq消费者消费该消息，将数据从redis插入到数据库</li><li>mq消费函数是幂等的，mq需要保证至少一次消费</li></ul><h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><p>查看系统的负载</p><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p><strong>可能的影响因素：</strong></p><ul><li>代码质量，是否使用缓存，缓存命中率</li><li>exam pod数量，pod的Xmx</li><li>gateway 、usercenter pod数量</li><li>redis </li><li>mysql</li></ul><p><strong>注意：</strong></p><ol><li>pod扩容应该在考试前进行，动态扩容瞬间系统会炸</li><li>每次压测前注意清理oom的pod</li></ol><p><strong>参数：</strong></p><ul><li>人数x&#x3D;6k~10k</li><li>warm-up&#x3D;100s</li><li>题目延时5~180s，平均delay &#x3D; 92.5s</li></ul><p>进入峰值QPS &#x3D; 在进入考试warm结尾：x&#x2F;warm * 3(notices\startExam\getExamInfo) + x&#x2F;delay </p><p>另外当交卷开始时会达到第二个峰值</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>3pod压2k人，无压力</li><li>开启动态扩容，压4k人，扩容瞬间系统崩溃</li><li>提前给开好10pod 6k人，不使用mq，峰值在进入考试结尾以及交卷，尤其是交卷。交卷90%达到了10sRT。<ol><li>分析：exam-pod的cpu利用率不高，推测是gateway usercenter的原因（第一时间运维同学不在没有找到mysql的pod），扩容gateway usercenter发现还是没有用</li><li>rt:<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202311232119135.png" alt="image-20231122140548390"></li></ol></li><li>在找到<strong>mysql</strong>机器后发现mysql负载很高，理论上如果同一场考试同一批人连续压测，不应该有任何mysql请求，全部数据都进入了缓存，回到本地机器调试开启gateway usercenter的debug发现，任何一个请求都进行了额外数据库的查询，该查询不合理需要优化掉，因此本次压测暂时到此结束。</li><li>此外skywalking也给出了慢SQL，但是第一时间没有关注到</li></ol><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>在系统中，除了要关注自己写的代码外， 还需要注意整条链路；自己写的代码再好有别的瓶颈也没有用</li><li>cpu利用率是最简单的查看瓶颈的方式</li><li>可观测的重要性</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
      <tag>优化</tag>
      
      <tag>水杉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>simple-db</title>
    <link href="/2023/06/20/simple-db/"/>
    <url>/2023/06/20/simple-db/</url>
    
    <content type="html"><![CDATA[<h1 id="simple-db"><a href="#simple-db" class="headerlink" title="simple-db"></a>simple-db</h1><p>code：<a href="https://github.com/Goinggoinggoing/simple-db-hw-2021">Goinggoinggoing&#x2F;simple-db-hw-2021 (github.com)</a></p><p>基于java语言，实现一个简易事务支持的关系型数据库</p><p>难度：lab4 &#x3D; lab5 &gt; lab6 &gt;&gt;&gt;&gt;&gt;&gt; lab3 &gt; lab2 &gt; lab1 </p><ul><li><p>lab1 实现基本的数据结构<br>tuple, page, tupleDesc, iterator等等，难度不大</p></li><li><p>lab2 实现scan iterator</p><p>​基于scan iterator 来实现各种聚合函数，比如avg，count，sum，join等</p></li><li><p>lab3 join 优化</p><p>​建立一个优化模型， 按照主键，非主键，scan 表代价，直方图等进行成本估计，根据估计值来确定多表join的顺序</p></li><li><p>lab 4 事务以及锁</p><p>​这一章相对较难，要自己实现一个简单的读写锁，但是6.830中简化了，实现了page-level的锁，粒度比较粗，还有多种死锁的情况，test很给力，建议在写的时候一定要看清楚是哪个transaction 拿到了哪些page的哪些lock，而且这里的代码会影响到后面的lab 5、6，这里主要是按照两阶段锁协议并且no steal &#x2F; force 的策略</p><p>​代码中实现基于<strong>Timeout</strong>、<strong>Wait-for Graph</strong> 、 <strong>Global Orderings</strong>(wait-die)死锁检测算法</p></li><li><p>lab 5 B+ 树索引（TODO）</p><p>​实现B+树索引，插入、删除、修改，难点在于要把B+树结构以及这三种操作逻辑要捋清楚，还有父节点，子节点；叶子兄弟节点，非叶子节点的指针问题，以及一些边界条件。</p></li><li><p>lab 6 实现基于 log的rollback 和 recover</p><p>​lab中并没有真正存在undo log 和redo log，日志结构比较简单，只需要根据偏移处理即可，可以理解成是逻辑上的undo log 和 redo log。基于UNDO日志实现<strong>STEAL&#x2F;NO FORCE</strong>策略，提供更灵活的缓冲区管理；实现基本的WAL(Write-Ahead Logging)策略实现<strong>事务回滚与恢复</strong></p></li></ul><h3 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h3><p>Database Catalog Table(DbFile，多个page)  HeapPage( []Tuple ) Tuple( []Field) Field    </p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653182.png" alt="image-20230601175517493" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java">Tuple：一行记录的内容<br><span class="hljs-keyword">private</span> TupleDesc tupleDesc;<br><span class="hljs-keyword">private</span> Field[] fields;<br><span class="hljs-keyword">private</span> RecordId recordId; table-page-slot<br><br>TupleDesc： 单表或单行每列的类别信息<br>    <span class="hljs-keyword">private</span> List&lt;TDItem&gt; tdItems;   TDItem（fieldType, fieldName）<br><br>Catalog: 所有表信息，加载时载入内存<br>    <span class="hljs-keyword">public</span> HashMap&lt;Integer, Table&gt; tables;  key是DbFile.getId() 也就是tableid，hash(path)<br>Table：DbFile file, String name, String pkeyField   文件、表名、主键<br>             DbFile（HeapFile）: tableid 、TupleDesc、File(文件路径)<br>                  HeapFile：单张表 <br>                 包含多个page, readPage(pid)获得;读入单个page时，seek跳过前面<br><br><br><br>BufferPool: 缓存的page<br>    <span class="hljs-keyword">private</span> Map&lt;PageId, Page&gt; pageCache;<br>PageId：tableId、pgNo  哪张表的第几个page<br>         map中没有则调用dbFile.readPage(pid);  dbFile被catalog存下了<br>                   <br>            <br>            <br>HeapPageId： tableId pgNo 哪个表的第几page<br>            <br>RecordId： PageId tupleno 哪个page哪一个slot<br>            <br>HeapPage： (HeapPageId, data[])  从data[]中读取数据,转为一个page，data包含header data来自HeapFile.read<br>         HeapPageId 哪个表的第几page<br>         header[getHeaderSize()] 每个slot是否有数据<br>Tuple[numSlots]  每一行内容，每一行包含rid ,也就是(pid, slotId)<br>         td 行结构<br>            <br>     f:<br>getNumTuples(): floor((_page size_ * <span class="hljs-number">8</span>) / (_tuple size_ * <span class="hljs-number">8</span> + <span class="hljs-number">1</span>))<br>         getHeaderSize(): Math.ceil(getNumTuples() * <span class="hljs-number">1.0</span> / <span class="hljs-number">8</span>);<br><br>iterator() 返回数据tuple的迭代，基于List的Iterator<br>            <br>ex5       <br>HeapFile <span class="hljs-title function_">HeapFile</span><span class="hljs-params">(File f, TupleDesc td)</span>;<br>readPage(PageId pid) BufferPool会调用<br>            randomAccess.seek(pageSize * pageNumber);<br>            randomAccess.read(buffer);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapPage</span>((HeapPageId) pid, buffer);<br><br>writePage(page) 修改磁盘内容，写入page，如果pagenum&gt;当前则相当于插入<br>iterator(tid)返回整个表的迭代，一页一页从bufferpool中读，每页内部会调用heappage.iterator<br>            <br><br><br>ex6<br>SeqScan <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OpIterator</span>  对HeapFile包装, 为最基础的select * <br>TransactionId tid, <span class="hljs-type">int</span> tableid, String tableAlias;   包含别名,<br>之后的操作都是这样的，包含next hashnext  每次取出tuple<br><br>运算符是基于迭代器的；每个运算符都实现了 DbIterator 接口。<br>较低级别的运算符传递到较高级别运算符的构造函数中,使他们串联起来。叶子节点<br>Operators are connected together into a plan by passing lower-level operators into the constructors of higher-level operators, i.e., by <span class="hljs-string">&#x27;chaining them together.&#x27;</span> Special access method operators at the leaves of the plan are responsible <span class="hljs-keyword">for</span> reading data from the <span class="hljs-title function_">disk</span> <span class="hljs-params">(and hence <span class="hljs-keyword">do</span> not have any operators below them)</span>.<br><br>At the top of the plan, the program interacting with SimpleDB simply calls getNext on the root operator; <span class="hljs-built_in">this</span> operator then calls getNext on its children, and so on, until these leaf operators are called. They fetch tuples from disk and pass them up the <span class="hljs-title function_">tree</span> <span class="hljs-params">(as return arguments to getNext)</span>; tuples propagate up the plan in <span class="hljs-built_in">this</span> way until they are output at the root or combined or rejected by another operator in the plan.<br><br>For <span class="hljs-built_in">this</span> lab, you will only need to implement one SimpleDB operator.<br></code></pre></td></tr></table></figure><p>HeapPage:</p><p>对于一个只有两个int的表，单个page中，共4096B的数据，Tuple行数为4096* 8 &#x2F; 8*8+1 &#x3D; 504行，headsize&#x3D;504&#x2F;8&#x3D; 63B</p><p>也就是前63B都是head(484个空)，数据为00007cbd、7fffffff。创建过程在<code>HeapPageReadTest.java</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653183.png" alt="image-20230420143257673"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>数据获取，txt转为HeapPage可读取的文件格式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">原始数据</span> <span class="hljs-string">java</span> <span class="hljs-string">-jar</span> <span class="hljs-string">dist/simpledb.jar</span> <span class="hljs-string">convert</span> <span class="hljs-string">some_data_file.txt</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span><span class="hljs-string">,1,1</span><br><span class="hljs-number">2</span><span class="hljs-string">,2,2</span> <br><span class="hljs-number">3</span><span class="hljs-string">,4,4</span><br><br><span class="hljs-string">.bat</span><br><span class="hljs-number">0700 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0100</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0100 </span><span class="hljs-number">0000 </span><span class="hljs-number">0100 </span><span class="hljs-number">0000 </span><span class="hljs-number">0200 </span><span class="hljs-number">0000 </span><span class="hljs-number">0200</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0200 </span><span class="hljs-number">0000 </span><span class="hljs-number">0300 </span><span class="hljs-number">0000 </span><span class="hljs-number">0400 </span><span class="hljs-number">0000 </span><span class="hljs-number">0400</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> &#123;<br>    <span class="hljs-comment">// construct a 3-column table schema</span><br>    Type types[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Type</span>[]&#123; Type.INT_TYPE, Type.INT_TYPE, Type.INT_TYPE &#125;;<br>    String names[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123; <span class="hljs-string">&quot;field0&quot;</span>, <span class="hljs-string">&quot;field1&quot;</span>, <span class="hljs-string">&quot;field2&quot;</span> &#125;;<br>    <span class="hljs-type">TupleDesc</span> <span class="hljs-variable">descriptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TupleDesc</span>(types, names);<br><br>    <span class="hljs-comment">// create the table, associate it with some_data_file.dat</span><br>    <span class="hljs-comment">// and tell the catalog about the schema of this table.</span><br>    <span class="hljs-type">HeapFile</span> <span class="hljs-variable">table1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;some_data_file.dat&quot;</span>), descriptor);<br>    Database.getCatalog().addTable(table1, <span class="hljs-string">&quot;test&quot;</span>);<br><br>    <span class="hljs-comment">// construct the query: we use a simple SeqScan, which spoonfeeds</span><br>    <span class="hljs-comment">// tuples via its iterator.</span><br>    <span class="hljs-type">TransactionId</span> <span class="hljs-variable">tid</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionId</span>();<br>    <span class="hljs-type">SeqScan</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeqScan</span>(tid, table1.getId());<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// and run it</span><br>        f.open();<br>        <span class="hljs-keyword">while</span> (f.hasNext()) &#123;<br>            <span class="hljs-type">Tuple</span> <span class="hljs-variable">tup</span> <span class="hljs-operator">=</span> f.next();<br>            System.out.println(tup);<br>        &#125;<br>        f.close();<br>        Database.getBufferPool().transactionComplete(tid);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        System.out.println (<span class="hljs-string">&quot;Exception : &quot;</span> + e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h3><p>基本操作，需要继承Operator，实现<code>fetchNext</code>， Operator implements OpIterator</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653184.png" alt="image-20230426164343396"></p><p>基于装饰器模式，</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>和某个field比较，并过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate(<span class="hljs-type">int</span> field, Op op, Field operand)<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(Tuple t)</span>  将传入的tuple和构造函数中的值比较<br><br>Filter(Predicate p, OpIterator child)  对child(SeqScan)进行predicte过滤，只保留<span class="hljs-literal">true</span><br>    <span class="hljs-title function_">next</span><span class="hljs-params">()</span>方法获取下一个，依靠fetchNext，需要重写<br>    fetchNext:<br>            <span class="hljs-keyword">while</span> (child.hasNext())&#123;<br>                <span class="hljs-type">Tuple</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> child.next();<br>                <span class="hljs-keyword">if</span> (predicate.filter(next))&#123;<br>                    <span class="hljs-keyword">return</span> next;<br>                &#125;<br>            &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-meta">@Test</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filterSomeLessThan</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-built_in">this</span>.scan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestUtil</span>.MockScan(-<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, testWidth); <span class="hljs-comment">// -5~5</span><br>    Predicate pred;<br>    pred = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>(<span class="hljs-number">0</span>, Predicate.Op.LESS_THAN, TestUtil.getField(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 过滤到-5~2</span><br>    <span class="hljs-type">Filter</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>(pred, scan);<br>    TestUtil.<span class="hljs-type">MockScan</span> <span class="hljs-variable">expectedOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestUtil</span>.MockScan(-<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, testWidth);<br>    op.open();<br>    TestUtil.compareDbIterators(op, expectedOut);<br>    op.close();<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h4><p>根据JoinPredicate规定的列是否满足op</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">JoinPredicate(<span class="hljs-type">int</span> field1, Predicate.Op op, <span class="hljs-type">int</span> field2)<br>filter(Tuple t1, Tuple t2); 用于判断两个tuple的特定field是否相等（满足op），join时需要<br><br>Join(JoinPredicate p, OpIterator child1, OpIterator child2)<br>    fetchNext:<br>双重<span class="hljs-keyword">for</span>遍历child1 child2，留下满足条件的。为了配合实现迭代器，需要额外记录下外层tuple1<br></code></pre></td></tr></table></figure><h4 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h4><p>min max sum count  avg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">IntegerAggregator(<span class="hljs-type">int</span> gbfield, Type gbfieldtype, <span class="hljs-type">int</span> afield, Op what) 分组idx 分组类型 聚合idx<br>    HashMap&lt;Field, Tuple&gt; aggregate;   Field是分组的，映射到结果tuple<br>       <span class="hljs-string">&#x27;male&#x27;</span> -&gt; (<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-number">10</span>)<br>       <span class="hljs-string">&#x27;female&#x27;</span> -&gt; (<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-number">8</span>)<br>    min max sum count 直接在上面的映射里修改<br>    avg 需要额外维护sum count<br>        HashMap&lt;Field, Integer&gt; countsMap;<br>        HashMap&lt;Field, Integer&gt; sumMap;<br><br><span class="hljs-comment">// 不断传入tuple，并在agg中计算，iterator返回计算结果</span><br><span class="hljs-type">IntegerAggregator</span> <span class="hljs-variable">agg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntegerAggregator</span>(<span class="hljs-number">0</span>, Type.INT_TYPE, <span class="hljs-number">1</span>, Aggregator.Op.SUM);<br>agg.mergeTupleIntoGroup(scan1.next());<br>agg.iterator();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Aggregate(OpIterator child, <span class="hljs-type">int</span> afield, <span class="hljs-type">int</span> gfield, Aggregator.Op aop);<br>调用Aggregator的聚合 实现基本的Operator，策略模式<br><span class="hljs-type">Aggregate</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Aggregate</span>(scan1, afield=<span class="hljs-number">0</span>, gfield=<span class="hljs-number">0</span>,<br>            Aggregator.Op.MIN);<br></code></pre></td></tr></table></figure><h4 id="insert-delete"><a href="#insert-delete" class="headerlink" title="insert delete"></a>insert delete</h4><p>共HeapPage HeapFile BufferPool三层</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HeapPage: Tuple<br>Tuple t 插入当前page，所以pid要改成当前HeapPage的，slot按插入的位置来<br><br>HeapFile: tid Tuple   返回被操作的DirtyPage ArrayList&lt;Page&gt;  (注意操作的page是从pool中拿，会修改pool 但不修改文件)<br>删除：直接调用HeapPage  <br>插入：先选择一个插入，都满了就增加一个page(需要修改file文件的大小，也就是写入空数据，然后再从pool中拿)    实验中tuple2int，一个page504条，超出后自动增一page<br><br>BufferPool: tid Tuple。  去Catalog拿表信息 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>get<span class="hljs-constructor">Catalog()</span>.get<span class="hljs-constructor">DatabaseFile(<span class="hljs-params">tableid</span>)</span>;   需要把设置返回的为dirty 事务层面<br>删除：直接调用<br>插入：需要额外tableId代表插入到哪个表<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>get<span class="hljs-constructor">BufferPool()</span>.insert<span class="hljs-constructor">Tuple(<span class="hljs-params">tid</span>, <span class="hljs-params">empty</span>.<span class="hljs-params">getId</span>()</span>, t);<br><br>HeapWriteTest <span class="hljs-number">2</span>个<span class="hljs-built_in">int</span>一个page可以写<span class="hljs-number">504</span>条数据<br></code></pre></td></tr></table></figure><h4 id="Page-eviction"><a href="#Page-eviction" class="headerlink" title="Page eviction"></a>Page eviction</h4><p>对于一个2个int的表，共1024*504条数据，也就是1024个page，没有eviction全部存入时<code>63MB</code> ，50pages <code>3MB</code></p><p>evictPage：扔掉前flush</p><h5 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">evictPage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> DbException &#123;<br>Iterator&lt;Map.Entry&lt;PageId, Page&gt;&gt; iterator = pageCache.entrySet().iterator();<br>    <span class="hljs-keyword">if</span> (iterator.hasNext())&#123;<br>        Map.Entry&lt;PageId, Page&gt; next = iterator.next();<br>        <span class="hljs-type">PageId</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> next.getKey();<br>        <span class="hljs-type">Page</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> next.getValue();<br>        <span class="hljs-keyword">if</span> (page.isDirty() != <span class="hljs-literal">null</span>)&#123;<br>            flushPage(pid);<br>        &#125;<br>        iterator.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyData</span><span class="hljs-params">(PageId pageId)</span> &#123;<br>        <span class="hljs-keyword">if</span> (set.contains(pageId)) <span class="hljs-keyword">return</span> ;<br>        queue.offer(pageId);<br>        set.add(pageId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PageId <span class="hljs-title function_">getEvictPageId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">PageId</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> queue.poll();<br>        set.remove(peek);<br>        <span class="hljs-keyword">return</span> peek;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="LRU："><a href="#LRU：" class="headerlink" title="LRU："></a>LRU：</h5><p>双向链表+Hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUEvict</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EvictStrategy</span>&#123;<br><br>    Node tail;<br>    Node head;<br>    HashMap&lt;PageId, Node&gt; hashMap;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">LRUEvict</span><span class="hljs-params">()</span>&#123;<br>        hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>);<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>);<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyData</span><span class="hljs-params">(PageId pageId)</span> &#123;<br>        <span class="hljs-keyword">if</span>(hashMap.containsKey(pageId))&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> hashMap.get(pageId);<br>            moveToHead(node);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(pageId);<br>            addHead(node);<br>            hashMap.put(pageId, node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PageId <span class="hljs-title function_">getEvictPageId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> tail.prev;<br>        hashMap.remove(prev.pageId);<br>        removeNode(prev);<br><br>        <span class="hljs-keyword">return</span> prev.pageId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHead</span><span class="hljs-params">(Node node)</span>&#123;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        node.prev = head;<br>        head.next = node;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(Node node)</span>&#123;<br>        removeNode(node);<br>        addHead(node);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(Node node)</span> &#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        PageId pageId;<br>        Node prev;<br>        Node next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(PageId pageId)</span> &#123;<br>            <span class="hljs-built_in">this</span>.pageId = pageId;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>flushPage(pid)</code>：  如果pid脏的，就写回磁盘</li><li><code>discardPage(pid)</code>：直接扔掉某一个page</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> some_data_file1,<br>     some_data_file2<br><span class="hljs-keyword">WHERE</span> some_data_file1.field1 <span class="hljs-operator">=</span> some_data_file2.field1<br>  <span class="hljs-keyword">AND</span> some_data_file1.id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// construct a 3-column table schema</span><br>        Type types[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Type</span>[]&#123;Type.INT_TYPE, Type.INT_TYPE, Type.INT_TYPE&#125;;<br>        String names[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;field0&quot;</span>, <span class="hljs-string">&quot;field1&quot;</span>, <span class="hljs-string">&quot;field2&quot;</span>&#125;;<br><br>        <span class="hljs-type">TupleDesc</span> <span class="hljs-variable">td</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TupleDesc</span>(types, names);<br><br>        <span class="hljs-comment">// create the tables, associate them with the data files</span><br>        <span class="hljs-comment">// and tell the catalog about the schema  the tables.</span><br>        <span class="hljs-type">HeapFile</span> <span class="hljs-variable">table1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;lab2_file1.dat&quot;</span>), td);<br>        Database.getCatalog().addTable(table1, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">HeapFile</span> <span class="hljs-variable">table2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;lab2_file2.dat&quot;</span>), td);<br>        Database.getCatalog().addTable(table2, <span class="hljs-string">&quot;t2&quot;</span>);<br>    <br>    <span class="hljs-comment">// 上面的是加载数据库表信息到Catalog，运行在数据库系统启动时</span><br>    <span class="hljs-comment">// ------------------------------------------------------------------------------</span><br>    <span class="hljs-comment">// 下面是用户执行查询请求</span><br><br>        <span class="hljs-comment">// construct the query: we use two SeqScans, which spoonfeed</span><br>        <span class="hljs-comment">// tuples via iterators into join</span><br>        <span class="hljs-type">TransactionId</span> <span class="hljs-variable">tid</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionId</span>();<br><br>        <span class="hljs-type">SeqScan</span> <span class="hljs-variable">ss1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeqScan</span>(tid, table1.getId(), <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-type">SeqScan</span> <span class="hljs-variable">ss2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeqScan</span>(tid, table2.getId(), <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        <span class="hljs-comment">// create a filter for the where condition</span><br>        <span class="hljs-type">Filter</span> <span class="hljs-variable">sf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>(<span class="hljs-number">0</span>,<br>                        Predicate.Op.GREATER_THAN, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntField</span>(<span class="hljs-number">1</span>)), ss1);<br><br>        <span class="hljs-type">JoinPredicate</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JoinPredicate</span>(<span class="hljs-number">1</span>, Predicate.Op.EQUALS, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Join</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Join</span>(p, sf1, ss2);<br><br>        <span class="hljs-comment">// and run it</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            j.open();<br>            <span class="hljs-keyword">while</span> (j.hasNext()) &#123;<br>                <span class="hljs-type">Tuple</span> <span class="hljs-variable">tup</span> <span class="hljs-operator">=</span> j.next();<br>                System.out.println(tup);<br>            &#125;<br>            j.close();<br>            Database.getBufferPool().transactionComplete(tid);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">table1Id</span> <span class="hljs-operator">=</span> Database.getCatalog().getTableId(<span class="hljs-string">&quot;t1&quot;</span>)<br><br><span class="hljs-comment">// inset到t1表中</span><br>Database.getBufferPool().insertTuple(tid, table1Id, tuple);<br><br><span class="hljs-comment">// delete tuple中PageId 下 第TupleNumber slot的数据</span><br>Database.getBufferPool().deleteTuple(tid, tuple);<br><br><span class="hljs-comment">// 先读取全部数据</span><br><span class="hljs-type">SeqScan</span> <span class="hljs-variable">ss1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeqScan</span>(tid, table1Id, <span class="hljs-string">&quot;t1&quot;</span>);<br><br><span class="hljs-comment">// 过滤field0小于1的行</span><br><span class="hljs-type">Filter</span> <span class="hljs-variable">sf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>(<span class="hljs-number">0</span>,<br>                        Predicate.Op.GREATER_THAN, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntField</span>(<span class="hljs-number">1</span>)), ss1);<br><br><span class="hljs-comment">// aggregate afiele=1; gfield=2</span><br><span class="hljs-type">Aggregate</span> <span class="hljs-variable">ag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Aggregate</span>(sf1, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, Aggregator.Op.SUM);<br><br><span class="hljs-comment">// join  field1和field1</span><br><span class="hljs-type">JoinPredicate</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JoinPredicate</span>(<span class="hljs-number">1</span>, Predicate.Op.EQUALS, <span class="hljs-number">1</span>);<br><span class="hljs-type">Join</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Join</span>(p, sf1, ss2);<br></code></pre></td></tr></table></figure><h4 id="Query-Parser"><a href="#Query-Parser" class="headerlink" title="Query Parser"></a>Query Parser</h4><p>读取表数据 并运行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">java -jar dist/simpledb.jar parser catalog.<span class="hljs-function">txt</span><br><span class="hljs-function"><span class="hljs-title">lab2_file1</span> (<span class="hljs-params">f1 <span class="hljs-built_in">int</span>, f2 <span class="hljs-built_in">int</span>, f3 <span class="hljs-built_in">int</span></span>)</span><br><span class="hljs-function"><span class="hljs-title">lab2_file2</span> (<span class="hljs-params">f1 <span class="hljs-built_in">int</span>, f2 <span class="hljs-built_in">int</span>, f3 <span class="hljs-built_in">int</span></span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">select</span> d.f1, d.f2 <span class="hljs-keyword">from</span> lab2_file1 d</span>;<br><br><span class="hljs-keyword">where</span>语句报错？<br></code></pre></td></tr></table></figure><h3 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h3><ul><li>通过分析表的统计信息，可以估算不同查询计划的成本。计划的成本与中间连接和选择的元组数量、过滤器和连接谓词的选择性相关。</li><li>使用这些统计数据  order joins and selections  to get an <strong>optimal</strong> way</li></ul><p>selectivity: 筛选比例</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653185.png" alt="image-20230606152332166"></p><p>在这个实验中，我们只关注连接和基本表访问序列的成本。我们不必担心访问方法的选择（因为我们只有一种访问方法，即表扫描），也不必考虑其他操作符（如聚合）的成本。</p><h4 id="Filter-Selectivity"><a href="#Filter-Selectivity" class="headerlink" title="Filter Selectivity"></a>Filter Selectivity</h4><p>base on histogram，to get <code>ntups</code> with one or more predicates </p><ul><li><em>f&#x3D;const</em>：<em>h&#x2F;w</em></li><li><em>f&gt;const</em>：<em>h_b &#x2F; ntups x   (b_right - const) &#x2F; w_b   + buckets( b+1…NumB-1)</em></li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653186.png" alt="image-20230606161236443"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] buckets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">IntHistogram</span><span class="hljs-params">(<span class="hljs-type">int</span> buckets, <span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addValue</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对于某一个tableid，创建从下标到Histogram的映射</span><br><span class="hljs-comment">// 扫描两次 第一次求出最大最小，第二次添加</span><br><span class="hljs-keyword">private</span> Map&lt;Integer, IntHistogram&gt; intHistogramMap;<br><span class="hljs-keyword">private</span> Map&lt;Integer, StringHistogram&gt; stringHistogramMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TableStats</span><span class="hljs-params">(<span class="hljs-type">int</span> tableid, <span class="hljs-type">int</span> ioCostPerPage)</span><br>    <br><span class="hljs-comment">// 返回某一个fieldid相对于某个值的比较</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">estimateSelectivity</span><span class="hljs-params">(<span class="hljs-type">int</span> field, Predicate.Op op, Field constant)</span><br>    intHistogramMap.get(field).estimateSelectivity(op, ((IntField) constant).getValue())<br>    <br><span class="hljs-comment">// 全表扫描代价 没有寻道时间 且 都不在pool中 IO_COST = 71</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">estimateScanCost</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> numPage * ioCostPerPage;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最后每一个table都生成一个TableStats</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, TableStats&gt; statsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="Join-cardinality"><a href="#Join-cardinality" class="headerlink" title="Join cardinality"></a>Join cardinality</h4><p> estimate the size (<code>ntups</code>) of <code>t1 join t2</code></p><ul><li>for equality joins, primary key &gt; non-primary key</li><li>For range scans  &gt;  non-primary key equality     估值product*0.3</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">estimateJoinCardinality</span><span class="hljs-params">(LogicalJoinNode j, <span class="hljs-type">int</span> card1, <span class="hljs-type">int</span> card2,</span><br><span class="hljs-params">                                   <span class="hljs-type">boolean</span> t1pkey, <span class="hljs-type">boolean</span> t2pkey, Map&lt;String, TableStats&gt; stats)</span> &#123;<br><span class="hljs-keyword">switch</span> (joinOp) &#123;<br>    <span class="hljs-keyword">case</span> EQUALS:<br>        <span class="hljs-keyword">if</span> (t1pkey &amp;&amp; !t2pkey) &#123;<br>            card = card2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!t1pkey &amp;&amp; t2pkey) &#123;<br>            card = card1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t1pkey &amp;&amp; t2pkey) &#123;<br>            card = Math.min(card1, card2);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            card = Math.max(card1, card2);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> NOT_EQUALS:<br>        <span class="hljs-comment">// 记录总数-等值记录数</span><br>        <span class="hljs-keyword">if</span> (t1pkey &amp;&amp; !t2pkey) &#123;<br>            card = card1 * card2 - card2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!t1pkey &amp;&amp; t2pkey) &#123;<br>            card = card1 * card2 - card1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t1pkey &amp;&amp; t2pkey) &#123;<br>            card = card1 * card2 - Math.min(card1, card2);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            card = card1 * card2 - Math.max(card1, card2);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 其他记录按范围查询计算</span><br>        card = (<span class="hljs-type">int</span>) (<span class="hljs-number">0.3</span> * card1 * card2);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Join-cost"><a href="#Join-cost" class="headerlink" title="Join cost"></a>Join cost</h4><p><code>p=t1 join t2 join ... tn</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scancost(t1) </span>+ <span class="hljs-keyword">scancost(t2) </span>+ <span class="hljs-keyword">joincost(t1 </span><span class="hljs-keyword">join </span><span class="hljs-built_in">t2</span>) +<br><span class="hljs-keyword">scancost(t3) </span>+ <span class="hljs-keyword">joincost((t1 </span><span class="hljs-keyword">join </span><span class="hljs-built_in">t2</span>) <span class="hljs-keyword">join </span><span class="hljs-built_in">t3</span>) +<br>... <br></code></pre></td></tr></table></figure><p><code>scancost(t1)</code> ：  the number of pages in t1 x <code>SCALING_FACTOR</code></p><p><code>joincost(t1 join t2)</code>： &#x3D; scancost(t1) + ntups(t1) x scancost(t2) &#x2F;&#x2F;IO cost </p><p>​+ ntups(t1) x ntups(t2)  &#x2F;&#x2F;CPU cost</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">estimateJoinCost</span><span class="hljs-params">(LogicalJoinNode j, <span class="hljs-type">int</span> card1, <span class="hljs-type">int</span> card2,</span><br><span class="hljs-params">            <span class="hljs-type">double</span> cost1, <span class="hljs-type">double</span> cost2)</span><br>cost1 + card1 * cost2 + card1 * card2;<br></code></pre></td></tr></table></figure><h4 id="Join-order"><a href="#Join-order" class="headerlink" title="Join order"></a>Join order</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CostCard</span> &#123;<br>    <span class="hljs-comment">/** The cost of the optimal subplan */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> cost;<br>    <span class="hljs-comment">/** The cardinality of the optimal subplan */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> card;<br>    <span class="hljs-comment">/** The optimal subplan */</span><br>    <span class="hljs-keyword">public</span> List&lt;LogicalJoinNode&gt; plan;<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;LogicalJoinNode&gt; <span class="hljs-title function_">orderJoins</span><span class="hljs-params">(</span><br><span class="hljs-params">    Map&lt;String, TableStats&gt; stats,</span><br><span class="hljs-params">    Map&lt;String, Double&gt; filterSelectivities, <span class="hljs-type">boolean</span> explain)</span><br>    <span class="hljs-keyword">throws</span> ParsingException &#123;<br><br>    <span class="hljs-comment">// some code goes here</span><br>    <span class="hljs-comment">//Replace the following</span><br>    <span class="hljs-comment">// some code goes here</span><br>    <span class="hljs-comment">//Replace the following</span><br>    <span class="hljs-type">PlanCache</span> <span class="hljs-variable">planCache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PlanCache</span>();<br>    <span class="hljs-type">CostCard</span> <span class="hljs-variable">bestCostCard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CostCard</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> joins.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= size; i++) &#123;<br>        <span class="hljs-comment">// 找出给定size的所有子集</span><br>        Set&lt;Set&lt;LogicalJoinNode&gt;&gt; subsets = enumerateSubsets(joins, i);<br>        <span class="hljs-keyword">for</span> (Set&lt;LogicalJoinNode&gt; subset : subsets) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">bestCostSoFar</span> <span class="hljs-operator">=</span> Double.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (LogicalJoinNode joinNode : subset) &#123;<br>                <span class="hljs-type">CostCard</span> <span class="hljs-variable">costCard</span> <span class="hljs-operator">=</span><br>                    computeCostAndCardOfSubplan(stats, filterSelectivities, joinNode, subset, bestCostSoFar, planCache);<br>                <span class="hljs-keyword">if</span> (costCard == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                bestCostSoFar = costCard.cost;<br>                bestCostCard = costCard;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bestCostSoFar != Double.MAX_VALUE) &#123;<br>                planCache.addPlan(subset, bestCostCard.cost, bestCostCard.card, bestCostCard.plan);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (explain) &#123;<br>        printJoins(bestCostCard.plan, planCache, stats, filterSelectivities);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bestCostCard.plan;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&quot;SELECT * FROM emp,dept,hobbies,hobby WHERE emp.c1 = dept.c0 AND hobbies.c0 = emp.c2 AND hobbies.c1 = hobby.c0 AND emp.c3 &lt; 1000;&quot;</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653187.png" alt="image-20230607161413205"></p><p>emp过滤后1500： 随机数最大值65530，1500≈（1000&#x2F;65535*10w）</p><h3 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h3><p>A <strong>transaction</strong> is a group of database actions (e.g., inserts, deletes, and reads) that are executed <em>atomically</em>;</p><ul><li><strong>Atomicity</strong>: Strict two-phase locking and careful buffer management ensure atomicity.</li><li><strong>Consistency</strong>: The database is transaction consistent by virtue of atomicity. Other consistency issues (e.g., key constraints) are not addressed in SimpleDB.</li><li><strong>Isolation</strong>: Strict two-phase locking provides isolation.</li><li><strong>Durability</strong>: A FORCE buffer management policy ensures durability (see Section 2.3 below).</li></ul><p>核心思想：<strong>NO STEAL&#x2F;FORCE</strong></p><p>To simplify your job, we recommend that you implement a <strong>NO STEAL&#x2F;FORCE</strong> buffer management policy.</p><ul><li>You shouldn’t evict dirty (updated) pages from the buffer pool if they are locked by an uncommitted transaction (this is NO STEAL).  <ul><li>由于只在最后刷盘，不需要undo了，失败只要重新从磁盘加载page即可</li></ul></li><li>On transaction commit, you should force dirty pages to disk (e.g., write the pages out) (this is FORCE). <ul><li>假设<code>transactionComplete</code>不会失败，这样就不需要redo log</li></ul></li></ul><h4 id="lock-acquire"><a href="#lock-acquire" class="headerlink" title="lock acquire"></a>lock acquire</h4><p>acquire and release locks in BufferPool</p><ul><li>Modify <code>getPage()</code> to block and acquire the desired lock before returning a page. 核心方法，阻塞获取锁</li><li>Implement <code>unsafeReleasePage(tid, pid)</code>. This method is primarily used for testing, and at the end of transactions. 释放tid在pid上的锁</li><li>Implement <code>holdsLock(tid, pid)</code> so that logic in Exercise 2 can determine whether a page is already locked by a transaction. tid是否锁住pid</li></ul><p>create data structures that keep track of which locks each transaction holds and check to see if a lock should be granted to a transaction when it is requested：<code>hashmap: pageid-&gt;locks</code></p><ul><li>插入 删除 查找都是调用pool的getPage，需要传入正确的permission</li><li>被操作的页置为dirty</li><li>插入时创建了新的page，能否正常锁定</li></ul><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p><code>strict two-phase locking</code>：This means that transactions should acquire the appropriate type of lock on any object before accessing that object and shouldn’t release any locks until after the transaction commits.</p><p>release a shared lock on a page after scanning it to find empty slots</p><h4 id="NO-STEAL"><a href="#NO-STEAL" class="headerlink" title="NO STEAL"></a>NO STEAL</h4><p>只evict非脏页，都是脏页就抛出异常。<code>AbortEvictionTest </code>  <code>testAllDirtyFails()</code>测试</p><h4 id="transactionComplete"><a href="#transactionComplete" class="headerlink" title="transactionComplete"></a>transactionComplete</h4><p><em>commits</em> or <em>aborts</em></p><p>途中可能抛出<code>TransactionAbortedException</code> 请求超时，死锁  如readpage</p><ul><li>commit：写回磁盘 释放锁</li><li>abort：重新从磁盘加载page  释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transactionComplete</span><span class="hljs-params">(TransactionId tid, <span class="hljs-type">boolean</span> commit)</span> &#123;<br>    <span class="hljs-keyword">if</span> (commit) &#123;<br>        flushPages(tid);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        recoverPages(tid);<br>    &#125;<br>    lockManager.completeTransaction(tid);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbortEvictionTest</code>测试 ：如果abort 插入的行是否还能找到</p><h4 id="Deadlocks-and-Aborts"><a href="#Deadlocks-and-Aborts" class="headerlink" title="Deadlocks and Aborts"></a>Deadlocks and Aborts</h4><p> detect <code>deadlock</code> and throw a <code>TransactionAbortedException</code>，被捕获后调用<code>transactionComplete</code></p><ol><li>a simple timeout policy（或者retry次数过多）</li><li>check for cycles in a dependency graph</li><li>全局排序：每个事务分配一个全局序号  <strong>WAIT-DIE</strong>(当前高就wait、否则rollback；保证环路中优先级最低的一定die) <strong>WOUND-WAIT</strong><ul><li>或者资源分配一个序号 哲学家，在这里代表着pageid 不好实现 因为pageid的读取顺序和业务相关</li><li>可能会中止本该成功的事务</li></ul></li></ol><p><code>DeadlockTest.java</code></p><p>t1读p1 t2读p2，然后t1写p2(等t2)  t2写p1(等t1)，就死锁了</p><p><code>TransactionTest.java</code></p><p>n个进程，首先都获取读锁，然后再进行一次删除和插入</p><p>锁升级时就会出现死锁等待</p><h5 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-type">long</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">2000</span>) + <span class="hljs-number">1000</span>;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (lockManager.acquire(pid, tid, perm)) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">if</span> (now - start &gt; timeout) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionAbortedException</span>();<br>    &#125;<br>    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 睡眠可以减少竞争 否则肯定过不了测试  但加了也很慢</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="cycle-check"><a href="#cycle-check" class="headerlink" title="cycle check"></a>cycle check</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(!lockManager.acquire(pid, tid, perm))&#123;<br>    Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));  <span class="hljs-comment">// 不加很慢 加了很快</span><br>&#125;<br><br><br><span class="hljs-comment">// acquire：</span><br><span class="hljs-comment">// 在获取锁失败时，检测有没有环</span><br><span class="hljs-keyword">if</span> (next.getValue().getLockType() == LockType.EXCLUSIVE || perm == Permissions.READ_WRITE)&#123;<br>    <span class="hljs-type">TidNode</span> <span class="hljs-variable">tidNow</span> <span class="hljs-operator">=</span> tidMap.getOrDefault(tid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TidNode</span>(tid));<br>    tidNow.next = tidMap.get(next.getValue().getTid());<br>    checkCycle(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;TidNode&gt;(), tidNow);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkCycle</span><span class="hljs-params">(HashSet&lt;TidNode&gt; visited, TidNode tidNode)</span> <span class="hljs-keyword">throws</span> TransactionAbortedException &#123;<br>    <span class="hljs-keyword">if</span>(visited.contains(tidNode))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionAbortedException</span>();<br>    &#125;<br>    visited.add(tidNode);<br>    <span class="hljs-keyword">if</span>(tidNode.next != <span class="hljs-literal">null</span>)&#123;<br>        checkCycle(visited, tidNode.next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="wait-die"><a href="#wait-die" class="headerlink" title="wait-die"></a>wait-die</h5><p>可以保证环路中，优先级最低的一定die</p><p>需要遍历全部资源冲突的(否则会失效)，如果存在优先级高的则die</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">unlock</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>    Map.Entry&lt;TransactionId, LockInfo&gt; next = iterator.next();<br>    <span class="hljs-keyword">if</span> (next.getKey().equals(tid))&#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (next.getValue().getLockType() == LockType.EXCLUSIVE || perm == Permissions.READ_WRITE)&#123;<br><br>        <span class="hljs-keyword">if</span>(tid.getId() &gt; next.getValue().getTid().getId())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionAbortedException</span>();<br>        &#125;<br><br>        unlock = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!unlock)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进阶：能否在获取失败后wait而不是自旋？    wait的锁住的对象不好处理    用map&lt;PageId, PageId&gt;尝试失败</p><h3 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h3><h3 id="lab6"><a href="#lab6" class="headerlink" title="lab6"></a>lab6</h3><ul><li>之前的pool中的脏页不能写回磁盘（NO STEAL），现在提供undo解决这一问题</li><li>commit后如果宕机怎么办？先写入日志，日志实现恢复</li></ul><p>You will implement rollback and recovery using the contents of the log file.</p><ul><li>undo：记录下修改 用于 abort</li><li>redo：恢复成功的事务</li></ul><p>STEAL and NO-FORCE：提供更灵活的缓冲区管理，允许commit前写回磁盘</p><p>​abort时，先根据日志把磁盘中的数据还原，再删除pool中的该页面，最后把pool中的脏页recover</p><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>因为可能没有commit就写回了（缓存空间不足 ，测试中通过<code>flushAllPages</code>模拟），需要写回前记录下写回前后的内容信息。当commit后，需要更新旧的信息</p><ol><li><p>Insert the following lines into <code>BufferPool.flushPage()</code> before your call to <code>writePage(p)</code>, where <code>p</code> is a reference to the page being written: 在page写回磁盘前，先将log写回，包含最开始的内容(<code>BeforeImage</code>)以及当前内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// append an update record to the log, with </span><br><span class="hljs-comment">// a before-image and after-image.</span><br><span class="hljs-type">TransactionId</span> <span class="hljs-variable">dirtier</span> <span class="hljs-operator">=</span> p.isDirty();<br><span class="hljs-keyword">if</span> (dirtier != <span class="hljs-literal">null</span>)&#123;<br>  Database.getLogFile().logWrite(dirtier, p.getBeforeImage(), p);<br>  Database.getLogFile().force();<br>&#125;<br><span class="hljs-keyword">if</span> (page.isDirty() != <span class="hljs-literal">null</span>)&#123;<br>    table.writePage(page);<br>    page.markDirty(<span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在commit并刷盘后，更新<code>BeforeImage</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">flushPages(tid)<br>    flushPage(pageId);<br>    <span class="hljs-comment">// use current page contents as the before-image</span><br>    <span class="hljs-comment">// for the next transaction that modifies this page.</span><br>    page.setBeforeImage();<br></code></pre></td></tr></table></figure></li></ol><p>先debug，查看在什么情况下会写log</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ABORT_RECORD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMMIT_RECORD</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UPDATE_RECORD</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BEGIN_RECORD</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CHECKPOINT_RECORD</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">NO_CHECKPOINT_ID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  日志文件开始<br>    <br>preAppend() 每次都调用 记录加一 或者重置日志<br><br>logXactionBegin(tid) 事务开始<br><br>logWrite(TransactionId tid, Page before, Page after) <br>page写回磁盘前，记录下写回前后的page<br><br><span class="hljs-title function_">logCommit</span><span class="hljs-params">(tid)</span> 提交事务<br><br>logAbort(tid) 回滚 <br>    需要rollback()<br><br>shutdown() 优雅关闭系统 记录下状态<br>logCheckpoint 关闭前记录下 tidToFirstLogRecord， 并在开头写入startCpOffset  <br>    写回所有脏页，log中只保存正在运行的tid的内容 minLogRecord 节约空间<br>logTruncate 截断以及commit的log内容，只保留正在运行的， 修改raf的指向<br><br></code></pre></td></tr></table></figure><p>log格式：type 和 tid，  内容  ,   最后写offset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">raf.writeInt(ABORT_RECORD);<br>raf.writeLong(tid.getId());<br><br>...<br>raf.writeLong(currentOffset);<br>currentOffset = raf.getFilePointer();<br></code></pre></td></tr></table></figure><h4 id="RollBack"><a href="#RollBack" class="headerlink" title="RollBack"></a>RollBack</h4><p><code>logFile/rollback()</code>：事务回滚后，把改事务修改的page还原到之前的状态</p><ol><li><p>修改了但已经写回磁盘：pool中存在但已经不是dirty(flushPage会写回磁盘并删除脏页标记)</p><ul><li>根据log找到该事务修改的pageId，读出before-image， 并写回（ tidToFirstLogRecord map到第一个log）</li><li>删除pool中的页面(这里丢弃了页面，注意evict中没丢会空指针，所以evict多加一个判断)</li><li>同一个pageId可能有多条log，最老的beforeimage才是正确的（page出去过后before就错了）</li></ul></li><li><p>修改了还在pool中的（No steal时只有这一个），直接recoverPages(tid) 对dirty把磁盘中读出来并覆盖</p></li></ol><p><code>TestAbort</code> and <code>TestAbortCommitInterleaved</code> sub-tests of the LogTest system test.</p><h4 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h4><ol><li>针对未commit的事务，回滚这些事务</li><li>针对已commit但可能还没同步写入磁盘，再次写回以确定一致性</li></ol><p>问题：flushAllPages中flushPage时会清除Dirty标记，清除后事务commit时<code>flushPages(tid)</code>就不会再次移出该page，导致pool中的beforeimage并不会更新  <code>TestCommitAbortCommitCrash</code>测出来的</p><ul><li>开源代码在commit时<code>flushPages(tid)</code>更新所有的old，该方案应该是错的，会影响还在进行中的其他事务</li><li>pool什么时候会被移出？ 页面不足时  也就是正常情况下是会在evict调用flushpage，之后一定会removepage，之后再次读入时oldpage就是最新的(对于进行中的当前事务oldpage是错的，但log中存了正确的)；也就是正常逻辑下不会出错，但flushAllPages会。所以需要在flushAllPages调用flushpage后也强制removepage一次就可以了</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>基于java语言，实现一个简易事务支持的关系型数据库</p><ul><li>实现基本的遍历、连接、聚合和删除等基本<strong>操作算子</strong>，以及基于直方图的查询优化</li><li>实现BufferPool缓存Page，且实现基于<strong>LRU</strong>的页面淘汰机制</li><li>实现<strong>页面级</strong>的共享锁、排他锁和锁升级，实现<strong>可串行化</strong>的并发策略</li><li>实现多种死锁检测算法：<strong>Timeout</strong>、<strong>Wait-for Graph</strong> 、 <strong>Global Orderings</strong>(wait-die)</li><li>基于UNDO日志实现<strong>STEAL&#x2F;NO FORCE</strong>策略，提供更灵活的缓冲区管理</li><li>实现基本的WAL(Write-Ahead Logging)策略实现<strong>事务回滚与恢复</strong></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/Cscprx/article/details/123418692">https://blog.csdn.net/Cscprx/article/details/123418692</a></p><p><a href="https://github.com/MIT-DB-Class/simple-db-hw-2021/blob/master">github</a></p><p><a href="https://gitee.com/wygandwind/simple-db/">Code</a></p><p><a href="https://gitee.com/wygandwind/simple-db/tree/master/src/java/simpledb/storage">wind&#x2F;SimpleDB - 码云 - 开源中国 (gitee.com)</a> <a href="https://www.wygandwdn.cn/article/62">风在哪个人博客 (wygandwdn.cn)</a></p><p><a href="https://blog.csdn.net/weixin_45834777/article/details/120595851">SimpleDb 实验报告_simpledb实验_跳着迪斯科学Java的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/402325847">MIT6.830 SimpleDB Lab1</a></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java项目</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发</title>
    <link href="/2023/06/12/java%E5%B9%B6%E5%8F%91/"/>
    <url>/2023/06/12/java%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>效率提升：</p><ul><li>异步，防止阻塞IO</li><li>充分发挥多核CPU</li></ul><h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ol><li>重写thread的run方法</li><li>创建runnable 抽象出来任务</li><li>FutureTask 带返回值  线程间通信</li></ol><p>核心Thread是创建一个线程，其中run方法或者Runnable只是代表具体的任务。如果main线程中调用Runnable.run该任务就是main执行的</p><p>extends Thread 并重写run方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// 要执行的任务</span><br> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>Runnable :当成参数传给thread，run方法默认会检查Runnable如果有就执行Runnable.run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的任务逻辑</span><br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// lambda:单个抽象方法的接口</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 线程的任务逻辑</span><br>&#125;);<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>FutureTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Callable</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<span class="hljs-comment">// 继承Runnable</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        t.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> task.get(); <span class="hljs-comment">// 阻塞等待返回结果</span><br>            System.out.println(s);<br>        &#125;  <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//重写线程任务类方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tasklist    jps</code>   <code>taskkill</code></p><p><code>top -H -p pid           jstack</code>  查看进程中线程信息</p><p>每一个线程都有一个独立的栈，栈内每个函数都会有栈帧。main线程中的三个函数：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808190.png" alt="image-20230607100221439"></p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>切换当前执行的线程</p><ul><li>CPU时间片</li><li>垃圾回收</li><li>更高优先权</li><li>线程主动调用sleep、yield、wait、 join、 park、 synchronized、 lock</li></ul><p>如何保存上下文信息？</p><ul><li>线程内程序计数器 记录运行到哪里</li><li>栈帧记录变量信息</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void <strong>start</strong>()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td></tr><tr><td>public void <strong>run</strong>()</td><td>线程启动后调用该方法</td></tr><tr><td>public void setName(String name)</td><td>给当前线程取名字</td></tr><tr><td>public void getName()</td><td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象，代码在哪个线程中执行</td></tr><tr><td>public static void <strong>sleep</strong>(long time)</td><td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td></tr><tr><td>public static native void <strong>yield</strong>()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td></tr><tr><td>public final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>public final void <strong>setPriority</strong>(int priority)</td><td>更改此线程的优先级，常用 1 5 10</td></tr><tr><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr><td>public final void <strong>join</strong>()</td><td>等待这个线程结束</td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td></tr><tr><td>public final native boolean isAlive()</td><td>线程是否存活（还没有运行完毕）</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td></tr></tbody></table><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><ul><li><strong>操作系统层面</strong>：新建 就绪 运行 阻塞(io) 终止</li><li><strong>java层面</strong>：其中Runnable包含 就绪 运行 阻塞(io)</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808191.png" alt="image-20230607112856036"></p><table><thead><tr><th>程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW（新建）</td><td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td>Runnable（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td>Blocked（阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态 <code>synchronized</code>      <strong>EntryList</strong></td></tr><tr><td>Waiting（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态. <code>wait</code>(WaitSet) <code>join</code>(原理wait) <code>park</code></td></tr><tr><td>Timed Waiting （限期等待）</td><td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。常用方法有 <code>Thread.sleep(time) 、wait(time)  </code> <code>join(time)</code> <code>parkUntil(time)</code></td></tr><tr><td>Teminated（结束）</td><td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">     */</span><br>    NEW,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">     * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">     * be waiting for other resources from the operating system</span><br><span class="hljs-comment">     * such as processor.</span><br><span class="hljs-comment">     */</span><br>    RUNNABLE,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">     * to enter a synchronized block/method or</span><br><span class="hljs-comment">     * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">     */</span><br>    BLOCKED,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread.</span><br><span class="hljs-comment">     * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">     * following methods:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">     * perform a particular action.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">     * on an object is waiting for another thread to call</span><br><span class="hljs-comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">     * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">     */</span><br>    WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">     * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">     * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     */</span><br>    TIMED_WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a terminated thread.</span><br><span class="hljs-comment">     * The thread has completed execution.</span><br><span class="hljs-comment">     */</span><br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><ul><li><code>public void interrupt()</code>：打断这个线程，异常处理机制</li><li><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong></li><li><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</li></ul><ol><li><p>线程处于<strong>阻塞</strong>状态：如果线程当前处于阻塞状态，如调用了 <code>Thread.sleep()</code>、<code>Object.wait()</code>、<code>join</code> <code>BlockingQueue.take()</code> 等阻塞方法，调用 <code>interrupt()</code> 方法会中断线程的阻塞状态，抛出 <code>InterruptedException</code> 异常，打断标记。因为线程都不在运行，所以需要抛异常来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    t1.interrupt();<br>    System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线程处于<strong>非阻塞</strong>状态：如果线程当前处于非阻塞状态，调用 <code>interrupt()</code> 方法会将线程的中断状态设置为 <code>true</code>，但不会中断线程的执行。可以通过检查中断状态来决定是否终止线程的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 主线程休眠 2 秒后中断子线程</span><br>Thread.sleep(<span class="hljs-number">2000</span>);<br>myThread.interrupt();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>            <span class="hljs-comment">// 线程执行的逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;Thread is running.&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Thread interrupted. Exiting...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="两阶段终止"><a href="#两阶段终止" class="headerlink" title="两阶段终止"></a>两阶段终止</h5><p>功能：记录系统的利用率，但需要能停止下来。<br>如果在sleep时被打断，则手动标记一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTInterrupt</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(current.isInterrupted()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    current.interrupt();<br>                &#125;<br>                <span class="hljs-comment">// 执行监控操作 </span><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="打断park"><a href="#打断park" class="headerlink" title="打断park"></a>打断park</h5><p>park阻塞线程类似于一直sleep，但被打断不会清空标记。需要标记为假时才生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);<br>        LockSupport.park();<br>        System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="hljs-comment">//打断状态：true</span><br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    t1.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><ul><li><code>public final void join()</code>等待该线程执行完成，原理上可以使用信号量PV</li><li><code>join(long millis)</code> 最大等待时间</li></ul><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>当其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><p><code>t1.setDaemon(true);</code></p><ul><li>垃圾回收器线程就是一种守护线程 </li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul><h2 id="共享模型之并发"><a href="#共享模型之并发" class="headerlink" title="共享模型之并发"></a>共享模型之并发</h2><p>访问共享变量时，代码的原子性（互斥）以及并发协调（同步）</p><ul><li>共享问题</li><li>synchronized</li><li>线程安全分析 </li><li>Monitor </li><li>wait&#x2F;notify </li><li>线程状态转换 </li><li>活跃性 </li><li>Lock 加以改进</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 共享资源</span><br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>        counter++;<br>     &#125;<br> &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br> <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>        counter--;<br>     &#125;<br> &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br></code></pre></td></tr></table></figure><ul><li>阻塞：synchronized、lock</li><li>非阻塞：原子变量</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>对象锁，同一时刻只有一个线程获取到针对该对象的锁，获取失败进入等待队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) <span class="hljs-comment">// 线程1， 线程2(blocked)</span><br>&#123;<br>临界区<br>&#125;<br><br>大括号相当于 获取锁 + 释放锁。  对象相当于locked<br>    没有获取到时会阻塞释放资源 相当于Futex <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span> (xchg(&amp;locked, <span class="hljs-number">1</span>)) ; &#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; xchg(&amp;locked, <span class="hljs-number">0</span>); &#125;<br></code></pre></td></tr></table></figure><p>加在成员方法上，锁<strong>对象</strong>  <code>synchronized(this)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步的代码块</span><br>&#125;<br><br>同一类中的多个函数，如果<span class="hljs-keyword">synchronized</span>了 也不能并行，因为对象被锁了而不是函数被锁了<br></code></pre></td></tr></table></figure><p>加在静态方法上，锁<strong>类对象</strong>  <code>synchronized(MyClass.class)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 同步的静态方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量理论是线程安全的（每个栈都有栈帧），成员变量和静态变量不是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但如果方法是public并且在子类中被修改了，就可能出错，所以private 或者 final的修饰符是有必要的，满足开<strong>闭</strong>原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadSafe</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h4><p>线程安全的类： 单一方法是安全的，组合不一定（想要安全还要额外上锁）</p><ul><li>java.lang.String、 java.lang.Integer  不可变对象</li><li>java.lang.StringBuffer</li><li>java.lang.Float</li><li>java.lang.Boolean</li><li>java.util.Vector</li><li>java.util.Hashtable</li><li>java.util.concurrent.ConcurrentHashMap</li></ul><p>非线程安全的类：</p><ul><li>java.lang.StringBuilder</li><li>java.util.ArrayList</li><li>java.util.LinkedList</li><li>java.util.HashMap</li><li>java.util.HashSet</li></ul><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>MyServlet只有一个，共享的。所以userService也是一个共享的。count不是安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>     <span class="hljs-comment">// 是否安全？</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>     userService.update(...);<br>     &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>     <span class="hljs-comment">// 记录调用次数</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// ...</span><br>     count++;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单例中的成员变量都是共享的。  改成环绕通知中的局部变量就解决了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>     <span class="hljs-comment">// 是否安全？</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br><br>     <span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>         start = System.nanoTime();<br>     &#125;<br><br>     <span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>         System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start));<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>dao中的数据库连接，不能共享否则被别人close了，所以每个查询都要在局部变量中获取一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br> <span class="hljs-comment">// 是否安全</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>         conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>         <span class="hljs-comment">// ...</span><br>         conn.close();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转账 锁住类对象，简单的解决办法但效率不高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Account.class)&#123;  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.money &gt; amount) &#123;<br>                <span class="hljs-built_in">this</span>.setMoney(<span class="hljs-built_in">this</span>.getMoney() - amount);<br>                target.setMoney(target.getMoney() + amount);<br>        &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808192.png" alt="image-20230609132432143" style="zoom: 80%;" /><p>Mark Word</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808194.png" alt="image-20230609132408757"></p><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor是JVM中提供的一个对象，负责管理某个对象的锁。我们的对象通过MarkWord中的指针指向monitor对象（一对一）  c++实现的</p><ul><li>获取成功为Owner</li><li>失败加入EntryList（还可以先进行<strong>自旋</strong>几次，如果还失败才加入，减少上下文切换   自适应）；</li><li>在thread-2释放时唤醒一个（线程的阻塞和唤醒操作是在<strong>Java虚拟机内部</strong>进行的，而不涉及到底层操作系统的系统调用）</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808195.png" alt="image-20230609133445269"></p><h4 id="字节码角度"><a href="#字节码角度" class="headerlink" title="字节码角度"></a>字节码角度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) <br>&#123;<br>count++;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了正常处理外，19~23为异常处理，也会释放锁</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808196.png" alt="image-20230609134409660"></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>优化：轻量级、偏向锁</p><ul><li><strong>轻量级锁</strong>：在竞争比较少的情况下，每次上锁太麻烦了；房门上挂书包  <strong>对使用者透明</strong></li><li><strong>偏向锁</strong>：直接在房门上课上名字，专属于谁</li></ul><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p><strong>锁记录</strong>：线程中负责记录 该线程锁住了哪些对象</p><ul><li><p>加锁：如果对象没被锁(01)，通过<strong>CAS</strong>让对象头保留锁记录地址，锁记录保存原对象头信息</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808197.png" alt="image-20230610113617600" style="zoom:67%;" /></li><li><p>加锁失败：如果对象已经被锁了(00)，<strong>锁膨胀</strong>：申请一个monitor，对象头指向monitor，加入entrylist</p></li><li><p>解锁：CAS再交换回来，如果发现对象被重量级锁锁住了，就进入重量级锁解锁流程</p></li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808198.png" alt="image-20230610114230079" style="zoom:67%;" /><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>轻量级锁问题：自己调用时，还需要指向<strong>CAS</strong>操作（这次一定会失败），偏向锁优化掉这个操作</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808199.png" alt="image-20230610123937238"></p><ul><li><p>把线程的ID放入MarkWord，以后轻量级锁前先查看线程ID是否是自己，自己就不用CAS了</p></li><li><p>如果threadID不是自己，升级为轻量级锁，解锁后变成normal</p><ul><li>（如果超过20次，会发生批量重新偏向，全部直接偏向t2）</li><li>（如果超过40次，直接所有新建对象不可偏向）</li></ul></li><li><p>偏向锁释放时，并不会清空threadID</p></li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808200.png" alt="image-20230610124244401" style="zoom: 80%;" /><ul><li>初始时默认状态就是该状态，但程序加载会有延时</li><li>可以手动禁用，或者hashCode()时会禁用（因为放不下，而在轻量级锁记录 重量级monitor会记录hash）</li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁压根不会发生冲突，则直接被优化掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>     <span class="hljs-keyword">synchronized</span> (o) &#123;<br>     x++;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="wait-x2F-notify"><a href="#wait-x2F-notify" class="headerlink" title="wait &#x2F; notify"></a>wait &#x2F; notify</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>等价于万能条件变量法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread A is waiting&quot;</span>);<br>        lock.wait();  <span class="hljs-comment">// 线程A等待</span><br>        System.out.println(<span class="hljs-string">&quot;Thread A is resumed&quot;</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread B is performing some task&quot;</span>);<br>        lock.notify();  <span class="hljs-comment">// 唤醒等待的线程A</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808201.png" alt="image-20230610133052012"></p><ul><li><p>在获取锁后，发现不满足情况，<code>lock.wait()</code>释放锁并进入<code>WaitSet</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex_lock(&amp;lk);<br><span class="hljs-keyword">if</span> (!cond) cond_wait(&amp;cv, &amp;lk); <span class="hljs-comment">// 睡眠前释放锁；在唤醒后，会重新尝试获取锁</span><br></code></pre></td></tr></table></figure></li><li><p>在被Owner <code>lock.notify</code>后，重新进入<code>EntryList</code>。<code>notifyAll()</code>唤醒全部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cond_signal(&amp;cv);<br>broadcast(&amp;cv);<br></code></pre></td></tr></table></figure></li><li><p>和<strong>操作系统不同点</strong>就是这里锁lk和唤醒信号cv都是lock对象</p></li></ul><p>同样可能会存在错误叫醒的情况，while + 广播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>     <span class="hljs-keyword">while</span>(!cond) &#123;<br>     lock.wait();<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="wait-sleep区别"><a href="#wait-sleep区别" class="headerlink" title="wait sleep区别"></a>wait sleep区别</h4><ul><li>wait 是Object方法；sleep是Thread方法</li><li>wait必须要先获取锁并且再释放锁，sleep不用且不会释放锁</li></ul><h4 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h4><ul><li>一个线程等待另外一个线程结果</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li><li>但如果是一直产生：消息队列（见生产者&#x2F;消费者）</li></ul><p>如果用join实现，必须要下载线程结束，并且变量要设置为全局的</p><h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>     <span class="hljs-keyword">private</span> Object response;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件不满足则等待</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件满足，通知等待线程</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            lock.notifyAll();<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 子线程执行下载 耗时</span><br>        List&lt;String&gt; response = download();<br>        log.debug(<span class="hljs-string">&quot;download complete...&quot;</span>);<br>        guardedObject.complete(response);<br>        <br>    &#125;).start();<br><br>    <span class="hljs-comment">// 主线程阻塞等待</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> guardedObject.get();<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="带超时"><a href="#带超时" class="headerlink" title="带超时"></a><strong>带超时</strong></h5><p>直接wait(time) break不行，因为存在虚假唤醒。记录等待时间防止多等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 1) 记录最初时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 2) 已经经历的时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">timePassed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> millis - timePassed;<br>            log.debug(<span class="hljs-string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);<br>            <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                log.debug(<span class="hljs-string">&quot;break...&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.wait(waitTime);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span><br>            timePassed = System.currentTimeMillis() - begin;<br>            log.debug(<span class="hljs-string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>, timePassed, response == <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="扩展多个"><a href="#扩展多个" class="headerlink" title="扩展多个"></a>扩展多个</h5><p>多加一个中间者，实现多对多，但其中每一对还是一一对应的。解耦产生和消费；  PRC框架</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808202.png" alt="image-20230610155101901"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mailboxes</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 产生唯一 id</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.remove(id);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(generateId());<br>        boxes.put(go.getId(), go);<br>        <span class="hljs-keyword">return</span> go;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.keySet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Join原理"><a href="#Join原理" class="headerlink" title="Join原理"></a>Join原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">线程对象也是对象<br>A线程调用B.join()时，会先获取锁<span class="hljs-keyword">synchronized</span> 然后执行B.wait(delay);<br>B线程运行结束后，调用notifyAll唤醒所有等待<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span>&#123;<br>    wait(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异步模式之生产者-x2F-消费者"><a href="#异步模式之生产者-x2F-消费者" class="headerlink" title="异步模式之生产者&#x2F;消费者"></a>异步模式之生产者&#x2F;消费者</h4><ul><li>生产者消费者不需要一一对应</li><li>JDK中的阻塞队列原理</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808203.png" alt="image-20230610155149434"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(queue)&#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.notifyAll();<br>            <span class="hljs-keyword">return</span> queue.getFirst();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Message m)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(queue)&#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.notifyAll();<br>            queue.add(m);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h3><p>wait状态，有点像<strong>值最大为1的信号量</strong>  但是是以<strong>线程</strong>为单位   不需要获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>    LockSupport.park(); <span class="hljs-comment">// 暂停自己</span><br>    log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>sleep(<span class="hljs-number">2</span>);<br>log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>LockSupport.unpark(t1); <span class="hljs-comment">// 恢复某个线程运行，可以在线程暂停前使用</span><br></code></pre></td></tr></table></figure><ul><li>不需要monitor，唤醒比较精确</li><li>可以先恢复再暂停</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>每个线程一个parker对象</p><p>其中有一个_counter(干粮数量)&#x3D;0或者1</p><ul><li>unpark：<code>_counter++  if(线程在等待) &#123;唤醒， _counter=0&#125;</code></li><li>park：<code>_counter--   if ( _counter&lt;0)  &#123;wait , _counter=0&#125;</code></li></ul><h3 id="细粒度锁"><a href="#细粒度锁" class="headerlink" title="细粒度锁"></a>细粒度锁</h3><p>睡觉和学习应该能并发，所以需要将锁细粒度化，而不是直接锁住this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>            log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>            log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>在一个线程需要获取多把锁时就可能导致</p><h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">jps <span class="hljs-comment">// 输出java进程 pid</span><br><br>jconsole <span class="hljs-comment">// 切换到线程，然后检测死锁</span><br>jstack pid  <span class="hljs-comment">// 显示进程运行信息  可以检测死锁  但只能检测java自己的  imple-db项目中锁是用map定义的就无法检测</span><br><br>Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br> waiting to lock monitor <span class="hljs-number">0x000000000361d378</span> (object <span class="hljs-number">0x000000076b5bf1c0</span>, a java.lang.Object),<br> which is held by <span class="hljs-string">&quot;Thread-0&quot;</span><br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br> waiting to lock monitor <span class="hljs-number">0x000000000361e768</span> (object <span class="hljs-number">0x000000076b5bf1d0</span>, a java.lang.Object),<br> which is held by <span class="hljs-string">&quot;Thread-1&quot;</span><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br> at thread.TestDeadLock.lambda$main$<span class="hljs-number">1</span>(TestDeadLock.java:<span class="hljs-number">28</span>)<br> - waiting to lock &lt;<span class="hljs-number">0x000000076b5bf1c0</span>&gt; (a java.lang.Object)<br> - locked &lt;<span class="hljs-number">0x000000076b5bf1d0</span>&gt; (a java.lang.Object)<br> at thread.TestDeadLock$$Lambda$<span class="hljs-number">2</span>/<span class="hljs-number">883049899.</span>run(Unknown Source)<br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br> at thread.TestDeadLock.lambda$main$<span class="hljs-number">0</span>(TestDeadLock.java:<span class="hljs-number">15</span>)<br> - waiting to lock &lt;<span class="hljs-number">0x000000076b5bf1d0</span>&gt; (a java.lang.Object)<br> - locked &lt;<span class="hljs-number">0x000000076b5bf1c0</span>&gt; (a java.lang.Object)<br> at thread.TestDeadLock$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">495053715.</span>run(Unknown Source)<br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure><h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。开发中可以增加随机时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 期望减到 0 退出循环</span><br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        sleep(<span class="hljs-number">0.2</span>);<br>        count--;<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 期望超过 20 退出循环</span><br>    <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>        sleep(<span class="hljs-number">0.2</span>);<br>        count++;<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>某个线程始终不能运行，如设置了线程优先级，优先级低的可能难以运行</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul><li>可中断</li><li>可以设置超时时间     </li><li>可以设置为公平锁     先到先得而不是随机</li><li>支持多个条件变量     相当于不同条件变量进入不同<code>WaitSet</code>    现在就完全相当于万能条件变量法 等价于synchronized+wait notifyall 升级</li></ul><p>都可以重入</p><p>java实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h4><p>等待锁的过程中可以被叫醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    lock.lockInterruptibly();  <span class="hljs-comment">// 如果别人获取了锁，我在等待过程可以被打断</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>    log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br>lock.lock();<br>t1.start();<br>sleep(<span class="hljs-number">1</span>);<br>t1.interrupt();<br></code></pre></td></tr></table></figure><h4 id="可超时"><a href="#可超时" class="headerlink" title="可超时"></a>可超时</h4><p>避免无限制的等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!lock.tryLock()) &#123; <span class="hljs-comment">// 查看当前状态下是否能够获取锁 立即返回true false</span><br>    log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br><br>lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS) <span class="hljs-comment">// 尝试1s</span><br></code></pre></td></tr></table></figure><h5 id="解决哲学家"><a href="#解决哲学家" class="headerlink" title="解决哲学家"></a>解决哲学家</h5><p>获取锁时，如果右手获取不到，需要立马不等并且左手要解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 尝试获得左手筷子</span><br><span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 尝试获得右手筷子</span><br>        <span class="hljs-keyword">if</span> (right.tryLock()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                eat();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                right.unlock();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        left.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>会降低并发度 默认为false   <code>lock = new ReentrantLock(true);</code></p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>之前等待队列只有一个，直接是lock对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Thread A is waiting&quot;</span>);<br>    lock.wait();  <span class="hljs-comment">// 线程A等待</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在lock基础上，创建一个condition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">// 创建一个condition</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionMet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (!conditionMet) &#123;<br>            condition.await(); <span class="hljs-comment">// 在该condition上等待 进入该队列</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Condition is met. Resuming execution.&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        conditionMet = <span class="hljs-literal">true</span>;<br>        condition.signal(); <span class="hljs-comment">// signalAll()</span><br>        System.out.println(<span class="hljs-string">&quot;Condition is signaled.&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h3><h4 id="线程执行顺序"><a href="#线程执行顺序" class="headerlink" title="线程执行顺序"></a>线程执行顺序</h4><ul><li>wait notify：  还需要一个额外变量标记代表cond</li><li>park unpark  非常简洁</li></ul><h4 id="打印指定形状"><a href="#打印指定形状" class="headerlink" title="打印指定形状"></a>打印指定形状</h4><p>例如打印abcabc   和打印🐟一个原理</p><ol><li><p>直接万能条件变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> waitFlag, <span class="hljs-type">int</span> nextFlag, String str)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.flag != waitFlag) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.print(str);<br>        flag = nextFlag;<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ReentrantLock + condition  每个线程都有等待的cond以及唤醒的cond 感觉没有必要 不如直接上面whlie+notifyAll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> &#123;<br>    <span class="hljs-built_in">this</span>.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        current.await();<br>        log.debug(str);<br>        next.signal();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.unlock();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>park unpark：每次unpark下一个想打印的线程，需要一个数组以获得下一个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LockSupport.park();<br>System.out.print(str);<br>LockSupport.unpark(nextThread());<br></code></pre></td></tr></table></figure></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>分析多线程访问共享资源时，哪些代码片段属于临界区 </p><p>使用 synchronized 互斥解决临界区的线程安全问题 </p><ul><li>掌握 synchronized 锁对象语法 </li><li>掌握 synchronzied 加载成员方法this 和静态方法语法 this.getClass()</li><li>掌握 wait&#x2F;notify 同步方法</li></ul><p>使用 lock 互斥解决临界区的线程安全问题 </p><ul><li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量   </li><li>相当于synchronzied 的<strong>升级</strong></li></ul><p>学会分析变量的线程安全性、掌握常见<strong>线程安全类</strong>的使用</p><p> 了解线程活跃性问题：死锁、活锁、饥饿 </p><p><strong>应用方面</strong> </p><ul><li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果</li><li>同步：使用 wait&#x2F;notify 或 Lock 的条件变量来达到线程间通信效果</li></ul><p><strong>原理方面</strong> </p><ul><li>monitor、synchronized 、wait&#x2F;notify 原理 </li><li>synchronized 进阶原理   轻量级  偏向锁  锁消除</li><li>park &amp; unpark 原理</li></ul><p><strong>模式方面</strong> </p><ul><li>同步模式之保护性暂停 </li><li>异步模式之生产者消费者 </li><li>同步模式之顺序控制</li></ul><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>通过volatile解决由于缓存引发的可见性问题，以及重排序引发的有序性问题</p><p>JMM java memory model</p><ul><li>原子性</li><li>可见性  不受缓存影响</li><li>有序性  不受cpu指令并行优化影响</li></ul><p>JMM的主要内容包括：</p><ol><li>主内存（Main Memory）：主内存是所有线程共享的内存区域，用于存储共享变量。主内存中的数据对所有线程可见。</li><li>工作内存（Working Memory）：每个线程都有自己的工作内存，用于存储线程执行时需要使用的数据。工作内存中包含了主内存中的部分数据副本。</li><li>内存间交互操作：JMM定义了一组规则，用于线程在主内存和工作内存之间进行数据交互。这些操作包括读取、写入和同步操作。</li><li>顺序一致性（Sequential Consistency）：JMM保证线程的执行结果与顺序一致的执行结果相同。即，对于一个线程来说，它的操作将按照程序中的顺序执行，并且对其他线程可见。</li><li>可见性（Visibility）：JMM保证一个线程对共享变量的修改对其他线程是可见的。这意味着一个线程对变量的修改，将会在之后的操作中对其他线程可见。</li><li>原子性（Atomicity）：JMM提供了一些原子性的保证。例如，对<code>volatile</code>变量的读写具有原子性，单个读写操作不会被线程中断。</li><li>重排序（Reordering）：JMM允许编译器和处理器对指令进行优化和重排序，但要求保持程序的顺序一致性和线程的可见性。</li></ol><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul><li>实际上停不下来，为什么？</li><li>while中如果有sout，就可以停下来了 为什么？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (run) &#123;<br>            <span class="hljs-comment">// ....</span><br>        &#125;<br>    &#125;);<br>    t.start();<br>    Thread.sleep(<span class="hljs-number">1</span>);<br>    run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t会在下一次循环中停下来</span><br>&#125;<br></code></pre></td></tr></table></figure><p>线程中存储了<code>run = true;</code> 的副本</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808204.png" alt="image-20230612163339523"></p><ul><li><strong>volatile</strong>：强制到主存中读取，修饰成员变量和静态成员变量。不能保证原子性，一个i++ 一个i– 还是会错，适合一个写其他读的情况 (轻量级的同步机制)</li><li><strong>synchronized</strong>：也可以实现必须去主存读取，但复杂度高。可以实现原子性(代码块内也可能重排序）<ul><li>进入时从主存读取最新</li><li>退出时将修改刷新到主存</li></ul></li></ul><h4 id="改进两阶段"><a href="#改进两阶段" class="headerlink" title="改进两阶段"></a>改进两阶段</h4><p>使用volatile标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTVolatile</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(stop) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>                <span class="hljs-comment">// 执行监控操作</span><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        stop = <span class="hljs-literal">true</span>;<br>        thread.interrupt(); <span class="hljs-comment">// 立即打断 不用等待sleep</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="balking"><a href="#balking" class="headerlink" title="balking"></a>balking</h4><p>监控线程只有一个，但如果有人多次start()其实会调用多个。balking<strong>避免重复执行某个操作</strong>  任务调度</p><ul><li>加一个volatile变量if判断 ？   不行 不能保证原子</li><li>加synchronized  可以实现，但每次都要synchronized同步比较慢（如用这个实现单例）</li><li>缩小synchronized 范围。  为什么不直接用单例 单例是保证只有一个实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorService</span> &#123;<br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> starting; <span class="hljs-comment">// 如果只在synchronized内读写可以不加volatile</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 真正启动监控线程...</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808205.png" alt="image-20230612172143500" style="zoom:67%;" /><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和组合来实现指令级并行，单线程下正确，但多线程下有问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 指令1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; <span class="hljs-comment">// 指令2</span><br>System.out.println( a + b );<br><span class="hljs-comment">// 不能重排的例子</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 指令1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">5</span>; <span class="hljs-comment">// 指令2</span><br></code></pre></td></tr></table></figure><h4 id="指令重排序问题"><a href="#指令重排序问题" class="headerlink" title="指令重排序问题"></a>指令重排序问题</h4><p>1 4为正常输出 但可能出现0(概率比较低)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123; <br>    num = <span class="hljs-number">2</span>; <span class="hljs-comment">// 这两条可能被交换位置  或者num = 2并没有被写入主存中</span><br>    ready = <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>对变量ready添加volatile会禁用重排序</p><h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障 </li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br>    <span class="hljs-comment">// 写屏障</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-comment">// 读屏障</span><br>    <span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可见性：<ul><li>遇到写屏障（sfence），对所有共享变量的改动，都同步到主存当中</li><li>遇到读屏障（lfence），去主存加载最新数据</li></ul></li><li>有序性：<ul><li>指令不能跨越屏障</li></ul></li></ul><h3 id="double-check-locking"><a href="#double-check-locking" class="headerlink" title="double-check-locking"></a>double-check-locking</h3><p>普通写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125; <br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>double</p><ul><li><p>需要把同步的范围缩小，只在第一次加锁</p></li><li><p>并且通过volatile保证读取最新值保证<strong>可见性</strong>，并且<strong>有序性</strong>防止指令重排导致 还没初始化完毕的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 的过程<br>    <span class="hljs-number">17</span> 表示创建对象，将对象引用入栈 <span class="hljs-comment">// new Singleton</span><br>    <span class="hljs-number">20</span> 表示复制一份对象引用 <span class="hljs-comment">// 引用地址</span><br>    <span class="hljs-number">21</span> 表示利用一个对象引用，调用构造方法<br>    <span class="hljs-number">24</span> 表示利用一个对象引用，赋值给 <span class="hljs-keyword">static</span> INSTANCE  <span class="hljs-comment">// 可能先执行  需要加volatile写屏障</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// 问题1：解释为什么要加 volatile ?</span><br>    <span class="hljs-comment">// volatile会在synchronized读取，synchronized外面需要volatile保证从内存读取</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123; <br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <br>            <span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗  EntryList都会进到这里</span><br>            <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2 </span><br>                <span class="hljs-keyword">return</span> INSTANCE;<br>            &#125;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可见性进阶"><a href="#可见性进阶" class="headerlink" title="可见性进阶"></a>可见性进阶</h3><ol><li>synchronized中的变量</li><li>volatile修饰的变量</li><li>在线程开始前修改变量（可以理解为创建副本）</li><li>t1.join() 后，可以看到t1中的修改</li><li>t1打断t2， t2.interrupt();  t2可以看到t1的写</li><li>对变量默认值的写，其他线程可见</li><li>具有传递性 ，在写屏障前的全部修改都可见 y &#x3D; 10 x &#x3D; 1  (x是volatile)</li></ol><h3 id="单例习题"><a href="#单例习题" class="headerlink" title="单例习题"></a>单例习题</h3><p>饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final 防止被修改</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?  不能</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?  jvm实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 避免反序列化</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的      </span><br><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题    jvm避免</span><br><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例        不能</span><br><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例    不会</span><br><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式      饿汉式  static 静态成员变量</span><br><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做  构造方法</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123; <br> INSTANCE; <br>&#125;<br></code></pre></td></tr></table></figure><p>类加载实现懒汉式单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyHolder</span> &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-comment">// 问题2：在创建时是否有并发问题  不会 JVM保证只有一个</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无锁并发"><a href="#无锁并发" class="headerlink" title="无锁并发"></a>无锁并发</h2><ul><li>本章内容</li><li>CAS 与 volatile </li><li>原子整数 </li><li>原子引用 </li><li>原子累加器 </li><li>Unsafe</li></ul><ol><li>CAS可以实现锁，0代表空闲1代表占用，下一章连接池中使用atomic数组实现多个连接池的锁</li><li>reentrantlock底层其实还是CAS，外带一个等待队列（park实现等待） 见原理部分</li></ol><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 获取当前值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> atomicInteger.get();<br><br><span class="hljs-comment">// 设置新的值</span><br>atomicInteger.set(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 获取当前值，并设置新的值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> atomicInteger.getAndSet(<span class="hljs-number">20</span>);<br><br><span class="hljs-comment">// 比较当前值是否等于期望值，如果等于则设置新的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> atomicInteger.compareAndSet(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br><span class="hljs-comment">// public final native boolean compareAndSwapInt(Object this, long offset, int old, int new);</span><br><br><span class="hljs-comment">// 获取当前值，并将其加1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> atomicInteger.getAndIncrement();<br><br><span class="hljs-comment">// 获取当前值，并将其减1</span><br>newValue = atomicInteger.getAndDecrement();<br><br><span class="hljs-comment">// 获取当前值，并将其加上delta</span><br>newValue = atomicInteger.getAndAdd(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 将当前值加1，并返回新的值</span><br>newValue = atomicInteger.incrementAndGet();<br><br><span class="hljs-comment">// 将当前值减1，并返回新的值</span><br>newValue = atomicInteger.decrementAndGet();<br><br><span class="hljs-comment">// 将当前值加上delta，并返回新的值</span><br>newValue = atomicInteger.addAndGet(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CAS修改过程</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 比如拿到了旧值 1000</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>    <span class="hljs-comment">// 在这个基础上 1000-10 = 990</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>    <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;  <span class="hljs-comment">//compareAndSwapInt(this, offset, prev, next)</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 包括getAndIncrement也是这个原理 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object <span class="hljs-built_in">this</span>, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> var4=<span class="hljs-number">1</span>)</span> &#123;<br>    <span class="hljs-type">int</span> old;<br>    <span class="hljs-keyword">do</span> &#123;<br>        old = <span class="hljs-built_in">this</span>.getIntVolatile(<span class="hljs-built_in">this</span>, offset);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(<span class="hljs-built_in">this</span>, offset, old, old + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">return</span> old;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><code>Compare And Swap</code>：先比较是否是旧值，旧值没被修改才swap（乐观锁） </p><p>核心一个函数：this和offset用于确定地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object <span class="hljs-built_in">this</span>, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> old, <span class="hljs-type">int</span> new)</span>;<br></code></pre></td></tr></table></figure><p>底层：<code>lock cmpxchg</code> 指令（X86 架构）</p><p>变量存储在一个<strong>volatile</strong>值中，因为每次都要保证可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br></code></pre></td></tr></table></figure><p><strong>效率高</strong>：不需要 锁的获取 以及 线程的上下文下切换，但需要更高的cpu资源，受限cpu内核数</p><h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><ul><li>AtomicBoolean </li><li>AtomicInteger </li><li>AtomicLong</li></ul><p>操作 原理都是while中尝试<code>compareAndSwapInt</code></p><ul><li>getAndIncrement();  incrementAndGet</li><li>getAndAdd(10);</li><li>getAndUpdate(p -&gt; p * 2);</li></ul><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><ul><li>AtomicReference </li><li>AtomicMarkableReference </li><li>AtomicStampedReference</li></ul><p>对象不是基本类型，提供CAS对对象进行操作，compare比较的是地址</p><h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p>保证多线程环境下取钱操作正常，并且不需要加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AtomicReference&lt;Double&gt; balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-number">0.0</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>    Double oldValue;<br>    Double newValue;<br>    <span class="hljs-keyword">do</span> &#123;<br>        oldValue = balance.get();<br>        newValue = oldValue - amount;<br>    &#125; <span class="hljs-keyword">while</span> (!balance.compareAndSet(oldValue, newValue));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h4><p>有人修改了值，但又改回来了，如何察觉到被修改了呢？</p><h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><p>添加版本号，每次操作版本号+1，除了值要匹配，版本号也要匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 获取值 A</span><br><span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br><span class="hljs-comment">// 获取版本号</span><br><span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br><br><br>ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h4><p>不关心换了几次，只关心有没有换。用一个bool 来判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicMarkableReference&lt;T&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(initialRef, initialMark=<span class="hljs-literal">true</span>);<br><br><span class="hljs-type">T</span> <span class="hljs-variable">currentRef</span> <span class="hljs-operator">=</span> ref.getReference();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">currentMark</span> <span class="hljs-operator">=</span> ref.isMarked();<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> ref.compareAndSet(expectedRef, newRef, expectedMark, newMark);<br><br><span class="hljs-type">boolean</span>[] mark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> counter.get(mark);<br>counter.compareAndSet(value, value + <span class="hljs-number">1</span>, mark[<span class="hljs-number">0</span>], !mark[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><ul><li>AtomicIntegerArray </li><li>AtomicLongArray </li><li>AtomicReferenceArray</li></ul><p>前面的是保证引用的对象不变，现在需要保护引用对象的内部不被改变，例如数组对象的内容没有修改（多个引用对象），底层就是偏移量不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment"> 参数2，获取数组长度的方法</span><br><span class="hljs-comment"> 参数3，自增方法，回传 array, index</span><br><span class="hljs-comment"> 参数4，打印数组的方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br><span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span><br><span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">    Supplier&lt;T&gt; arraySupplier,</span><br><span class="hljs-params">    Function&lt;T, Integer&gt; lengthFun,</span><br><span class="hljs-params">    BiConsumer&lt;T, Integer&gt; putConsumer,</span><br><span class="hljs-params">    Consumer&lt;T&gt; printConsumer )</span> &#123;<br>    List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                putConsumer.accept(array, j%length);<br>            &#125;<br>        &#125;));<br>    &#125;<br>    ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>    ts.forEach(t -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;); <span class="hljs-comment">// 等所有线程结束</span><br>    printConsumer.accept(array);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br> ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br> (array)-&gt;array.length,<br> (array, index) -&gt; array[index]++,<br> array-&gt; System.out.println(Arrays.toString(array))<br>);<br><br>demo(<br> ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br> (array) -&gt; array.length(),<br> (array, index) -&gt; array.getAndIncrement(index),<br> array -&gt; System.out.println(array)<br>);<br></code></pre></td></tr></table></figure><h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><ul><li>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段 </li><li>AtomicIntegerFieldUpdater </li><li>AtomicLongFieldUpdater</li></ul><p>某个对象内部的字段，保证原子操作。必须volatile</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span>AtomicIntegerFieldUpdater.newUpdater(Test5.class, <span class="hljs-string">&quot;field&quot;</span>);<br>    <span class="hljs-type">Test5</span> <span class="hljs-variable">test5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test5</span>();<br>    fieldUpdater.compareAndSet(test5, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>更高级的自增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    demo(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>(), adder -&gt; adder.increment());<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    demo(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(), adder -&gt; adder.getAndIncrement());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> adderSupplier.get();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 4 个线程，每人累加 50 万</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;<br>                action.accept(adder);<br>            &#125;<br>        &#125;));<br>    &#125;<br>    ts.forEach(t -&gt; t.start());<br>    ts.forEach(t -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start)/<span class="hljs-number">1000_000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 累加单元数组, 懒惰初始化</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><span class="hljs-comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br><span class="hljs-comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁   CAS实现</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><h5 id="sun-misc-Contended"><a href="#sun-misc-Contended" class="headerlink" title="@sun.misc.Contended"></a>@sun.misc.Contended</h5><p>防止cell伪共享</p><p>缓存行64 byte，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value）  一个缓存行可能有多个Cell，注解添加128B的pad防止在同一个缓存行</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808206.png" alt="image-20230630145548007"></p><table><thead><tr><th>从 cpu 到</th><th>大约需要的时钟周期</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle (4GHz 的 CPU 约为0.25ns)</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></tbody></table><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>会操作内存，比较危险</p><p>获取unsafe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Unsafe.getUnsafe();  被CallerSensitive修饰，能在引导类加载器加载的类中访问 抛出 SecurityException <br><br><span class="hljs-comment">// 反射获取</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">unsafeField</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>unsafeField.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) unsafeField.get(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>操作field</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br><br><span class="hljs-type">long</span> <span class="hljs-variable">idOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>));<br><span class="hljs-type">long</span> <span class="hljs-variable">nameOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br><br>unsafe.compareAndSwapInt(teacher, idOffset, <span class="hljs-number">0</span> , <span class="hljs-number">1</span>);<br>System.out.println(teacher);<br></code></pre></td></tr></table></figure><h4 id="模拟原子整数"><a href="#模拟原子整数" class="headerlink" title="模拟原子整数"></a>模拟原子整数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicData</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> DATA_OFFSET;<br>    <span class="hljs-keyword">static</span> &#123;<br>        unsafe = UnsafeAccessor.getUnsafe();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span><br>            DATA_OFFSET = unsafe.objectFieldOffset(AtomicData.class.getDeclaredField(<span class="hljs-string">&quot;data&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrease</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span> oldValue;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span><br>            oldValue = data;<br>            <span class="hljs-comment">// cas 尝试修改 data 为 旧值 + amount，如果期间旧值被别的线程改了，返回 false</span><br>            <span class="hljs-keyword">if</span> (unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, DATA_OFFSET, oldValue, oldValue - amount)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><h3 id="日期转换的问题"><a href="#日期转换的问题" class="headerlink" title="日期转换的问题"></a>日期转换的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>); <span class="hljs-comment">// 不是线程安全的 多个线程调用会出错</span><br><br><span class="hljs-keyword">synchronized</span> (sdf)&#123;  <span class="hljs-comment">// 可以解决 但太慢了</span><br>    sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>内部属性不可变实现安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 保护性拷贝，防止内容被修改</span><br><span class="hljs-built_in">this</span>.value = Arrays.copyOf(value, value.length); <br><span class="hljs-built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br></code></pre></td></tr></table></figure><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>minimizes memory usage by sharing</p><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的<br>valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对<br>象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">long</span> l)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>        <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-type">int</span>)l + offset];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(l);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="String-串池"><a href="#String-串池" class="headerlink" title="String 串池"></a>String 串池</h4><h4 id="BigDecimal-BigInteger"><a href="#BigDecimal-BigInteger" class="headerlink" title="BigDecimal BigInteger"></a>BigDecimal BigInteger</h4><h3 id="模拟连接池！"><a href="#模拟连接池！" class="headerlink" title="模拟连接池！"></a>模拟连接池！</h3><p>有多个连接，所以需要array标记使用状态：AtomicArray</p><p>AtomicIntegerArray来标记连接状态，并且是线程安全的，注意需要使用cas修改标记<br>在所有的连接都占用时，wait等待以节约cpu</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>    <span class="hljs-comment">// 1. 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br>    <span class="hljs-comment">// 2. 连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br>    <span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br>    <span class="hljs-comment">// 4. 构造方法初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];<br>        <span class="hljs-built_in">this</span>.states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 5. 借连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-comment">// 获取空闲连接</span><br>                <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 6. 归还连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                states.set(i, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>                    <span class="hljs-built_in">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br>    <span class="hljs-comment">// 实现略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上实现没有考虑：</p><ul><li>连接的动态增长与收缩</li><li>连接保活（可用性检测）</li><li>等待超时处理</li><li>分布式 hash</li></ul><p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache<br>commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p><p>tomcat jdbc连接池比较简单易读</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>线程池 ThreadPollExecutor Fork&#x2F;Join</li><li>JUC   Lock Semaphore CountdownLatch CyclicBarrier…</li><li>第三方</li></ul><h3 id="自己线程池"><a href="#自己线程池" class="headerlink" title="自己线程池"></a>自己线程池</h3><p>无救急线程</p><p>高并发下，并不是越大越好，而是需要充分发挥已有线程的潜力</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808207.png" alt="image-20230702093206100"></p><ul><li>需要一个线程set</li><li>当一个线程结束后，查看有没有BlockingQueue有没有任务，有就run（实现复用）</li></ul><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>实现保存暂时没有执行的任务列表，任务队列相当于<a href="###%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85/%E6%B6%88%E8%B4%B9%E8%80%85">生产者消费者模型</a>,但使用lock实现</p><ul><li><p>获取一个任务take</p><ul><li>为了实现如果等一段时间内还没有任务结束线程（不是一直死等），需要添加超时的等待<code>take -&gt; poll(timeout, unit)</code></li></ul></li><li><p>添加一个任务put</p><ul><li><p>等待任务队列也不是无穷大，有一个capcity</p></li><li><p>当满了以后，有<strong>不同的策略</strong></p><ol><li><p><code>put</code> 死等，阻塞主线程 fullWaitSet.await()</p></li><li><p><code>offer(task, timeout, unit)</code> 带超时等待</p></li><li><p>添加一个拒绝策略，策略模式</p><ul><li><p>具体实现的策略可以是死等、超时…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">(queue, task)-&gt;&#123;<br>    <span class="hljs-comment">// 1. 死等</span><br>    queue.put(task);<br>    <span class="hljs-comment">// 2) 带超时等待</span><br>    queue.offer(task, <span class="hljs-number">1500</span>, TimeUnit.MILLISECONDS);<br>    <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><br>    log.debug(<span class="hljs-string">&quot;放弃&#123;&#125;&quot;</span>, task);<br>    <span class="hljs-comment">// 4) 让调用者抛出异常</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;任务执行失败 &quot;</span> + task);<br>    <span class="hljs-comment">// 5) 让调用者自己执行任务</span><br>    task.run();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 1. 任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-comment">// 2. 锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 3. 生产者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">fullWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 4. 消费者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">emptyWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 5. 容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capcity;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capcity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capcity = capcity;<br>    &#125;<br>    <span class="hljs-comment">// 带超时阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将 timeout 统一转换为 纳秒</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 返回值是剩余时间</span><br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    nanos = emptyWaitSet.awaitNanos(nanos);<span class="hljs-comment">//自动返回剩余时间</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 带超时时间阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T task, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断队列是否满</span><br>            <span class="hljs-keyword">if</span>(queue.size() == capcity) &#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>, task);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 有空闲</span><br>                log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务队列</span><br><span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br><span class="hljs-comment">// 线程集合</span><br><span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-comment">// 核心线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br><br><span class="hljs-comment">// 等待队列满了时，拒绝策略</span><br><span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br></code></pre></td></tr></table></figure><h5 id="创建任务："><a href="#创建任务：" class="headerlink" title="创建任务："></a>创建任务：</h5><ul><li><p>任务数量小于coreSize时，创建一个Worker并加入线程集合中</p></li><li><p>否则加入taskQueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span><br>    <span class="hljs-comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span><br>    <span class="hljs-keyword">synchronized</span> (workers) &#123; <span class="hljs-comment">// 保证线程安全</span><br>        <span class="hljs-keyword">if</span>(workers.size() &lt; coreSize) &#123;<br>            <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>            log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);<br>            workers.add(worker);<br>            worker.start();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// taskQueue.put(task);</span><br>            <span class="hljs-comment">// 1) 死等</span><br>            <span class="hljs-comment">// 2) 带超时等待</span><br>            <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><br>            <span class="hljs-comment">// 4) 让调用者抛出异常</span><br>            <span class="hljs-comment">// 5) 让调用者自己执行任务</span><br>            taskQueue.tryPut(rejectPolicy, task);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="执行与任务完成："><a href="#执行与任务完成：" class="headerlink" title="执行与任务完成："></a>执行与任务完成：</h5><ul><li><p>当任务完成后，Worker需要从taskQueue取出下一个任务，实现Worker的复用</p><ul><li>一直等待 或者 等一段时间后结束线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Runnable task;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行任务</span><br>        <span class="hljs-comment">// 1) 当 task 不为空，执行任务</span><br>        <span class="hljs-comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span><br>        <span class="hljs-comment">// while(task != null || (task = taskQueue.take()) != null) &#123;  // 会一直等awiati</span><br>        <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;正在执行...&#123;&#125;&quot;</span>, task);<br>                task.run();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            log.debug(<span class="hljs-string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>            workers.remove(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> threadpoolself;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-comment">// 线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br>    <span class="hljs-comment">// 获取任务时的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span><br>        <span class="hljs-comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span><br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            <span class="hljs-keyword">if</span>(workers.size() &lt; coreSize) &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// taskQueue.put(task);</span><br>                <span class="hljs-comment">// 1) 死等</span><br>                <span class="hljs-comment">// 2) 带超时等待</span><br>                <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><br>                <span class="hljs-comment">// 4) 让调用者抛出异常</span><br>                <span class="hljs-comment">// 5) 让调用者自己执行任务</span><br>                taskQueue.tryPut(rejectPolicy, task);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit, <span class="hljs-type">int</span> queueCapcity,</span><br><span class="hljs-params">                      RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-built_in">this</span>.taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(queueCapcity);<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 执行任务</span><br>            <span class="hljs-comment">// 1) 当 task 不为空，执行任务</span><br>            <span class="hljs-comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span><br>            <span class="hljs-comment">// while(task != null || (task = taskQueue.take()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;正在执行...&#123;&#125;&quot;</span>, task);<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                log.debug(<span class="hljs-string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h3><h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808208.png" alt="image-20230702105624890"></p><p> int 的高 3 位来表示线程池状态，低 29 位表示线程数量，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值</p><table><thead><tr><th>状态名</th><th>高3位</th><th>新任务</th><th>处理阻塞队列任务</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不会接收新任务，但会处理阻塞队列剩余任务shutdown</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>会中断正在执行的任务，并抛弃阻塞队列任务shutdownNow</td></tr><tr><td>TIDYING</td><td>010</td><td></td><td></td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td></td><td></td><td>终结状态</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><ul><li>corePoolSize 核心线程数目 (最多保留的线程数)</li><li>maximumPoolSize 最大线程数目   减去核心线程就是救急线程数量，多出来的会被销毁</li><li>keepAliveTime 生存时间 - 针对救急线程</li><li>unit 时间单位 - 针对救急线程</li><li>workQueue 阻塞队列</li><li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li><li>handler 拒绝策略</li></ul><p><strong>当阻塞队列满时，会先创建救济线程，再考虑拒绝策略</strong></p><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808209.png" alt="image-20230702111206853"></p><ul><li><p>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</p></li><li><p>CallerRunsPolicy 让调用者运行任务</p></li><li><p>DiscardPolicy 放弃本次任务</p></li><li><p>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</p></li><li><p>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方<br>便定位问题</p></li><li><p>Netty 的实现，是创建一个新线程来执行任务</p></li><li><p>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</p></li><li><p>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</p></li></ul><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li><li>任务量已知，任务耗时</li></ul><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>全部都是救急线程（60s 后可以回收）</li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li><li>适合任务数比较密集，但每个任务执行时间较短的情况</li></ul><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</p><p><code>FinalizableDelegatedExecutorService</code>限制了一些方法的暴露</p><h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br><br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;   futer.get()获取结果（原理保护性暂停模式） 有异常返回异常<br><br><span class="hljs-comment">// 提交 tasks 中所有任务, 会等最后一个完成</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br></code></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 非阻塞</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br><br>- 会将队列中的任务返回<br>- 并用 interrupt 的方式中断正在执行的任务<br><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> <br><br><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事</span><br>情，可以利用此方法等待<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><h4 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h4><p>分工模式，不同的任务采用不同的线程池。如点餐线程池和做饭线程池</p><p>如果同一个线程池中，可能会没有做饭的导致点餐的一直在等待，导致饥饿。但jconsole死锁检测不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">waiterPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cookPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>waiterPool.execute(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>    Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>        <span class="hljs-keyword">return</span> cooking();<br>    &#125;);<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="线程池数量"><a href="#线程池数量" class="headerlink" title="线程池数量"></a>线程池数量</h5><ul><li><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿</p></li><li><p>过大会导致更多的线程上下文切换，占用更多内存</p></li><li><p><strong>CPU 密集</strong>型运算</p><p>​通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因<br>导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p></li><li><p><strong>I&#x2F;O 密集型</strong>运算</p><p>​CPU 容易闲下来（IO RPC），你可以利用多线程提高它的利用率。    时间占比可以用工具估算</p><p>​线程数 &#x3D; 核数 * 期望 CPU 利用率(1.0) * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</p></li></ul><h4 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h4><p>如何实现一些延时的任务，或者反复执行</p><h5 id="Timmer"><a href="#Timmer" class="headerlink" title="Timmer"></a>Timmer</h5><p>同一时间只能有一个任务在执行，出现异常后续不可以执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;task 1&quot;</span>);<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;task 2&quot;</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span><br>    <span class="hljs-comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span><br>    timer.schedule(task1, <span class="hljs-number">1000</span>);<br>    timer.schedule(task2, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h5><p>延时任务或者重复执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 添加两个任务，希望它们都在 1s 后执行</span><br>executor.schedule(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务1，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">2000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>&#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>executor.schedule(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务2，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>&#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br><br><br><span class="hljs-comment">// 延时2s后 每隔1s反复执行，延时包括执行时间，任务开始间隔时间 = max（执行时间，等待时间）</span><br>executor.scheduleAtFixedRate(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// 延时从上一个任务结束开始算  任务开始间隔时间 = 执行时间+等待时间</span><br>executor.scheduleWithFixedDelay(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul><li><p>方法1：主动捉异常</p></li><li><p>方法2：使用submit中的 Future，f.get()会返回异常信息</p></li></ul><h3 id="Tomcat线程池"><a href="#Tomcat线程池" class="headerlink" title="Tomcat线程池"></a>Tomcat线程池</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808210.png" alt="image-20230703111719298"></p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】</li><li>一旦可读，封装一个任务对象（socketProcessor implement Runnable），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ul><h4 id="线程池源码"><a href="#线程池源码" class="headerlink" title="线程池源码"></a>线程池源码</h4><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同<br>    如果总线程数达到 maximumPoolSize<br>        这时不会立刻抛 RejectedExecutionException 异常<br>        而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>    submittedCount.incrementAndGet();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">super</span>.getQueue() <span class="hljs-keyword">instanceof</span> TaskQueue) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">TaskQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> (TaskQueue)<span class="hljs-built_in">super</span>.getQueue();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!queue.force(command, timeout, unit)) &#123;<br>                    submittedCount.decrementAndGet();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Queue capacity is full.&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;<br>                submittedCount.decrementAndGet();<br>                Thread.interrupted();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(x);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            submittedCount.decrementAndGet();<br>            <span class="hljs-keyword">throw</span> rx;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Connector 配置</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808211.png" alt="image-20230703112719086"></p><p>Executor 线程配置，优先级高于上面的配置</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808212.png" alt="image-20230703112911572"></p><p>此外，对救急线程的激活逻辑做了修改，先创建救急线程而不是加入队列</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808213.png" alt="image-20230703113021772"></p><h3 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h3><p>大任务拆分为算法上相同的小任务，小任务分配到不同线程从而并行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br>    System.out.println(pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask1</span>(<span class="hljs-number">5</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTask1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>        <span class="hljs-type">AddTask1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask1</span>(n - <span class="hljs-number">1</span>);<br>        t1.fork(); <span class="hljs-comment">// 启动另一个线程执行该任务</span><br>        <br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br>        <span class="hljs-comment">// 合并(join)结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n + t1.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拆分优化：拆分成 begin-mid，mid+1-end 能提高并行度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask3</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-built_in">this</span>.begin = begin;<br>    <span class="hljs-built_in">this</span>.end = end;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><p>特点：</p><ul><li>用 <strong>state</strong>  volatile属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取<br>锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果获取锁失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123;<br>    <span class="hljs-comment">// 入队, 可以选择阻塞当前线程 park unpark</span><br>&#125;<br><br><span class="hljs-comment">// 如果释放锁成功</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>    <span class="hljs-comment">// 让阻塞线程恢复运行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>需要实现以下方法： 不同的实现代表不同锁类型    AQS其他方法会调用下面的方法,详情见ReentrantLock</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808214.png" alt="image-20230704100702089" style="zoom:50%;" /><p>入队需要把当前Node变成tail，CAS操作防止并发影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// 原来的 tail</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> tail;<br><span class="hljs-comment">// 用 cas 在原来 tail 的基础上改为 node</span><br>&#125; <span class="hljs-keyword">while</span>(tail.compareAndSet(prev, node))<br></code></pre></td></tr></table></figure><p>某个线程释放锁后，会唤醒Head的下一个，并尝试tryAcquire；成功后设置当前节点为head，并且出队列，失败继续等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 释放锁</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <span class="hljs-comment">// 修改state 自己定义的方法</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>        unparkSuccessor(h);  <span class="hljs-comment">// unpark下一个thread，优先叫醒head下一个；只是unpark，后面还要获取锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="hljs-comment">// 老二被叫醒 尝试获取锁，成功了才被删除</span><br>    setHead(node);<br>    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>    failed = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> interrupted;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义非重入锁"><a href="#自定义非重入锁" class="headerlink" title="自定义非重入锁"></a>自定义非重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">if</span> (acquires == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">if</span>(acquires == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(getState() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            &#125;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">MySync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试，不成功，进入等待队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试，不成功，进入等待队列，可打断</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试一次，不成功返回，不进入队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试，不成功，进入等待队列，有时限</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 生成条件变量</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808215.png" alt="image-20230703151551509"></p><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>当前线程在获取失败后会park</p><p>有一个Node链表连接所有线程（有一个虚假head），前一个负责unpark后一个</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808216.png" alt="image-20230703154753396"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="hljs-comment">// add加入到链表中</span><br>        selfInterrupt();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="hljs-comment">// 老二被叫醒 尝试获取锁</span><br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="hljs-comment">// pre的state设置为-1</span><br>                parkAndCheckInterrupt()) <span class="hljs-comment">// park 并返回等待过程中有没有被打断</span><br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><ul><li>设置state</li><li>unpark队列中离head最近的Thread</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808217.png" alt="image-20230703155757360"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <span class="hljs-comment">// 修改state 自己定义的方法</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);  <span class="hljs-comment">// unpark下一个thread，优先叫醒head下一个；只是unpark，后面还要获取锁</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p>state：代表计数，获取时++，释放时–</p><h4 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h4><p>获取锁时会进入park，如果被打断就立马抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>(); <span class="hljs-comment">// 被打断后 立马抛出异常</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 如果被打断 返回true</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平性原理"><a href="#公平性原理" class="headerlink" title="公平性原理"></a>公平性原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">tryAcquire<br>    <span class="hljs-title function_">if</span> <span class="hljs-params">(!hasQueuedPredecessors()</span> &amp;&amp;  <span class="hljs-comment">// 添加这一句  队列中等待有时，新来的不可以tryAcquire</span><br>        compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h4><p>每一个ConditionObject有一个Node等待队列，nextWaiter串起来，firstWaiter为第一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1173984872572414699L</span>;<br>    <span class="hljs-comment">/** First node of condition queue. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>    <span class="hljs-comment">/** Last node of condition queue. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>&#125;<br><br>await<br>    <span class="hljs-comment">// 添加一个节点，CONDITION 并加入到Waiter队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br><br>    <span class="hljs-comment">// 释放掉当前lock上的锁，并唤醒等待队列</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br><br>    <span class="hljs-comment">// park自己</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br><br>signal<br>    从ConditionObject.firstWaiter转移到等待列表<br></code></pre></td></tr></table></figure><p>await</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808218.png" alt="image-20230703173859988"></p><p>signal</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808219.png" alt="image-20230703173947214"></p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>让<code>读-读</code>并发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rw.readLock();<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rw.writeLock();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DataContainer</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainer</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>dataContainer.read();<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>dataContainer.write();<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>写锁才有条件变量</li><li>不支持升级但支持降级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedData</span> &#123;<br>    Object data;<br>    <span class="hljs-comment">// 是否有效，如果失效，需要重新计算 data</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> cacheValid;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCachedData</span><span class="hljs-params">()</span> &#123;<br>        rwl.readLock().lock();<br>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            <span class="hljs-comment">// 获取写锁前必须释放读锁</span><br>            rwl.readLock().unlock();<br>            rwl.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span><br>                <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>                    data = ...<br>                        cacheValid = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span><br>                rwl.readLock().lock();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                rwl.writeLock().unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 自己用完数据, 释放读锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            use(data);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rwl.readLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读写锁实现缓存一致性"><a href="#读写锁实现缓存一致性" class="headerlink" title="读写锁实现缓存一致性"></a><strong>读写锁实现缓存一致性</strong></h4><p>以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑<br>    适合读多写少，如果写操作比较频繁，以上实现性能低<br>    没有考虑缓存容量<br>    没有考虑缓存过期<br>    只适合单机<br>    并发性还是低，目前只会用一把锁<br>    更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key）<br>乐观锁实现：用 CAS 去更新</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位，Node链表还是只有一个</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808220.png" alt="image-20230704112731294"></p><p>没有仔细读源码</p><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p>进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.readLock();<br>lock.unlockRead(stamp);<br><br><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();  <span class="hljs-comment">// 无锁</span><br>sleep(readTime); <br><span class="hljs-comment">// 验戳 如果有人修改了，那么会失败</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br>    <span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><br>semaphore.acquire();<br>semaphore.release();<br></code></pre></td></tr></table></figure><h4 id="优化连接池"><a href="#优化连接池" class="headerlink" title="优化连接池"></a>优化连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.semaphore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(poolSize);<br><br><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// t1, t2, t3</span><br>    <span class="hljs-comment">// 获取许可</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        semaphore.acquire(); <span class="hljs-comment">// 没有许可的线程，在此等待</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>        <span class="hljs-comment">// 获取空闲连接</span><br>        <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                <span class="hljs-keyword">return</span> connections[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不会执行到这里</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 6. 归还连接</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>        <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>            states.set(i, <span class="hljs-number">0</span>);<br>            log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>            semaphore.release();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>原理：state记录数量，cas操作。减完小于零时进入队列 <code>doAcquireSharedInterruptibly</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放，检查唤醒后面的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>    doReleaseShared();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Ensure that a release propagates, even if there are other</span><br><span class="hljs-comment">         * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="hljs-comment">         * way of trying to unparkSuccessor of head if it needs</span><br><span class="hljs-comment">         * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="hljs-comment">         * ensure that upon release, propagation continues.</span><br><span class="hljs-comment">         * Additionally, we must loop in case a new node is added</span><br><span class="hljs-comment">         * while we are doing this. Also, unlike other uses of</span><br><span class="hljs-comment">         * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="hljs-comment">         * fails, if so rechecking.</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>用来进行线程同步协作，等待所有线程完成倒计时。<br>其中构造参数用来初始化等待计数值<code>new CountDownLatch(3)</code>，<code>await()</code> 用来等待计数归零，<code>countDown()</code> 用来让计数减一</p><p>原理可以看源码，非常短countDown：state–   await：state不等于零就加入队列</p><p>可以用来实现等待线程完成，为什么不用join？线程池！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1.5</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(()-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>            latch.await();<br>            log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p> 应用：</p><ul><li>等待线程完成，如用户加载</li><li>等待远程调用完成</li></ul><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>人满发车，可重复使用，state变成0后，会修改为init</p><p>await： state–  不为零就加入队列；为零就唤醒所有人，并重置state</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>); <br><br>t1: cb.await(); <span class="hljs-comment">// 当个数不足时，等</span><br>t2: cb.await(); <span class="hljs-comment">// 2 秒后，线程个数够2，继续运行</span><br><br><span class="hljs-comment">// 发车后执行的操作</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>, ()-&gt;&#123;<br>    <span class="hljs-string">&quot;发车了&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>注意线程池数量要和CyclicBarrier一样，否则可能出现同时两次都是task1的await触发</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法基础</title>
    <link href="/2023/05/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/05/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="0-特殊"><a href="#0-特殊" class="headerlink" title="0.特殊"></a>0.特殊</h2><p>leetcode  10^7^</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">n&lt;=</span><span class="hljs-number">12</span><span class="language-xml">      n!</span><br><span class="language-xml"></span><br><span class="language-xml">n&lt;=</span><span class="hljs-number">30</span><span class="language-xml">      </span><span class="hljs-number">2</span><span class="hljs-keyword">^n</span><span class="language-xml">           dfs+剪枝</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">100</span><span class="language-xml">~</span><span class="hljs-number">300</span><span class="language-xml">  n</span><span class="hljs-keyword">^3</span><span class="language-xml">            floyd</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^3</span><span class="language-xml">        n</span><span class="hljs-keyword">^2</span><span class="language-xml">            dp dij 二分  </span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^4</span><span class="language-xml">        n*根号n      块状链表</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^5</span><span class="language-xml">~</span><span class="hljs-number">6</span><span class="language-xml">    nlogn         排序 线段树 树状数组 set/map heap dij+heap spfa 二分 求凸包 求半平面交</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^6</span><span class="language-xml">         n               hash 双指针  kmp ac自动机  </span><br><span class="language-xml">小常nlogn   sort 树状数组 heap+dij spfa</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^7</span><span class="language-xml">         n                hash 双指针  kmp ac自动机  线性筛质素</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^9</span><span class="language-xml">         根号n         判断质素</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^18</span><span class="language-xml">        logn          欧几里得  快速幂</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;utility&gt;</span> map</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span> memset(h,-1,sizeof h); memset(dis,0x3f,sizeof dis);</span><br><span class="hljs-comment">// 小于x的第一个元素</span><br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">lower_bound</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>(), x)-alls.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-comment">// 优先队列</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt; &gt; q;  <span class="hljs-comment">//大根堆 priority_queue&lt;int&gt; q; </span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt;q;  <span class="hljs-comment">//小根堆</span><br><span class="hljs-comment">// 自定义比较函数：STL构造时放入 https://www.cnblogs.com/lengbingshy/p/3491192.html</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">mycmp</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span>  <span class="hljs-keyword">return</span> l1-&gt;val&gt;l2-&gt;val</span>;<br>    priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,function&lt;<span class="hljs-type">bool</span>(ListNode*, ListNode*)&gt;&gt; <span class="hljs-built_in">pq</span>(mycmp);<br><span class="hljs-comment">// 或者</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">comp</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode* a, ListNode* b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>        &#125;<br>    &#125;;<br>    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, comp&gt; q;<br><br><span class="hljs-comment">// 保留小数</span><br><span class="hljs-built_in">setiosflags</span>(ios::fixed)&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>)<br><span class="hljs-comment">//排序 去重  algorithm</span><br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// vector</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(b)</span> vector&lt;<span class="hljs-type">int</span>&gt; a </span>= &#123;<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>&#125;初始化<br>    <br>a.<span class="hljs-built_in">swap</span>(b)交换<br>add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;)  <span class="hljs-comment">//vector中 pair插入:</span><br>        <br><span class="hljs-comment">// 优先队列 栈  top()   pop() push()</span><br><span class="hljs-comment">// 队列        front() pop() push()</span><br>        <br><span class="hljs-comment">//set map multiset multimap 平衡二叉树（红黑树） 动态维护有序序列 增删改查:O(logN)</span><br><span class="hljs-built_in">size</span>() <span class="hljs-built_in">empty</span>() <span class="hljs-built_in">clear</span>() <span class="hljs-built_in">begin</span>() <span class="hljs-built_in">end</span>()<br>set 无重复有序 multiset 有重复<br>    <span class="hljs-built_in">insert</span>()<br>    <span class="hljs-built_in">find</span>()<br>    <span class="hljs-built_in">count</span>() <span class="hljs-comment">// 0 1</span><br>    <span class="hljs-built_in">erase</span>(x)删除所有x  k+<span class="hljs-function">logn</span><br><span class="hljs-function">    <span class="hljs-title">erase</span><span class="hljs-params">(迭代器)</span>删除当前</span><br><span class="hljs-function">    <span class="hljs-title">lower_bound</span><span class="hljs-params">(x)</span> 删除大于等于x最小的  </span><br><span class="hljs-function">    <span class="hljs-title">upper_bound</span><span class="hljs-params">(x)</span> 删除大于x中最小的</span><br><span class="hljs-function"></span><br><span class="hljs-function">map multimap</span><br><span class="hljs-function">    <span class="hljs-title">insert</span><span class="hljs-params">(&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>&#125;)</span> <span class="hljs-title">erase</span><span class="hljs-params">()</span> 参数pair</span><br><span class="hljs-function">    添加M[&quot;str&quot;]</span>=<span class="hljs-number">1</span> ,如果没有该key，默认值为<span class="hljs-number">0</span><br>    <span class="hljs-keyword">auto</span>遍历时first,second取数，和pair遍历一样<br>    multimap可以用map&lt;x,vector&lt;y&gt; &gt;代替<br><br>unordered_set unordered_map unoerder_multiset unoerder_multimap 哈希表<br>    增删改查<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) 不支持 lower_bound upper_bound<br><br><span class="hljs-comment">//二分返回第一个大于等于x的数</span><br><span class="hljs-built_in">lower_bound</span>(a,a+n,x)-a;<br><span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),x)-v.<span class="hljs-built_in">begin</span>();  <br><br><span class="hljs-comment">// 随机数</span><br><span class="hljs-built_in">srand</span>((<span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>cout &lt;&lt; <span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>&lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;b;&#125;<br><span class="hljs-built_in">sort</span>(a,a+n,cmp);<br><span class="hljs-comment">// greater比较</span><br><span class="hljs-built_in">sort</span>(a,a+n,<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h2><h3 id="1-0排序"><a href="#1-0排序" class="headerlink" title="1.0排序"></a>1.0排序</h3><blockquote><p>快速排序</p></blockquote><p>​选取中点为划分，左边&lt;&#x3D;，右边&gt;&#x3D;。再分别排序两边  空间O(logn)   不稳定 <a href="https://www.acwing.com/activity/content/code/content/487415/">边界选择</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span> ,j=r+<span class="hljs-number">1</span> mid=a[l + r &gt;&gt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>    i++;<span class="hljs-keyword">while</span>(a[i]&lt;mid) i ++;<br>    j--;<span class="hljs-keyword">while</span>(a[j]&gt;mid) j --;<br>    <span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(a[i], a[j]);<br>&#125;<br><span class="hljs-built_in">quickSort</span>(l, j);        <span class="hljs-comment">// j会停留在&lt;=mid的位置，且j右边一定满足&gt;mid</span><br><span class="hljs-built_in">quickSort</span>(j+<span class="hljs-number">1</span>, r);<br><span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure><p>​<strong>partition</strong>:  l的左边小于key，r的右边大于key。[l:i)的数等于key</p><p>l为下一个放小于key的地方，r为下一个放大于key的地方</p><p>最后0<del>l-1小于key ， l</del>r等于key ， r+1到n-1大于key</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>,i=l<br><span class="hljs-keyword">while</span>(i&lt;=r)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]&lt;key)&#123;<br>    <span class="hljs-built_in">swap</span>(nums[i],nums[l]);<br>    i++,l++;<span class="hljs-comment">//换过来的数一定等于key，i直接增加</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]&gt;key)&#123;<br>    <span class="hljs-built_in">swap</span>(nums[i],nums[r]);<br>    r--;   <span class="hljs-comment">// 换过来的数不知道大小，i不增加</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    i++;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><blockquote><p>归并排序</p></blockquote><p>​先排好中点左边，再排中点右边，然后merge两边,  空间O(n)  稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> mid = l+r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">merge_sort</span>(l,mid);<br><span class="hljs-built_in">merge_sort</span>(mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-comment">// merge  merge时tmp数组只申请需要的大小，或者全局申请</span><br></code></pre></td></tr></table></figure><blockquote><p>其他</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">冒泡 每次交换出一个最大<br>插入 每次向有序中插入一个元素<br>选择 每次在无序中，选出一个最小的 不稳定<br><br>堆排序 不稳定<br><br>计数排序<br>桶排序  ：桶内排序，桶外计数排序<br></code></pre></td></tr></table></figure><h3 id="1-1二分"><a href="#1-1二分" class="headerlink" title="1.1二分"></a>1.1二分</h3><p>分界点右边都满足一种性质，左边都不满足</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">l=<span class="hljs-number">0</span> ,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//寻找满足条件的最左边的数        大于等于aim      不会用到a[r]的值     </span><br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(a[mid]&gt;=aim)&#123;<br>        r=mid;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//寻找满足条件的最右边的数        小于等于aim      不会用到a[l]的值</span><br> <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-comment">//不加一 会死循环</span><br>    <span class="hljs-keyword">if</span>(a[mid]&lt;=aim)&#123;<br>        l=mid;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        r=mid<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//浮点数二分，结束条件要多两位</span><br><span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">0.00000001</span>)&#123;        <span class="hljs-comment">//多两位</span><br>    <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(mid*mid*mid&lt;=n) l=mid;<br>    <span class="hljs-keyword">else</span> r=mid;<br>&#125;<br></code></pre></td></tr></table></figure><p>0.旋转数组找旋转点</p><p>1.机器人跳跃 1e5 n a[i]，从起点跳到终点 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">每次跳跃res= res*<span class="hljs-number">2</span>-a[i];   res始终要大于零，求最小的起始res。<br>检测一个数要<span class="hljs-number">1e5</span>，遍历[<span class="hljs-number">1</span>,<span class="hljs-number">1e5</span>]个数超时，二分遍历即可解决<br></code></pre></td></tr></table></figure><p>2.分巧克力</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">对于每一种大小的切法，1e5时间能求出是否满足数量<br>二分求出这个大小即可。<br></code></pre></td></tr></table></figure><p>3.炸弹问题：矩阵和</p><p><strong>4.四平方和 四个数的平方和为x，求出序列最小的  x&lt; 5*1e6</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">求出三个数，就能得出最后一个，但是时间上最多求出两个<br>枚举前面两个数c d，并存下来 按照sum排序 如果相同就按照c排序<br>（或者把和扔到hash中，只放入第一次遇到的）<br>枚举<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span>，查看x-<span class="hljs-selector-tag">a</span>^<span class="hljs-number">2</span>-<span class="hljs-selector-tag">b</span>^<span class="hljs-number">2</span>是否在存下的数中（二分，hash）<br></code></pre></td></tr></table></figure><p>5.k倍区间  一个数组中子串为给定数k的倍数，求共有多少个这样的区间  1e5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">两个循环加前缀和 但依旧会超时<br><br>s[r]-s[l]  % k == <span class="hljs-number">0</span> 相当于  s[r]与s[l]余数相同，所以每次是在找余数为固定值的个数<br>cnt[i] 代表当前余数为i的个数（包括s[r]）<br>先计算出s[r]全取的情况下，余数为零的个数，再取算s[l]与s[r]同余的个数<br>遍历右端点<br>    <span class="hljs-keyword">if</span>(s[r]==<span class="hljs-number">0</span>)res ++;<br>cnt[s[r]]++;<br>    res += (cnt[s[r]]<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h3 id="1-2高精度"><a href="#1-2高精度" class="headerlink" title="1.2高精度"></a>1.2高精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//两个大整数，求和          10^6位</span><br><span class="hljs-comment">//相减                    10^6位</span><br><span class="hljs-comment">//一个大整数乘一个小整数    &lt;10^6位 * 1000000</span><br><span class="hljs-comment">//          除</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//大整数的每一位存到vector中，个位放下标0,输入用字符串,记得-&#x27;0&#x27;</span><br><span class="hljs-comment">//t = a[i] + b[i] + t</span><br></code></pre></td></tr></table></figure><ul><li>除了加法都要去除前面的零    while(C.size()&gt;1&amp;&amp;C.back()&#x3D;&#x3D;0)C.pop_back();</li><li>乘法每一位直接拿小的数乘</li><li>除法从高位开始除，最后反转 reverse(C.begin(),C.end());</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 乘法直接一位一位乘, 最后再一次性进位</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a1.size();i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;a2.size();j++)&#123;<br>    res[i+j] += a1.get(i) * a2.get(j);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.length-<span class="hljs-number">1</span>;i++)&#123;<br>    res[i+<span class="hljs-number">1</span>] += res[i]/<span class="hljs-number">10</span>;<br>    res[i] %= <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>java中，<code>string</code>到<code>List&lt;Integer&gt;</code>需要-‘0’，而sb.append 可以直接append数字</p><h3 id="1-3前缀和-差分"><a href="#1-3前缀和-差分" class="headerlink" title="1.3前缀和  差分"></a>1.3前缀和  差分</h3><p>&#x3D;&#x3D;前缀和&#x3D;&#x3D;：前缀和一个值代表着一个区间的性质</p><ol><li>普通前缀和  <strong>询问区间</strong></li><li>矩阵和        求出每个到0，0点的矩阵的和   <strong>询问矩阵</strong></li></ol><p>&#x3D;&#x3D;差分&#x3D;&#x3D;：差分数组一个值的改变影响一个区间</p><ol><li>差分数组   <strong>区间操作，询问结果</strong></li><li>差分矩阵b求和等于a，不用考虑b如何出来的，只需要考虑b如何改变a的<ul><li>当b增加时，改变的时全部右下角的数</li></ul></li></ol><h3 id="1-4双指针"><a href="#1-4双指针" class="headerlink" title="1.4双指针"></a>1.4双指针</h3><p>双指针<br>快排 归并排序</p><p>将i j 两种枚举n^2的情况，优化为O(n);<br>找到i j 之间存在的单调性</p><p>将一个英文句子的每个单词输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>连续最长不重复子串</p></li><li><p>两个升序数组，求和为x的两个数组的下标</p></li><li><p>判断是否是字串</p></li></ul><h3 id="1-5位运算"><a href="#1-5位运算" class="headerlink" title="1.5位运算"></a>1.5位运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) x&amp;-x</span><br><span class="hljs-comment">//lowbit:返回最后一位1以及后面的零 110100 -&gt; 100</span><br><br>n&gt;&gt;k&amp;<span class="hljs-number">1</span><br><span class="hljs-comment">//二进制中第k位是几</span><br></code></pre></td></tr></table></figure><ul><li>求一个数中二进制1的个数，两种方法都可以</li></ul><h3 id="1-6离散化"><a href="#1-6离散化" class="headerlink" title="1.6离散化"></a>1.6离散化</h3><p>原来的下标太大了，将大数，转为排序数组的下标</p><ul><li>操作无限长坐标上的元素后，询问区间和</li></ul><p>将大的数保存到vector中后，排序，去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><p>将大值和下标映射用<strong>二分查找</strong>或<strong>unordered_map</strong>映射</p><p>询问上的点也要先加入到alls中</p><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>int h&#x3D;-1, e[], ne[], idx</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>s[],  t&#x3D;-1</p><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调增：栈内元素单调递增，遍历到i时，导致某元素出栈，则i是右边第一个比该元素小的，新栈顶为左边第一个比该元素小的。</p><ol start="84"><li>最大矩阵面积</li></ol><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>q[], t&#x3D;-1, h&#x3D;0;     t进h出   q[++t]&#x3D;x;  h++;</p><ul><li>单调队列：把最小的始终保存在队头，实现滑动窗口求最小</li></ul><h3 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">297</span> 树的序列化与反序列化<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">middle_order</span><span class="hljs-params">(Node Node)</span>:</span><br><span class="hljs-function">if(Node =</span>= <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// printf(&quot;%d &quot;, Node-&gt;data);前</span><br>    <span class="hljs-built_in">middle_order</span>(Node-&gt;left);<br>    <span class="hljs-comment">// printf(&quot;%d &quot;, Node-&gt;data);中</span><br>    <span class="hljs-built_in">middle_order</span>(Node-&gt;right);<br>    <span class="hljs-comment">// printf(&quot;%d &quot;, Node-&gt;data);后</span><br><br>非递归实现：颜色标记法<br><span class="hljs-function">def <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; List[<span class="hljs-type">int</span>]:</span><br><span class="hljs-function">    WHITE, GRAY =</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    res = []<br>    stack = [(WHITE, root)]<br>    <span class="hljs-keyword">while</span> stack:<br>        color, node = stack.<span class="hljs-built_in">pop</span>()<br>        <span class="hljs-keyword">if</span> node is None: <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> color == WHITE:<br>            stack.<span class="hljs-built_in">append</span>((WHITE, node.right)) # 先输出的后入栈<br>            stack.<span class="hljs-built_in">append</span>((GRAY, node))<br>            stack.<span class="hljs-built_in">append</span>((WHITE, node.left))<br>        <span class="hljs-keyword">else</span>:<br>            res.<span class="hljs-built_in">append</span>(node.val)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h3><p>树：边的个数加+ 1 &#x3D; ∑节点*度 + 1 &#x3D; 节点个数</p><p><a href="https://www.bilibili.com/video/BV1Tb4y197Fe">https://www.bilibili.com/video/BV1Tb4y197Fe</a></p><p>Binary Search Tree: <strong>BST</strong>   -&gt;退化-&gt;   <strong>AVL</strong> （左右高度差不超过1）&gt;频繁增删&gt;  <strong>RBT</strong></p><p>如果失去平衡, 找到第一个失去平衡的点左右旋转使得平衡 LL，RR（直接旋转）  LR（先左旋）</p><p> RBT：根是黑色（空结点也是黑色）、红节点不连续、黑节点到达空指针进过的黑点个数相同</p><p><strong>B树</strong>（数据库）：一个节最多m-1个值（连续，访问磁盘次数就会更少），m个孩子节点。m为树的阶</p><p>​非叶子节点最少有(m+1)&#x2F;2子树，最多m</p><p>​叶子节点为空节点，都在同一层</p><p>​<strong>查找</strong>：和BST类似       范围查询：中序遍历</p><p>​<strong>插入</strong>：当节点个数多于(m+1)&#x2F;2时，进行分裂</p><p>​<strong>删除</strong>：终端节点：大于(m+1)&#x2F;2-1个节点：直接删</p><p>​等于(m+1)&#x2F;2-1，去兄弟节点借，借不到就合并：上一层挪下来一个</p><p>​非终端：和相邻关键字（前驱、后驱）互换，就变成了终端节点</p><p><strong>B+树：</strong></p><p>​n个节点n个子树</p><p>​非叶子节点只能索引，叶子节点才指向记录。</p><p>​叶子节点被串成了一个单链表，可以线性访问，头指针被保存。</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>p 在 s中所有的起始位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">ne:p当前匹配失败后，j跳转的位置（j<span class="hljs-number">-1</span>的最大匹配长度） ababc ne[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>  ne[<span class="hljs-number">4</span>]=<span class="hljs-number">2</span><br><span class="hljs-type">void</span> <span class="hljs-built_in">get</span>()&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">-1</span>;<br>    ne[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||p[i]==p[j])&#123;<br>            i++,j++;<br>            ne[i]=j;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;m)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||s[i]==p[j])&#123;<br>            i++,j++;<br>            <span class="hljs-keyword">if</span>(j==n)&#123;<br>                cout&lt;&lt;i-n&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                j=ne[j];  <span class="hljs-comment">// 这里不可以从头开始，不然会少很多  如 aba  ababa</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>&#125;<br>cin&gt;&gt;n&gt;&gt;s&gt;&gt;m&gt;&gt;p;<br><span class="hljs-built_in">get</span>();<br><span class="hljs-built_in">kmp</span>();<br></code></pre></td></tr></table></figure><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>字符串出现次数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>],cnt[N],idx;   <span class="hljs-comment">//son 保存下标</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span>&#123;<br>    <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;str[i];i++)&#123;<br>        <span class="hljs-type">int</span> u=str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u])son[p][u]=++idx;<br>        p=son[p][u];<br>    &#125;<br>    cnt[p]++;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回根节点编号 路径压缩</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x!=p[x])&#123;<br>        p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> fx=<span class="hljs-built_in">find</span>(x),fy=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(fx!=fy)&#123;     <span class="hljs-comment">//在不同的情况下才相加</span><br>        p[fx]=fy;<br>        cnt[fy]+=cnt[fx];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>用数列保存，从1开始存 儿子（2<em>u，2</em>u+1）</p><p>down: 左右儿子已经是堆，加上直接再构成堆    n&#x2F;2开始down</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-type">int</span> t=u;<br>    <span class="hljs-keyword">if</span>(u*<span class="hljs-number">2</span>&lt;=si&amp;&amp;h[u*<span class="hljs-number">2</span>]&lt;h[t])t=u*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;=si&amp;&amp;h[u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]&lt;h[t])t=u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(u!=t)&#123;<br>        <span class="hljs-built_in">swap</span>(h[u],h[t]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span> &amp;&amp; heap[i]&lt;heap[i/<span class="hljs-number">2</span>])&#123;<br>        <span class="hljs-built_in">swap</span>(heap[i],heap[i/<span class="hljs-number">2</span>]);<br>        <span class="hljs-built_in">up</span>(i/<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 插入到最后一个元素，然后up</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br>    now++;<br>    heap[now] = p;<br>    <span class="hljs-built_in">up</span>(now);<br>&#125;<br><span class="hljs-comment">// 最后一个元素放到第一个位置，然后down</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    heap[<span class="hljs-number">1</span>]=heap[now];<br>    now--;<br>    <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>无扩容java堆，0开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPriorityQueue</span>&lt;E&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> Object[] queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyPriorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator)</span>&#123;<br>        <span class="hljs-built_in">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity+<span class="hljs-number">1</span>];<br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.comparator = comparator;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>&#123;<br>        queue[size] = e;<br>        size ++;<br>        up(size-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span>: (E)queue[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> (E)queue[<span class="hljs-number">0</span>];<br>        queue[<span class="hljs-number">0</span>] = queue[size-<span class="hljs-number">1</span>];<br>        size--;<br>        down(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">if</span>(i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;size &amp;&amp; comparator.compare((E)queue[u], (E)queue[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>)&#123;<br>            u = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>&lt;size &amp;&amp; comparator.compare((E)queue[u], (E)queue[i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]) &gt; <span class="hljs-number">0</span>)&#123;<br>            u = i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(u != i)&#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue[i];<br>            queue[i] = queue[u];<br>            queue[u] = t;<br>            down(u);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (i-<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span>(comparator.compare((E)queue[i], (E)queue[p]) &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue[i];<br>            queue[i] = queue[p];<br>            queue[p] = t;<br>            up(p);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>方法1：线性探测表，开两倍地址空间 null&#x3D;0x3f3f3f3f</p><p>&#x2F;&#x2F;返回x对应下标,没有x就返回应该放的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">while</span>(a[k]!=null&amp;&amp;a[k]!=x)&#123;<br>        k++;<br>        <span class="hljs-keyword">if</span>(k==N)k=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法2：链地址法，也是存图的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> mod=<span class="hljs-number">100003</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N; <span class="hljs-comment">//保证都映射到正数上</span><br>    e[idx]=x;<br>    ne[idx]=h[k];<br>    h[k]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[k];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>        <span class="hljs-keyword">if</span>(e[i]==x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><p>将一段<strong>字符串</strong>用一个<strong>数字</strong>表示，字符串低位为数字高位  左高右低</p><p>hash值用ULL保存typedef unsigned long long ULL;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> P=<span class="hljs-number">131</span>;<span class="hljs-comment">//131进制，字符串中下标小的为高位</span><br>ULL p[N];  <span class="hljs-comment">// 进制的i次方</span><br>ULL h[N];  <span class="hljs-comment">// hash值   下标1~i</span><br></code></pre></td></tr></table></figure><p>存入时,计算字符串hash</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    h[i]=h[i<span class="hljs-number">-1</span>]*P+s[i];<br>    p[i]=p[i<span class="hljs-number">-1</span>]*P;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算式，L到R之间的字符串的hash值为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ULL t=h[R]-h[L<span class="hljs-number">-1</span>]*p[R-L+<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>java：前添加字符使得字符串回文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">131</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">mul</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, suffix = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-comment">// abcde</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<br>    prefix = (<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>) prefix * base + c)%mod); <span class="hljs-comment">//a ab abc  正常字符串写法</span><br>    suffix = (<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>) mul * c + suffix)%mod); <span class="hljs-comment">//a ba cba</span><br>    mul = (<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>) mul * base) % mod);<br><br>    <span class="hljs-keyword">if</span>(prefix == suffix)&#123;<br>        idx = i;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">if</span>(idx==n-<span class="hljs-number">1</span> || n==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s.substring(idx+<span class="hljs-number">1</span>)).reverse().toString() + s;<br></code></pre></td></tr></table></figure><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ol><li><strong>单点更新</strong> <code>update(x, delta)</code>： 把序列 x 位置的数加上一个值 delta；  logn</li><li><strong>前缀和查询</strong> <code>query(x)</code>：查询序列 <code>[1,...x]</code> 区间的区间和，即位置 x 的前缀和。logn</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">1005</span>],c[<span class="hljs-number">1005</span>]; <span class="hljs-comment">//对应原数组和树状数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k)</span></span>&#123;    <span class="hljs-comment">//在i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i &lt;= n)&#123;<br>        c[i] += k;<br>        i += <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;        <span class="hljs-comment">//求A[1 - i]的和</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>        res += c[i];<br>        i -= <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-图"><a href="#3-图" class="headerlink" title="3.图"></a>3.图</h2><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N],ne[N],e[N],w[N];<br><span class="hljs-type">int</span> idx;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    w[idx]=c;<br>    e[idx]=b;<br>    ne[idx]=h[a];<br>    h[a]=idx++;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[a];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>    <span class="hljs-type">int</span> j=e[i];<br></code></pre></td></tr></table></figure><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs:"></a>dfs:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 需要标记数组st[N],  遍历节点的每个相邻的边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记一下，记录为已经被搜索过了，下面进行搜索过程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>            <span class="hljs-built_in">dfs</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br>实践：求树的重心 acwing846<br></code></pre></td></tr></table></figure><h3 id="bfs："><a href="#bfs：" class="headerlink" title="bfs："></a>bfs：</h3><p>st[] 和 queue</p><p>求距离，先进距离短 先出</p><p> d[]保存距离，同时判断是否访问过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>    <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(d[j]==<span class="hljs-number">-1</span>)&#123;<br>            d[j]=d[x]+<span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs inform7">无负边 （从顶点角度出发每次取出最近顶点）<br>                                                  都需要dis<span class="hljs-comment">[N]</span><br>   dij稠密          n*n      二维数组           st<span class="hljs-comment">[N]</span> //判断是否已经求出来了<br>   dij稀疏  堆优化      m*logn     邻接表              优先队列存&lt;PII&gt;  st<span class="hljs-comment">[N]</span><br><br><br>有负边  (从边的角度出发)<br><br>   有负环 bellmanford      n*m               struct存边       backup<span class="hljs-comment">[N]</span>//防止串联更新<br>   无负环 spfa             m -&gt; n*m          邻接表            q  st<span class="hljs-comment">[N]</span>//是否在队列中<br>      判负环：不用设置dis，所有点都加入队列                        +cnt<span class="hljs-comment">[N]</span>  连了多少条边<br><br>floyd 动态规划             n^3                 二维数组<br><br><br>二维数组处理重边g<span class="hljs-comment">[a]</span><span class="hljs-comment">[b]</span>=min(g<span class="hljs-comment">[a]</span><span class="hljs-comment">[b]</span>,c); dij初始化可以全为0x3f3f3f3f但floyd不行。<br>邻接表、struct存边不需要额外处理，松弛时自动选择小的边<br><br>存在负边会导致正无穷变小（bellmanford 和 floyd）所以判断改成：dis<span class="hljs-comment">[n]</span>&gt;0x3f3f3f3f /2<br></code></pre></td></tr></table></figure><h4 id="dij"><a href="#dij" class="headerlink" title="dij"></a>dij</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">priority_queue</span>&lt;PII,<span class="hljs-built_in">vector</span>&lt;PII&gt;,greater&lt;PII&gt; &gt; p;<br>p.push(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br><br><span class="hljs-keyword">while</span>(p.size())&#123;<br>    PII tmp = p.top();<br>    p.pop();<br>    <span class="hljs-keyword">if</span>(st[tmp.second])<span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-type">int</span> x = tmp.second;<br>    st[x] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(dis[j]&gt;dis[x]+w[i])&#123;<br>            dis[j] = dis[x]+w[i];<br>            p.push(&#123;dis[j],j&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bellmanford"><a href="#bellmanford" class="headerlink" title="bellmanford"></a>bellmanford</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-comment">// 最多k条边,对所有点的出边进行更新</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>    <span class="hljs-built_in">memcpy</span>(backup,dis,<span class="hljs-keyword">sizeof</span> dis); <span class="hljs-comment">//防止串联更新</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>        <span class="hljs-type">int</span> a=edges[j].a,b=edges[j].b,c=edges[j].c;<br>        dis[b]=<span class="hljs-built_in">min</span>(dis[b],backup[a]+c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果k&#x3D;n时还更新了，就是存在包含点1的负环</p><h4 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h4><p>当一个点距离变小后，所有以该点的出边才可能更新。st数组防止重复添加(不用也能过)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>st[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>    <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    st[t]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;<br>            dis[j]=dis[t]+w[i];<br>            <span class="hljs-keyword">if</span>(st[j]==<span class="hljs-number">0</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>(j);<br>                st[j]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h4><p>最短路包含边数大于n-1</p><p>设置一个虚拟源节点，到所有阶段距离都为0，原图有负环等价于现在的图有负环，</p><p>第一次spfa等价于所以开始时所有点都加入</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">普里姆： 加最近点，有点像dij    n</span><span class="hljs-keyword">^2</span><span class="language-xml"></span><br><span class="language-xml">克鲁斯卡尔： 加最小的边     E</span><span class="hljs-keyword">^2</span><span class="language-xml">     并查集</span><br></code></pre></td></tr></table></figure><h2 id="4-数学"><a href="#4-数学" class="headerlink" title="4.数学"></a>4.数学</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">求 m^k mod p，时间复杂度 <span class="hljs-built_in">O</span>(logk)。<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p, t = m;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k&amp;<span class="hljs-number">1</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>将递推式写成矩阵形式：斐波那契数列 O（n）-&gt; O（m^3*logn）</p><p><a href="https://vjudge.net/contest/350535">矩阵快速幂 - Virtual Judge (vjudge.net)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">6</span>;                  <span class="hljs-comment">//题目中可能出现的最大大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n=<span class="hljs-number">6</span>;                  <span class="hljs-comment">//实际常数矩阵的大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">123456789</span>;        <span class="hljs-comment">// const int 和int 作为模数还运算速度不一样</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> t[N][N];          <span class="hljs-comment">//常数矩阵</span><br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> tmp[N][N];         <span class="hljs-comment">//相乘时的temp  辅助</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multi</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> a[][N],<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> b[][N],<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(tmp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> tmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)<br>                tmp[i][j]=(tmp[i][j]+a[i][k]*b[k][j])%mod;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>    a[i][j]=tmp[i][j];<br><br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> result[N][N];                     <span class="hljs-comment">//保存求幂后的值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> a[][N],<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(result,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> result);             <span class="hljs-comment">//N是矩阵大小</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++) result[i][i]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        <span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">multi</span>(result,a,n);              <span class="hljs-comment">//result=result*a;复制直接在multi里面实现了；</span><br>        <span class="hljs-built_in">multi</span>(a,a,N);                       <span class="hljs-comment">//a=a*a</span><br>        x&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs subunit">n元1次方程组<br><br>初等行列变换：1.某一行乘非零的数   2.交换某2行   3.把某一行的k倍加到另外一行取<br><br>高斯消元：每一次消去每行第一个，把方程边成上三角，再逆推求xn xn<span class="hljs-string">-1</span>...<br><br>完美阶梯型(第一行n个数 第二行n<span class="hljs-string">-1</span>...最后一行1个) 唯一解             r(A)=r(A,b)=n<br>左边没有未知数，右边不为零                    无解                r(A)&lt;r(A,b)<br>方程没有n个                                无穷多组           r(A)=r(A,b)&lt;n<br><br>（矩阵的秩r：矩阵中所有行向量中极大线性代无关组的元素个数。有效方程数量, 阶梯矩阵非零行数）<br>https://www.zhihu.com/question/21605094<br><br>化阶梯型：<br>int r=0,c=0;<br>枚举每一列c 0~n<span class="hljs-string">-1</span><br>1.选出r~n<span class="hljs-string">-1</span>行中，第c列的数最大的那一行(为零就continue),移到第r行上去（最上面）<br>2.将该数a[r][c]化成1<br>3.将r<span class="hljs-string">+1</span>~n<span class="hljs-string">-1</span>行，如果第c列不是零，将第c列化为零<br>成功消除一列r++<br>r==n 有解  有解逆推 i=n<span class="hljs-string">-1</span> ~0，<br>j= i<span class="hljs-string">+1</span>~n<span class="hljs-string">-1</span> <br>a[i][n]-=a[i][j]*a[j][n];<br>r&lt;n <br>for i in r~n<span class="hljs-string">-1</span><br>如果存在b不为零，无解 否则无穷解<br></code></pre></td></tr></table></figure><h2 id="5-dp"><a href="#5-dp" class="headerlink" title="5.dp"></a>5.dp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>每一个状态为一个集合，分集合思想后，求转移方程是通过大的划分出小的(不重不漏)<br><span class="hljs-number">2.</span>代码实现时，是从小的推导出大的，一定要保证转移方程中小的项已经求出来了。自底向上逐步填充数组<br>因此有的循环顺序可以交换：背包、整数划分      有的一定不行：哈密顿<br><span class="hljs-number">3.</span>初始化，按题意给出有效的初始值<br>计数时有效：<span class="hljs-number">1</span>，无效为<span class="hljs-number">0</span><br>最值时有效：<span class="hljs-number">0</span>  负无穷或正无穷<br></code></pre></td></tr></table></figure><h3 id="5-1背包问题"><a href="#5-1背包问题" class="headerlink" title="5.1背包问题"></a>5.1背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">https:<span class="hljs-comment">//blog.csdn.net/yandaoqiusheng/article/details/84782655</span><br><span class="hljs-number">01</span>背包    每种只有一个             <br>完全背包 可以无限重复        <br>    <span class="hljs-number">1000</span> *<span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> 暴力tle，f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j-v[i]] +w[i]) 用本层求出来的值优化<br>多重背包 限制单种数量              <br>    <span class="hljs-number">1000</span>* <span class="hljs-number">2000</span>* <span class="hljs-number">2000</span> 暴力tle，二进制优化（像快速幂），打包后<span class="hljs-number">1000</span>* <span class="hljs-number">2000</span>* <span class="hljs-number">12</span>转化为<span class="hljs-number">01</span>背包  <br>分组背包 每一组最多选一个       <br>    <span class="hljs-number">100</span>* <span class="hljs-number">100</span>* <span class="hljs-number">100</span>直接暴力<br>限制总数量                                <br>    额外一个sum[][]记录当前数量<br><br><span class="hljs-number">1.</span>一维数组存储，用上一层的值j就从大到小，用本层的j从小到大<br><br><span class="hljs-number">2.</span>完全背包 和 <span class="hljs-number">01</span>背包 的区别仅在于状态更新时的遍历顺序。（即<span class="hljs-number">01</span>是逆序，完全是顺序）<br><br><span class="hljs-number">3.</span>不超过容量 和 恰好装满 的区别仅在于二者的初始化~<br>- 前者全<span class="hljs-number">0</span>；也就是全有效<br>- 后者，f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>（第一列），其余全为负无穷，一维：除f[<span class="hljs-number">0</span>]为<span class="hljs-number">0</span>外，其余f[j]都是负无穷）<br></code></pre></td></tr></table></figure><h3 id="5-2线性dp"><a href="#5-2线性dp" class="headerlink" title="5.2线性dp:"></a>5.2线性dp:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>三角形<br><span class="hljs-number">2.</span>a最长上升子序列 f[i] 以i结尾的长度     优化：f[i]长度为i的序列结尾的数字<br><span class="hljs-number">3.</span>a、b最长公共子序列 f[i][j] a[i],b[j]结尾的最大长度   以a[i],b[j]是否出现四次划分<span class="hljs-number">11</span> <span class="hljs-number">10</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span><br><span class="hljs-number">4.</span>编辑距离       f[i][j]a前i个变成b前j个的最小操作次数 只操作i的最后一个字母（<span class="hljs-number">3</span>种）<br><span class="hljs-number">5.</span>最短编辑距离 同上<br><span class="hljs-number">6.</span>石头合并最小代价（最优矩阵相乘）  f[i][j] i到j的代价  最后一次的分界线为分类（因为该区间最后一定是某两个区间合并出来的）<br>(!!!!!!区间问题：先枚举区间长度，再枚举起点，最后再根据决策计算。)<br>    长度 -&gt; 起点 -&gt; 拆分点<br><br><span class="hljs-number">7.</span>整数划分<span class="hljs-number">1.</span> 转化为体积为<span class="hljs-number">1</span>~n的！恰好 ！为n的完全背包物体 计数问题<br>            f[i][j]只取i个数，体积恰好为j的种类<br><br> <span class="hljs-number">2.</span> f[i][j] 总和为i，总数为j   分成有无<span class="hljs-number">1</span>两类 f[i][j]=(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+f[i-j][j])%mod;<br><br><span class="hljs-number">8.</span>计数问题<br></code></pre></td></tr></table></figure><h3 id="5-3状态dp"><a href="#5-3状态dp" class="headerlink" title="5.3状态dp"></a>5.3状态dp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">AcWing <span class="hljs-number">291</span><br>只考虑放水平的方格，列方格自动补全（前提不能有连续奇数个零，不然补全不了）<br>用二进制表示状态，<span class="hljs-number">0</span>表示无<span class="hljs-number">1</span>表示有<br><br>横向放置第i列结尾方格时  <span class="hljs-number">1.</span>满足与第i<span class="hljs-number">-1</span>列不冲突     (j&amp;k)==<span class="hljs-number">0</span><br>         <span class="hljs-number">2.</span>i<span class="hljs-number">-1</span>列剩下的格子，没有连续奇数个格子   st[ j|k ]==<span class="hljs-number">1</span><br>当n不同时，st数组也不同<br><br><span class="hljs-comment">//棋盘为0~m-1列，需要计算到m列</span><br><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> f);<br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)     <span class="hljs-comment">//放以i列结尾的方块</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt; <span class="hljs-number">1</span>&lt;&lt;n ;j++)      <span class="hljs-comment">//i-1列结尾的方块状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt; <span class="hljs-number">1</span>&lt;&lt;n ;k++)     <span class="hljs-comment">//尝试i列结尾的方块状态</span><br>            <span class="hljs-keyword">if</span>((j&amp;k)==<span class="hljs-number">0</span> &amp;&amp; st[j|k])<br>                f[i][k]+=f[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-number">11</span>* <span class="hljs-number">2</span>^<span class="hljs-number">11</span> *<span class="hljs-number">2</span>^<span class="hljs-number">11</span> =<span class="hljs-number">4</span> * <span class="hljs-number">10</span>^<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">acwing <span class="hljs-number">91</span> 最短hamilton哈密顿距离<br><span class="hljs-number">1</span>≤n≤<span class="hljs-number">20</span> <br>用二进制保存进过点的状态 <br><span class="hljs-type">int</span> f[<span class="hljs-number">1</span>&lt;&lt;N][N];<span class="hljs-comment">//i状态 j结尾的最小长度</span><br><span class="hljs-keyword">for</span> 状态<br><span class="hljs-keyword">for</span> 终点<br><span class="hljs-keyword">for</span> 倒数第二个点<br></code></pre></td></tr></table></figure><h3 id="5-4记忆化搜索"><a href="#5-4记忆化搜索" class="headerlink" title="5.4记忆化搜索"></a>5.4记忆化搜索</h3><p>dfs的同时，返回前记录下当前状态值。</p><p>没有上司的舞会、最长滑雪长度 <a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a>(需要注意什么情况下是无解 什么条件是还没求 什么时候是中止)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x])<span class="hljs-keyword">return</span> f[x];<br>    <span class="hljs-comment">// 中止条件 </span><br>    ... 求解f[x]的最优解res<br>    f[x] = res;<br>    <span class="hljs-keyword">return</span> f[x];<br></code></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">322</span>Coin Change：给定无数个定值硬币，最少数量凑出amount。<br>dp：恰好、完全背包<br>记忆化搜索：凑<span class="hljs-keyword">x</span>需要的个数 me[<span class="hljs-keyword">x</span>]<span class="hljs-punctuation">,</span> 画出求解树<span class="hljs-punctuation">,</span>存在重叠，需要记忆优化<br><br>矩阵左上角到右下角传纸条，穿两次路径和最大<br><br>栈的出栈入栈序列<br></code></pre></td></tr></table></figure><h2 id="6-贪心"><a href="#6-贪心" class="headerlink" title="6.贪心"></a>6.贪心</h2><p>0.合并区间</p><p>1.区间选点使得每个区间至少一个点。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">右端点排序，每次更新最右边的点<br></code></pre></td></tr></table></figure><p>2.安排课表，使得上的课最多[区间不重叠]</p><p>3.区间分组，组内互不相交      优先队列+左端点排序</p><p>4.选择区间覆盖指定区间。     左端点+贪心</p><p>5.排序</p><p>6.牛的最大忍耐度最小     对两头牛交换，会导致结果变大还是变小</p><h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="Hot-100"><a href="#Hot-100" class="headerlink" title="Hot 100"></a>Hot 100</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1 两数之和 hash  双指针<br>4  二分<br>5 最长回文 dp || 马拉车<br>10 正则表达式匹配 ！ dp  处理边界以及情况列举<br>11 盛水容器  每次移动是丢弃了一些状态 <br>15 三数和为零 排序+双指针 如何去重<br>19 一次遍历删除链表第n个元素  快慢指针<br>23 合并k个有序列表  分治！类似归并、维护优先队列<br>31 下一个排序 找规律<br>33 旋转过的有序数组 二分寻找一个数<br>34 二分模板<br>39 dfs   引用更快，但需要回溯回状态<br>42 不会<br>46 全排列<br>48 旋转矩阵<br><br>49 输入vector<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span></span> 将所含字母相同放入一个vector中输出<br><span class="hljs-code">1.map&lt;string,[s1,s2]&gt; string为排序后 s1,s2为原来</span><br><span class="hljs-code">2.将字母映射一个质素double a[26]=&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101&#125;;</span><br><span class="hljs-code">将string转为质素相乘，其他与1一样，少一个排序时间</span><br><span class="hljs-code">小心溢出，用long long后取余(余数要大)或者用double</span><br><span class="hljs-code">3.如果是string需要完全相同，可以字符串哈希映射为一个数字</span><br><span class="hljs-code"></span><br>53* 字串的最大连续和  【dp】  分治更优<br><br>55 从数组第一个位置能否跳到最后一位置，数组上值为最大跳跃距离  dp优化成【贪心】<br><br>56 区间合并 【贪心】<br><br><span class="hljs-bullet">62.</span> 【dp】或者 记忆化搜索 或者 排列组合<br><br>63 【dp】可以优化空间到<br><br>64 【dp】可以直接原数组上dp<br><br>70 【dp】或找规律<br><br>72 最短编辑距离 【dp】    边界条件(如何初始化方便)<br><br>75 将数组分为0 1 2 【partition】 L:下一个放0的位置   R：放2   <br><br>76 【滑动窗口】求最小覆盖串<br><span class="hljs-code">滑动窗口的套路</span><br><span class="hljs-code">先找到一个可行解，再优化这个可行解。</span><br><span class="hljs-code">优化到不能优化，产生出一个可能的最优解。</span><br><span class="hljs-code">继续找新的可行解，再优化这个可行解。</span><br><span class="hljs-code"></span><br><span class="hljs-code">直接用数组代替map映射需要的字母的数量，用额外count记下还需要匹配多少个，免去遍历过程</span><br><span class="hljs-code"></span><br>78  求无重复数组的子集   直接每层选出一个，下一层接着这个数选，有重复的话剪枝，排序后只拿第一个<br><br>79  普通回溯，记得找到后【提前结束】寻找，不然超时<br><br>84  柱状图中最大的矩形 暴力：以i为高度两边扩散；     【单调栈】<br><br>85  多个84题<br><br>96  n个节点二叉搜索数的个数    暴力超时，dp分解求解   卡特兰数<br><br>98 验证二叉搜索树  中序遍历为上升序列，巧用pre保存前一个点<br><br>101 对称二叉树  dfs<br><br>102二叉树层次遍历  需要知道层次，一次性处理一行<br><br>105前序中序得到树dfs<br><br>114 将树转为链表：右节点转为下一个节点  dfs<br><br>128 最长连续序列  数组中的数值，连续的最长序列长度<br><span class="hljs-code">1.暴力：计算以每一个数为开头的长度n  2.优化：只计算区间起点的长度    3.并查集</span><br><span class="hljs-code"></span><br>136 只出现一次的数字  异或<br><br><span class="hljs-bullet">142.</span> 环形链表 II  并返回入环点<br><br><span class="hljs-bullet">152.</span> 乘积最大子数组 dp<br><br><span class="hljs-bullet">155.</span> 最小栈 栈，但能获取到最小值<br><br><span class="hljs-bullet">160.</span> 相交链表 求相交点 1.hash 2.求多出来的长度 3.相互连接起来<br><br><span class="hljs-bullet">169.</span> 多数元素 删除不同的两个数 还是多数元素<br><br><span class="hljs-bullet">198.</span> 打家劫舍<br><br><span class="hljs-bullet">200.</span> 岛屿数量 DFS||BFS<br><br><span class="hljs-bullet">206.</span> 反转链表<br><br><span class="hljs-bullet">207.</span> 课程表 图是否有环  拓扑图 ||  DFS搜索看是否回来<br><br><span class="hljs-bullet">215.</span> 数组中的第K个最大元素<br><br><span class="hljs-bullet">221.</span> 最大正方形  dp  直接用长方形来解答的，没用答案的正方形性质<br><br><span class="hljs-bullet">235.</span> 二叉搜索树的最近公共祖先  非搜索树236也可也解，递归，函数返回结果为是否包含p或q<br><br><span class="hljs-bullet">238.</span> 除自身以外数组的乘积  不用除法、On时间 On空间  前缀和<br><br><span class="hljs-bullet">240.</span> 搜索二维矩阵 II  在搜索矩阵中高效找一个数<br><br><span class="hljs-bullet">287.</span> 寻找重复数 有一个数出现两次及以上  二分 | 位运算<br><br><span class="hljs-bullet">297.</span> 二叉树的序列化与反序列化 解析时删除元素<br><br><span class="hljs-bullet">300.</span> 最长递增子序列<br><br><span class="hljs-bullet">301.</span> 删除无效的括号  可能的方案？<br><br><span class="hljs-bullet">309.</span> 买卖股票的最佳时机含冷冻期  dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">3</span>]<br><br><span class="hljs-bullet">322.</span> 零钱兑换  dp  见分类刷题-dp<br><br><span class="hljs-bullet">337.</span> 打家劫舍 III  树上 记忆化搜索  不要考虑两种情直接求<br><br><br><span class="hljs-bullet">538.</span> 把二叉搜索树转换为累加树 反中序遍历<br><br><span class="hljs-bullet">543.</span> 二叉树的直径<br><br><span class="hljs-bullet">560.</span> 和为 K 的子数组  <br><br><span class="hljs-bullet">581.</span> 最短无序连续子数组 nlogn排序-二分  找规律技巧<br><br><span class="hljs-bullet">617.</span> 合并二叉树<br><br><span class="hljs-bullet">647.</span> 回文子串<br><br>739 每日温度 下一个更大的温度 单调栈<br></code></pre></td></tr></table></figure><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sml"><span class="hljs-number">23</span> 合并多个有序列表  直接排序  两两合并   k个指针-》优先队列<br><span class="hljs-number">24</span> 两两交换链表节点  递归<br><span class="hljs-number">26</span> 删除有序<span class="hljs-built_in">vector</span>重复项     双指针<br><br><span class="hljs-number">172</span> 阶层中零的个数<br><span class="hljs-number">202</span> 将一个数每一位求平方和，判断最后是否收敛到<span class="hljs-number">1</span>  <span class="hljs-number">19</span>-&gt;<span class="hljs-number">82</span>-&gt;<span class="hljs-number">68</span>-&gt;<span class="hljs-number">100</span>-&gt;<span class="hljs-number">1</span>  <br>判断是否存在循环：快慢指针、hash<br><span class="hljs-number">347</span> 输出数组中频率最高的k个数，用hash统计次数后，用小根堆优化到nlogk,因为小根堆每次弹出最小的logk<br><br><br><br><br></code></pre></td></tr></table></figure><p>卡特兰数：n对括号正确匹配数目 (22)，n个节点二叉搜索树(96)，出栈次序，矩阵相乘<br>C0 &#x3D; 0   Cn+1 &#x3D; 2(2n+1) &#x2F; (n+2) * Cn</p><p>$$<br>C0 &#x3D; 0      ~~~~~~~~~<br>Cn+1&#x3D;<br>\frac{2(2n+1)}{n+2}Cn<br>$$</p><h2 id="分类刷题"><a href="#分类刷题" class="headerlink" title="分类刷题"></a>分类刷题</h2><p><a href="https://github.com/doocs/leetcode">doocs&#x2F;leetcode: 😏 LeetCode solutions</a></p><h3 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1. 基础算法"></a>1. 基础算法</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">在排序数组中查找元素的第一个和最后一个位置 - 二分查找<br>准时到达的列车最小时速 - 二分查找  对速度进行二分<br>找到需要补充粉笔的学生编号 - 二分查找<br>可移除字符的最大数目 - 二分查找<br><br>排序数组 - 快速排序、归并排序<br><br>字符串相加 - 高精度加法<br>字符串相乘 - 高精度乘法<br><br>区域和检索 - 数组不可变 - 前缀和<br>二维区域和检索 - 矩阵不可变 - 二维前缀和<br>区间加法 - 前缀和、差分<br>用邮票贴满网格图 - 二维前缀和、二维差分<br><br><br>位<span class="hljs-number"> 1 </span>的个数 - 位运算、lowbit<br>合并区间 - 区间合并<br></code></pre></td></tr></table></figure><h3 id="2-数据结构-1"><a href="#2-数据结构-1" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">设计链表 <span class="hljs-operator">-</span> 单链表、指针引用、数组实现<br>下一个更大元素 <span class="hljs-built_in">I</span> <span class="hljs-operator">-</span> 单调栈<br>每日温度 <span class="hljs-operator">-</span> 单调栈<br>子数组的最小值之和 <span class="hljs-operator">-</span> 单调栈<br>最大宽度坡 <span class="hljs-operator">-</span> 单调栈<br>最多能完成排序的块 <span class="hljs-variable">II</span> <span class="hljs-operator">-</span> 单调栈   ×<br>子数组范围和 <span class="hljs-operator">-</span> 单调栈<br>子数组最小乘积的最大值 <span class="hljs-operator">-</span> 单调栈<br>滑动窗口最大值 <span class="hljs-operator">-</span> 单调队列<br>满足不等式的最大值 <span class="hljs-operator">-</span> 单调队列 ×<br>和至少为 <span class="hljs-built_in">K</span> 的最短子数组 <span class="hljs-operator">-</span> 单调队列   尝试单调栈<span class="hljs-operator">-&gt;</span>无单调性？  前缀和<span class="hljs-operator">+</span>单调队列<br>带限制的子序列和 <span class="hljs-operator">-</span> 动态规划、单调队列优化<br>单词规律 <span class="hljs-variable">II</span> <span class="hljs-operator">-</span> 哈希表、回溯 ×<br>最短回文串 <span class="hljs-operator">-</span> 字符串哈希<br>回文对 <span class="hljs-operator">-</span> 字符串哈希<br>最长重复子串 <span class="hljs-operator">-</span> 字符串哈希、二分查找<br>不同的循环子字符串 <span class="hljs-operator">-</span> 字符串哈希<br></code></pre></td></tr></table></figure><h4 id="滑动窗口（双指针）"><a href="#滑动窗口（双指针）" class="headerlink" title="滑动窗口（双指针）"></a>滑动窗口（双指针）</h4><p>查找满足某要求的字串、子序列；<strong>解题时看到字串子序列：先考虑所有以i结尾的串，在考虑j的单调</strong></p><p>（此外还有一种二分的解法 nlogn：每一个right结尾时，二分寻找left的最优）</p><p><strong>基本思想</strong>：随着 i的增大，满足 某表达式 的j 值是单调的。</p><p>​        1.我遍历了全部以i结尾的串。确保不遗漏<br>​        2.暴力：j需要for一次 -&gt; 如果以i结尾的<code>j~i</code>窗口是一个可行解，i往后移，<strong>j不能回头</strong>。该单调性可以优化掉O(n^2^)</p><p><strong>步骤</strong></p><ol><li>左右指针ji控制窗口，遍历右指针i向右边移动，以获取所有的答案（理解为以i结尾的所有串）</li><li>目前ji是可行解</li><li>当前窗口<code>i++</code>，不是可行解或最优解（窗口大小,字符数量）</li><li><code>j++</code>，直到可行</li><li>更新res</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 朴素 N^2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (check(i, j)) &#123;<br>            <span class="hljs-comment">// 具体问题的逻辑 res = max(res, j-i+1)</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 双指针 N</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; check(i, j)) j ++ ;<br>    <span class="hljs-comment">// 具体问题的逻辑 res = max(res, j-i+1)</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题：</strong></p><ol><li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小且sum大于k的子数组</a>：<code>j~i</code>以i结尾长度最小且大于k，<code>j ~ i+1</code> 一定大于但可能不是最短； 除了双指针还可以二分j</li><li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a>：<code>j~i</code>以i结尾无重复且最长，<code>j ~ i+1</code>  不一定无重复，但j一定是往后移动缩小窗口，使得无重复<ol><li><a href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/description/">长度为 K 的无重复字符子串</a> 多一个长度缩小</li></ol></li><li><a href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a>：s2是否存在的某个子串刚好包含s1全部字符  ；直接长度判断是否满足</li><li><strong>最小覆盖字串</strong>：s中字串能包含t全部字符，且最小（可以多）。<code>j~i</code>覆盖且最小，<code>j ~ i+1</code>  覆盖但不一定最小，但j一定是往后移动缩小窗口，使得更小；用一个变量记录下一共要多少个字符、一个hash记录每个字符需要多少</li><li><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">乘积小于 K 的子数组</a>：有多少个子串乘积后严格小于k。<code>j~i &lt; k</code>，<code>j ~ i+1</code>不一定&lt;k, 但j一定要往后走<ol><li>拓展：字串加减乘除(不能有负数:<a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">反例</a>) 满足 大于小于某个值:<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">相加大于某个值</a></li></ol></li><li><a href="https://www.acwing.com/problem/content/802/">数组元素的目标和</a>两个升序数组，求和为x的两个数组的下标<ul><li>一个i指针一直往大了走，说明窗口是变大的，那么j的移动方向就是使得窗口值变小</li><li>因此推断<code>i=0  -&gt; n</code> ;  <code>j=m-1 -&gt; 0</code>  <ul><li>if  <code>v(i,j)&gt;x</code>，j一直移动变小，直到满足&lt;&#x3D;x       （<code>v(i,j)&gt;x</code>，那么<code>v(i+1,j)&gt;x</code>，不会遗漏）</li><li>如果ij小于x，x变大，并且j</li></ul></li></ul></li><li><a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">统计定界子数组的数目</a> 满足最大为min 最小为max的子数组的数量<ol><li>维护两个指针，i是以i结尾的子数组。</li><li>当i不越界时，数量关系取决于最后一个min 和 max的下标</li><li>当i越界时，两指针都跳到i+1</li></ol></li><li><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">最大连续1的个数 III</a>：最多存在k个0，求数组连续1的个数</li></ol><h4 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h4><ul><li><p>想知道每个元素前后第一个比它大(或小)的元素；  当新来元素很大时，前面比他小的都找到下一个更大了 于是出栈，所以栈中是一个递减的序列</p></li><li><p><code>pre ~ i ~ next</code>时(两边只包含一个) i 都是最大，就可以知道所有子数组中，i 当了<code>(k-i)(i-j)</code>次老大</p></li><li><p>经常要求所有子数组的个数或者子数组求和，需要注意越界问题</p></li></ul><p>求下一个更大：暴力：每个元素都可能要遍历后面的所有；优化：维护一个栈，当目前元素比栈顶更大时，栈顶就找到了下一个更大。一直pop，最后栈顶是i的前一个更大</p><p>模板1：当前元素必须进栈，进栈后影响栈内元素  可以见<a href="https://leetcode.cn/problems/sum-of-subarray-ranges/">https://leetcode.cn/problems/sum-of-subarray-ranges/</a><br>这里pre next 一个是严格一个不是，可以保证子数组不重不漏！ <strong>如果都想要严格或者非严格就再求一次</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt;= nums[i]) &#123;<br>        nextBig[stack.top()] = i; <span class="hljs-comment">// 栈顶的下一个非严格大是i，出栈时记录   下面是严格大，去掉等号要反过来</span><br>        stack.pop();<br>    &#125;<br>    preBig[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();  <span class="hljs-comment">// 当前i的前一个严格大是栈顶</span><br>    stack.push(i);<br>&#125;<br><span class="hljs-comment">// 不能忘了最后栈内的</span><br><span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>    nextBig[stack.pop()] = n;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板2：当前元素可能不进栈，进栈后会影响后面未进栈的。左边小的可以让后面大的都不进栈，相当于从右到左模板1的弹出过程,用的比较少，看题目具体情况（最大宽度坡）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (stack.isEmpty() || nums[stack.peek() &gt; nums[i]]) &#123;<br>    stack.push(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>模板1从左到右和从右到左得到结果不一样</li><li>从左到右模板2的结果和从右到左模板1并反序，栈内元素会一样</li></ul><p>例题：</p><ol><li><p><a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a></p></li><li><p>求所有子数组中最小值，并求和  907</p><p>​<strong>方法一</strong>:  dp[i] 以i结尾的所有子数组，最小和：<code>a[i]</code>能影响到上一个比a[i]小数a[j] <strong>单调栈</strong>，dp[i] &#x3D; dp[j] + (i-j)*a[i]  如果这一步不dp记录下来，就会导致超时</p><p>​<strong>方法二</strong>：每个元素 <code>nums[i]</code> 作为最小值出现在了多少个子数组中：pre j、next k <code>(k-i)(i-j)</code>。<strong>单调栈！</strong></p><p>​<strong>方法三</strong>：排序后，从最小数的下标开始  <code>Arrays.sort(B, (i, j) -&gt; ((Integer) A[i]).compareTo(A[j]));</code></p></li><li><p>最大宽度坡  满足 <code>A[i] &lt;= A[j]</code> 的最大 <code>j - i</code> 值</p><p>​需要从左往右建立一个特殊的栈，小的元素会导致后面大的元素直接不进栈，建立后从右往左找规律求结果</p></li><li><p><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">最多能完成排序的块 II</a> 排序子数组使得整体有序</p><p>​1、找规律 max nums[0:i-1] &lt; min nums[i:n-1]   和单调栈无关</p><p>​2、和排序的对比字符数</p><p>​3、单调栈</p></li><li><p><a href="https://leetcode.cn/problems/sum-of-subarray-ranges/">子数组范围和</a>  </p><p>​求全部子数组(max-min)，并求和，同2，但多一个最pre nextMax。</p></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray-min-product/">子数组最小乘积的最大值</a></p><p>​求全部子数组中，<code>min(a) * sum(a)</code>最大的。mina 还是用单调栈，注意这里是越宽越好，所以pre next都用非严格的两次去求(单次同时求出非严格需要跳跃 <a href="https://leetcode.cn/submissions/detail/427726444/">代码</a>)。（其实一个非严格一个严格也可以，因为第一个元素的nextBig会包裹相同元素，1111相当于以第一个1为代表）。</p></li></ol><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>​为什么要引入队列？有的题目前后都要弹出！！元素满足单调性</p><p>理解：通过单调性来移出不优的元素，例如在“和至少为 K 的最短子数组”，对于每个点作为左节点<code>j</code>，如果来了一个新值<code>j‘</code>，并且更小，那么左边的旧值<code>j</code>就永远不需要看了；作为左节点<code>j</code>如果<code>j~i</code>满足条件，那么右边的<code>j~i&#39;</code>就不用再看了</p><p><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/description/[">可以获取最值的队列</a>  可以在队尾插入，队头取出；并且O1最大值</p><ol><li>维护全局一个最大值，但该元素出队列后找不到下一个最大值  ×</li><li>维护有效最大值列表，使得最大出列后还能找到第二大：<ol><li>有效的特点：当队尾来了一个很大的数，最大值列表中的小值都可以被忽略了，所以是一个递减的</li><li>队头也可也删除元素，当普通队列的元素和最大值队列队头相同时，最大值队列需要出队</li></ol></li><li>类似题目：<a href="https://leetcode.cn/problems/min-stack/">可以获取最小值的栈</a>  同样是维护一个最小值列表</li></ol><p>[滑动窗口最大值](<a href="https://github.com/doocs/leetcode/blob/main/solution/0200-0299/0239.Sliding">https://github.com/doocs/leetcode/blob/main/solution/0200-0299/0239.Sliding</a> Window Maximum&#x2F;README.md)</p><p>​求滑动窗口的最大值，当新来元素很大时，前面比他小的都可以忽略了，所以窗口中是一个递减的序列，最大值就在peekLast  （此外还可以维护一个优先队列（堆） <code>O(logn)</code>取出最值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队尾超出窗口大小 pop</span><br><span class="hljs-keyword">while</span>(deque.peekLast().index&lt;i-k+<span class="hljs-number">1</span>)&#123;<br>    deque.pollLast();<br>&#125;<br><br><span class="hljs-comment">// 队头出pop， 并且新元素入队</span><br><span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekFirst().value&lt;nums[i])&#123;<br>    deque.pollFirst();<br>&#125;<br>deque.addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(nums[i], i));<br><span class="hljs-comment">// 根据队列最大值计算相关值</span><br>res[i] = deque.peekLast().value;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">和至少为 K 的最短子数组</a> ：如果全是正数，那么用双指针可以把空间复杂度也降低到O1</p><ol><li><p>使用<code>前缀和的差</code>来计算子数组的和；</p></li><li><p>使用一种数据结构，将<code>当前前缀和i</code>与<code>最前面的前缀和j</code>作差，如果满足&gt;&#x3D;k的条件，那么<code>j</code>在之后就可以不用看了。【因为即使后面也有满足条件的，长度也会更长，所以需要将j从前面弹出】；</p></li><li><p>第2步完成了之后，当前的i也要放入数据结构，那么如果数据结构中有<code>前缀和j</code>比<code>前缀和i</code>大，j也可以不用看了。【因为即使后面有满足条件的，与i作差肯定也满足条件，并且长度更短，所以需要将大于等于i的从后面弹出】。</p><p>​前面后面都要弹出，压入的元素满足单调性，所以使用单调队列。</p><p>数组存在负数，所以不能用二分查找i结尾的起点在哪。</p><p>第二次做：其实是找满足条件的<code>j~i</code>，不能暴力遍历就找规律：对于左起点j以及右终点i，如果<code>j~i</code>当前满足了，那j不需要再去找后面的i了；i以后作为左起点 对于左起点，如果当前比左边的数小，那么左边的数都不可能再作为左起点了</p></li></ol><p><a href="https://leetcode.cn/problems/constrained-subsequence-sum/">带限制的子序列和</a>  求<code>max ( sum[子序列] )</code> ， 且子序列中的最大下标间隔不能超过k</p><ol><li><code>dp[i]</code> 代表以i结尾的子序列的最大和，保证不遗漏</li><li><code>dp[i] = max(dp [i-k] ~ dp[i-1])</code>  如果遍历k的话，超时；分析目前是想得到前k个元素的最大值</li><li>维护一个窗口大小为k的单调队列！</li></ol><h3 id="3-搜索"><a href="#3-搜索" class="headerlink" title="3.搜索"></a>3.搜索</h3><p>BFS：有很多结果，需要最优的，所以需要BFS同时尝试所有的，并且最先遇到的就是最优解<br>DFS：存在问题，只需要一个；把一种可能的情况尝试到底</p><p><strong>BFS</strong>：状态转换 + <strong>最短路&#x2F;最小步数&#x2F;最小操作</strong>；空间范围有限</p><ul><li>有一个全局的visit代表是否访问过，<strong>用来保证不走回头路</strong>，可以用距离(使用距离的话，入队的点就不用额外保存距离)</li><li><strong>入队时</strong>标记而不是出队时标记，防止同一个节点入队两次</li><li>只将有意义的节点入队，同时入队时判断结束条件最好：<a href="https://leetcode.cn/problems/minimum-operations-to-convert-number/">转化数字的最小运算数</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">grid[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 入队时标记</span><br>deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;n-<span class="hljs-number">1</span>, m-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);<br><br><span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>    <span class="hljs-type">int</span>[] tmp = deque.pollFirst();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> tmp[<span class="hljs-number">0</span>], y = tmp[<span class="hljs-number">1</span>], dis = tmp[<span class="hljs-number">2</span>];<br>    <br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>&amp;&amp;y==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> dis; <span class="hljs-comment">// 出队时判断全集最优 结束搜索</span><br><br>    <span class="hljs-type">int</span> []dx = &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> []dy = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">xx</span> <span class="hljs-operator">=</span> x + dx[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">yy</span> <span class="hljs-operator">=</span> y + dy[i];<br>        <span class="hljs-keyword">if</span>(xx&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;xx&lt;n&amp;&amp;yy&lt;m&amp;&amp;grid[xx][yy]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 入队的条件</span><br>            grid[xx][yy] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 入队标记</span><br>            deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;xx, yy, dis+<span class="hljs-number">1</span>&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br>https:<span class="hljs-comment">//leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/submissions/505710677/</span><br></code></pre></td></tr></table></figure><p>优化：<strong>双向DFS</strong>，可以节约百倍空间复杂度[模板](<a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/submissions/505775766/">1091. 二进制矩阵中的最短路径 - 力扣（LeetCode）</a>) <a href="https://leetcode.cn/problems/open-the-lock/submissions/505756847/">模板code</a>  </p><p>1+2+4+8+16+32+64+128+256+512  -&gt;    1+2+4+8+16  + (相遇)  16+8+4+2+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">queue1、queue2 为两个方向的队列<br>dis1、dis2 为两个方向的距离数组，记录每个节点距离起点的<br><br>更新时优先更新小的，并且一次更新一层<br>二者相遇时即为结果<br><br>    <span class="hljs-keyword">while</span>(!deque1.isEmpty() &amp;&amp; !deque2.isEmpty())&#123;<br>        <span class="hljs-type">int</span> res=-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 优先扩展size小的 缩小搜索空间</span><br>        <span class="hljs-keyword">if</span>(deque1.size()&lt;deque2.size())&#123;<br>            res = update(deque1, dis1, dis2);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res = update(deque2, dis2, dis1);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(res!=-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">return</span>-<span class="hljs-number">1</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Deque&lt;Integer&gt; deque, <span class="hljs-type">int</span> []dis, <span class="hljs-type">int</span> []other)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> deque.size();<br>        <span class="hljs-keyword">while</span>(num-- != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> deque.pollFirst();<br><br>            <span class="hljs-comment">// 相遇为终结</span><br>            <span class="hljs-keyword">if</span>(other[x] != -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> dis[x] + other[x];<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-comment">// 具体业务</span><br>                <span class="hljs-keyword">if</span>(...&amp;&amp;dis[now]==-<span class="hljs-number">1</span>)&#123;<br>                deque.addLast(now);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>DFS</strong>：</p><ul><li>存在问题，剪枝：搜索到了就直接<code>return true</code>   <a href="https://leetcode.cn/problems/word-search/">单词搜索</a> <a href="https://leetcode.cn/problems/matchsticks-to-square/">火柴拼正方形</a> <a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">划分为k个相等的子集</a></li><li>最优问题，剪枝：<ul><li>最大值：遍历全部 <a href="https://leetcode.cn/problems/path-with-maximum-gold/"> 黄金矿工</a></li><li>最小值：维护一个全局最小，当前值大于就剪枝 <a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">公平分发饼干</a>  <a href="https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/">完成所有工作的最短时间</a></li></ul></li></ul><p>​进入时修改状态，回溯后改回状态</p><p><strong>记忆化搜索</strong>： 自顶向下，并记录。可以改写dp</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs excel">图像渲染- BFS、DFS、Flood Fill 算法、连通性模型<br>岛屿数量 - BFS、DFS、Flood Fill 算法<br><span class="hljs-number">01</span> 矩阵 - 多源 BFS     注意只能多源BFS！！DFS实现失败   还可以dp，但没看<br>地图中的最高点 - 多源 BFS 和上面一模一样<br>进击的骑士 - BFS、最短路模型   暴力或者双向BFS<br>二进制矩阵中的最短路径 - BFS、最短路模型     模板  如果入队没有标记而是出队标记 会超时<br>迷宫中离入口最近的出口 - BFS、最短路模型     模板<br><br>网格中的最短路径 - BFS、最短路模型           从左上到右下最短路，可以删除k个障碍；这里即便访问过，后来的也可也访问：入队额外记录剩余删除个数，如果比全局的更多（后来的距离一定更大，想要继续走就必须要剩余更多删除），就可以入队<br><br>打开转盘锁 - 最小步数模型、双向 BFS、A* IDA*  四位旋转到目标数  看上去题目复杂，但搜索空间只有<span class="hljs-number">1</span>e5 直接暴力 dfs第一次遇到的是最优的，set去重。  双向BFS优化模板<br><br>单词接龙 - 最小步数模型、双向 BFS   同上 仔细分析搜索空间其实不是特别大  最多也就<span class="hljs-number">5</span>k个词<br>转化数字的最小运算数 - 最小步数模型、双向 BFS<br>滑动谜题 - BFS、最小步数模型、A* 算法<br>访问所有节点的最短路径 - BFS、最小步数模型、A* 算法<br>为高尔夫比赛砍树 - BFS、A* 算法<br>使网格图至少有一条有效路径的最小代价 - 双端队列 BFS<br>到达角落需要移除障碍物的最小数目 - 双端队列 BFS<br><br>迷宫 - DFS、连通性模型、Flood Fill 算法<br>单词搜索 - DFS、搜索顺序、回溯<br>黄金矿工 - DFS、搜索顺序、回溯<br>火柴拼正方形 - DFS、回溯、剪枝 <span class="hljs-built_in">n</span>=<span class="hljs-number">15</span>          数组组合成一个正方形，暴力遍历 <br><span class="hljs-number">1</span>.从组成边的角度出发：<span class="hljs-built_in">n</span>! used标记 在组成某一条边时，注意不能回头选择(去重)！！所以需要起始idx<br><span class="hljs-number">2</span>.从使用每一个数字出发： 每个数字可以放<span class="hljs-number">4</span>个位置 <span class="hljs-number">4</span>^<span class="hljs-built_in">n</span> 剪枝：优先遍历大的数字，这样遍历空间更小<br><span class="hljs-number">3</span>.状态压缩 + 动态规划<br><br>划分为 k 个相等的子集 - DFS、回溯、剪枝  k&lt;=<span class="hljs-number">16</span>    同上, 数组从划分<span class="hljs-number">4</span>个子数组改为k个<br><span class="hljs-number">1</span>.从组成子集角度 <span class="hljs-built_in">n</span>!<br><span class="hljs-number">2</span>.从使用每一个数字：k^<span class="hljs-built_in">n</span>   超时！<br><br>公平分发饼干 - DFS、回溯、剪枝  <span class="hljs-built_in">n</span>=k=<span class="hljs-number">8</span>   数组划分为k个，求划分使得最小化：<span class="hljs-built_in">max</span>(<span class="hljs-built_in">sum</span>(子数组)) 同下<br><span class="hljs-number">1</span>.无法从组成子集角度 <br><span class="hljs-number">2</span>.分配每一个数字即可, <span class="hljs-built_in">n</span>=<span class="hljs-number">8</span>不需要剪枝<br><br>完成所有工作的最短时间 - DFS、回溯、剪枝  <span class="hljs-built_in">n</span>=k=<span class="hljs-number">12</span>   数组划分为k个，求划分使得最小化：<span class="hljs-built_in">max</span>(<span class="hljs-built_in">sum</span>(子数组))<br><span class="hljs-number">2</span>.从分配每一个任务角度：k^<span class="hljs-built_in">n</span>   超时！   剪枝：维护一个全局最优  降序排列<br>剪枝：默认dfs第一次会把任务全给<span class="hljs-number">0</span>号工人，其实是最差情况，我们希望分配平均一点<br> 优化<span class="hljs-number">1</span>：先用优先队列贪心求取出一个res，缩小dfs范围<br> 优化<span class="hljs-number">2</span>：配i+<span class="hljs-number">1</span>前必须先分配i，因为二者等价 (最方便！！！)<br> 优化<span class="hljs-number">3</span>. 优先分配给未分配的工人; 因为未分配都一样，所以就分配给未分配的第一个人<br>     可以快速获得一个全局最优，并且去重。原来第一个任务分配给所有人，现在只给<span class="hljs-number">1</span><br> 优化<span class="hljs-number">4</span>. 对分配排序，每次取出最小的：问题<span class="hljs-number">1</span> 直接排序下一层影响这一层，使用idx<br>           问题<span class="hljs-number">2</span> 每次都排序复杂度太高了，排序行不通<br>     <br><span class="hljs-number">3</span>. 状态压缩 dp<br><br><br>矩阵中的最长递增路径 - DFS、记忆化搜索      模板<br>网格图中递增路径的数目 - DFS、记忆化搜索    模板  上面是最大长度，这里是求和<br>翻转游戏 II - DFS、状态压缩、记忆化搜索 你和朋友轮流将 连续 的两个 <span class="hljs-string">&quot;++&quot;</span> 反转成 <span class="hljs-string">&quot;--&quot;</span> 是否存在必胜<br>代码特别优雅，使用位运算实现字符串的改变<br>String nextState = state.substring(<span class="hljs-number">0</span>, i) + <span class="hljs-string">&quot;--&quot;</span> + state.substring(i + <span class="hljs-number">2</span>);<br><br>    // 优化<br>    <span class="hljs-built_in">if</span> ((mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) == <span class="hljs-number">0</span> || (mask &amp; (<span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>))) == <span class="hljs-number">0</span>) &#123;<br>    continue;<br>    &#125;<br>    <span class="hljs-built_in">if</span> (dfs(mask ^ (<span class="hljs-number">1</span> &lt;&lt; i) ^ (<span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>)))) &#123;<br>    continue;<br>    &#125;<br>    <br>    <br>统计所有可行路径 - DFS、记忆化搜索    <br>模板，记录从 dp[i][fuel]  从i并且有fuel燃料 到finish 有多少解法 <span class="hljs-built_in">sum</span> dfs(j, fuel-cost(i-&gt;j))<br>需要注意边界条件，如果i==finish，那么ans += <span class="hljs-number">1</span> 当前立即结束代表一种解法<br><br>改写成dp！！！  fuel 有大小关系所以在外层，注意dp的初始化<br><br>切披萨的方案数 - DFS、记忆化搜索  ×<br></code></pre></td></tr></table></figure><h3 id="4-DP"><a href="#4-DP" class="headerlink" title="4.DP"></a>4.DP</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs inform7">杨辉三角 - 线性 DP、数字三角形模型<br>最小路径和 - 线性 DP、数字三角形模型<br><br>摘樱桃 - 线性 DP、数字三角形模型  ×<br><br>摘樱桃 II - 线性 DP、数字三角形模型<br><br>最长递增子序列 - 线性 DP、最长上升子序列模型<br>暴力：查找前面所有的<br>优化：如果当前长度为5，并且结尾字符比以前的长度为5的结尾字符小，那么以前的就被忽略了，有点像单调栈<br>所以每一个长度只需要保存一个结尾字符最小的就行了。<br>长度越长结尾字符肯定越大，用二分查找哪一个长度的字符刚好比现在小<br><br>无重叠区间 - 线性 DP、最长上升子序列模型、贪心优化<br>dp：以当前区间结尾的 无重复区间数，和上面一样可以用二分优化<br><br>删列造序 III - 线性 DP、最长上升子序列模型<br><br>俄罗斯套娃信封问题 - 线性 DP、最长上升子序列模型、贪心优化<br><br>堆叠长方体的最大高度 - 排序、线性 DP、最长上升子序列模型<br>无矛盾的最佳球队 - 排序、线性 DP、最长上升子序列模型<br><br><br>最长公共子序列 - 线性 DP、最长公共子序列模型<br>两个字符串的最小 ASCII 删除和 - 线性 DP、最长公共子序列模型<br>两个字符串的删除操作 - 线性 DP、最长公共子序列模型<br><br>目标和 - 0-1 背包问题<br>数组前面添加+ 或 -， 最后凑出目标的方案数<br>方法1：dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>  前i个数凑出j-1000的方案个数<br>init: dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1000]</span> = 1; return dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[target+1000]</span>;<br>方法2：负号和为x。sum - 2x = target。 数组中凑出(sum-target)/2的方案数<br>   dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> 前i个数和为j的方案数(可以不选) <br>    init: dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 1;  return dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[target]</span><br>方案3：dfs暴力 2^n^   <br><br>   <br>分割等和子集 - 0-1 背包问题  是否存在使得划分两个集合sum相等  计算方案会溢出<br><br>最后一块石头的重量 II - 0-1 背包问题  分成两堆 sum差值最小<br><br>零钱兑换 - 完全背包问题 给出零钱面值数组(可重复)，凑出target的最小数量<br>1.完全背包 f<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> 前i种零钱凑出j<br>2.普通背包问题 f<span class="hljs-comment">[i]</span> 凑出i的硬币数量。从n种状态种选出最优<br>3.记忆化搜索 从上到下 定义什么时候终止 什么状态为求出来了 求出来中什么状态无解<br><br>组合总和 Ⅳ - 完全背包问题  数组中凑出target方案数  不考虑顺序是完全背包  考虑为f<span class="hljs-comment">[i]</span>凑出i的方案数<br><br><br>从栈中取出 K 个硬币的最大面值和 - 分组背包问题<br><br>数字 1 的个数 - 数位 DP、记忆化搜索<br><br>统计各位数字都不同的数字个数 - 数位 DP、记忆化搜索、状态压缩<br><br>不含连续 1 的非负整数 - 数位 DP、记忆化搜索<br><br>旋转数字 - 数位 DP、记忆化搜索<br>最大为 N 的数字组合 - 数位 DP、记忆化搜索<br>统计特殊整数 - 数位 DP、记忆化搜索<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a>:  子数组的乘积最大   存在正负</p><h2 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="非递归快排"><a href="#非递归快排" class="headerlink" title="非递归快排"></a>非递归快排</h4><p>用栈模拟递归保存排序区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort_no_Recursion</span><span class="hljs-params">(<span class="hljs-type">int</span>[] q)</span>&#123;<br>        ArrayDeque&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        st.push(<span class="hljs-number">0</span>);<br>        st.push(q.length-<span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-type">int</span> l, r, x, i, j;<br>        <span class="hljs-keyword">while</span>(st.size() != <span class="hljs-number">0</span>)&#123;<br>            <br>            r = st.pop();<br>            l = st.pop();<br>            <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">continue</span>;<br>            <br>            x = q[(l + r) &gt;&gt; <span class="hljs-number">1</span>];<br>        <br>            i = l-<span class="hljs-number">1</span>; j = r+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>                i++; <span class="hljs-keyword">while</span>(q[i] &lt; x) i++;<br>                j--; <span class="hljs-keyword">while</span>(q[j] &gt; x) j--;<br>                <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q[i];<br>                    q[i] = q[j];<br>                    q[j] = t;<br>                &#125;<br>            &#125;<br>            <br>            st.push(l);<br>            st.push(j);<br>            <br>            st.push(j+<span class="hljs-number">1</span>);<br>            st.push(r);<br>            <br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><code>stringbuilder</code>删除的时候，从后往前删防止影响，传入整数自动转为字符串</p><p><code>new Integer(&#39;0&#39;)</code>  得到的是ASCII， char可以自动转integer，反过来不行 <code>new Character((char) 48)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccess</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-built_in">this</span>.file, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[pageSize];<br>randomAccess.seek(pageSize * pageNumber);<br>randomAccess.read(buffer);<br><br><br>数组    .length  <br>String  .length()<br>List    .size()<br><br><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][]; <span class="hljs-comment">// 3行的二维数组，但每行的列数不定  内存不连续</span><br><br><br>Arrays:<br>    sort(a);     <span class="hljs-comment">// 对于非基本类 第二个参数可以传入比较方法，见 后面</span><br>binarySearch(a, key);<br>fill(a, value);<br>a2 = copyOf(a1, a1.length);<br>toString() <span class="hljs-comment">// 打印</span><br>        <br>Arrays.stream(a).sum();<br>Arrays.stream(a).max().getAsInt();<br><br>object[]转List： <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(ints))<br>        反过来 ints = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][]) <span class="hljs-comment">//这里是二维的 list中存放 &lt;int[]&gt; 带参方法</span><br><span class="hljs-type">int</span>[] 转List ：  Arrays.stream(a).boxed().collect(Collectors.toList());    <span class="hljs-comment">//需要装箱</span><br><br>隐式强转可以小转大，大转小需要显式并且不能溢出<br><br>    <br>java 包含声明和创建<br>    变量的声明通常在栈内存中完成<br>    创建通常为<span class="hljs-keyword">new</span>在堆中完成，返回堆内存地址<br>    <br>Object[] arr:申明数组类型变量时，为其分配了（<span class="hljs-number">32</span>位）引用空间 栈中，由于未赋值，因此并不指向任何对象<br>    <br>arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>]  堆中创建一个长度为<span class="hljs-number">10</span>的Object 类型数组对象(也是对象)，分配了<span class="hljs-number">10</span>个连续的内存空间，各自占用（<span class="hljs-number">32</span>位的）Object用空间，但现在默认指向<span class="hljs-literal">null</span><br>    <br>arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() 在堆中为 Object 类型的对象分配一段内存空间，将引用存储在arr[i]<br></code></pre></td></tr></table></figure><p>重写排序，<code>Array.sorts(a)</code> 排序数组同理。注意int不能重写，需要逆序就先排序再反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList：<br>    方法一：直接传一个函数，原理还是下面 FunctionalInterface<br>        nums.sort( (x, y) -&gt; x - y ); <span class="hljs-comment">// integer</span><br>            nums.sort(persons, (p1, p2) -&gt; p2.getAge() - p1.getAge());  <span class="hljs-comment">// 方便 </span><br>   nums.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 数组</span><br>方法二：传一个Comparator类对象，比较时调用Comparator.compare<br>            nums.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>                    <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>                &#125;<br>            &#125;)<br>    方法三：类重写接口方法<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;MyClass&gt;&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyClass other)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-built_in">this</span>.priority, other.priority);<br>            &#125;<br>&#125;<br><br><br><br>或者对于List<br>Collections.sort(nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>    &#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">栈 底层数组，适合两端插入删除；LinkedList是链表<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();  或 Stack<br>.isEmpty() .peek() .pop() .push(num)<br><br>队列  在栈中pop push都是从First操作，因此我代码也在first加入，但严格来说队列是队尾插入<br>.addFirst  .addLast<br>.peekFirst .peekLast<br>.pollFirst .pollLast<br>    <br>    <br>优先队列 PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(); <span class="hljs-comment">// 自己的类同sort方法 </span><br><span class="hljs-comment">// (a, b) -&gt; a.getValue() - b.getValue() 小根堆</span><br>pq.offer(<span class="hljs-number">3</span>);<br> pq.peek();<br>pq.poll();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">console</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(T... input)</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (T i: input) &#123;<br>            sb.append(i.toString());<br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        System.out.println(sb.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="randomfile"><a href="#randomfile" class="headerlink" title="randomfile"></a>randomfile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">randomAccess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(filepath, <span class="hljs-string">&quot;rw&quot;</span>);<br><span class="hljs-type">byte</span>[] buffer = ...<br>randomAccess.seek(pageSize * pageNumber);<br>randomAccess.write(buffer);<br><br>randomAccess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(filepath, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[pageSize]<br>randomAccess.seek(pageSize * pageNumber);<br>randomAccess.read(buffer);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapPage</span>((HeapPageId) pid, buffer);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图网络入门</title>
    <link href="/2023/05/26/GNN-base/"/>
    <url>/2023/05/26/GNN-base/</url>
    
    <content type="html"><![CDATA[<p><a href="https://distill.pub/2021/gnn-intro/">https://distill.pub/2021/gnn-intro/</a></p><ul><li>图的矩阵表示<ul><li>邻接矩阵</li><li>邻接表：稀疏性</li></ul></li><li>聚合操作：实现层间的信息传递<ul><li>层内：池化</li><li>层间：GCN邻域聚合、考虑邻接节点的权重（attention）  先采样再聚合</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056327.png" alt="image-20230524214233460"></p><p>什么数据会用图表示  图数据有什么特点区别，构建一个GNN，提供一个GNN playground</p><h3 id="图表示"><a href="#图表示" class="headerlink" title="图表示"></a>图表示</h3><p>顶点、边、全局  用向量来表示。内部有信息，通过向量存储</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056329.png" alt="image-20230524214810624"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056330.png" alt="image-20230524215123040"></p><h3 id="什么能被表示为图"><a href="#什么能被表示为图" class="headerlink" title="什么能被表示为图"></a>什么能被表示为图</h3><p><strong>图片表示为图</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056331.png" alt="image-20230524215156969"></p><p><strong>文本</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056332.png" alt="image-20230524215642756"></p><p><strong>分子 Molecules</strong> </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056333.png" alt="image-20230525095851988"></p><p><strong>社交关系图</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056334.png" alt="image-20230524215744881"></p><h3 id="引出什么问题"><a href="#引出什么问题" class="headerlink" title="引出什么问题"></a>引出什么问题</h3><p>graph-level, node-level, and edge-level</p><ul><li>对整个图判断：是否有环</li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056335.png" alt="image-20230525100550222" style="zoom:50%;" /><ul><li>对顶点判断：社交网络有两个老师分开了，学生跟随谁</li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056336.png" alt="image-20230525100534543" style="zoom:50%;" /><ul><li>对边判断：顶点是图中的物体，判断物体和物体间关系</li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056337.png" alt="image-20230525100522460" style="zoom:50%;" /><h3 id="represent-graphs"><a href="#represent-graphs" class="headerlink" title="represent graphs"></a>represent graphs</h3><ul><li><strong>顶点 边 全局信息</strong>：直接用向量，比较简单</li><li><strong>连接信息</strong>：邻接矩阵，比较大浪费空间、同一图交换两行会影响矩阵形状；邻接表</li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056338.png" alt="image-20230524220829767" style="zoom:67%;" /><p>这里用标量表示的，可替换向量</p><h3 id="GNN："><a href="#GNN：" class="headerlink" title="GNN："></a>GNN：</h3><p><strong>Define</strong>：对顶点、边、全局进行变换，变换满足置换不变性。输入输出都是图，对顶点、边进行变化但不改变连接性</p><p>message passing neural network</p><p>通过MLP更新顶点向量，最后对单个顶点的向量就可以通过softmax分类</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056339.png" alt="image-20230524221712195"></p><h4 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h4><p>可能点没有信息，但边有，在最后一层pool。pool: 边-&gt;点   。同理可以点到边</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056340.png"></p><h4 id="Passing-messages"><a href="#Passing-messages" class="headerlink" title="Passing messages"></a>Passing messages</h4><p>问题：我们没有使用图的信息(除了最后一次)，顶点和哪些边相连的。我想在GNN层中使用池化来做出更复杂的预测</p><h5 id="点-点-或-边-边"><a href="#点-点-或-边-边" class="headerlink" title="点-点 或 边-边"></a>点-点 或 边-边</h5><p>消息传递：进入mlp前，当前顶点会加上所有相邻的点，如果很多层就可以看到全局的点，如第一张图所示（像感受野）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056341.png" alt="image-20230524222021997"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056342.png" alt="image-20230525094552106"></p><h5 id="点-边"><a href="#点-边" class="headerlink" title="点-边"></a>点-边</h5><p>顶点信息给边，再给边信息给点（相加、concat）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056343.png" alt="image-20230524222504445"></p><h5 id="全局信息"><a href="#全局信息" class="headerlink" title="全局信息"></a>全局信息</h5><p>解决很远的节点间的消息传递问题</p><p>master node：<strong>和所有点和边相连</strong> 包含全局信息，更新时需要点边信息，点边更新时会额外加入全局</p><p>先更E(包含V，U)，再更新点（包含E，U），最后更新U（包含V，E）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056344.png" alt="image-20230524224543319"></p><h3 id="PlayGround"><a href="#PlayGround" class="headerlink" title="PlayGround"></a>PlayGround</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056345.png" alt="image-20230525104435625"></p><p><strong>hyperparameters</strong>：</p><ul><li><p>Style of message passing   明显全部消息传递效果最优</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056347.png" alt="image-20230525104737176"></p></li><li><p>the dimensionality of embeddings</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056348.png" alt="image-20230525104343737"></p></li><li><p>number of layers</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056349.png" alt="image-20230525104804863"></p></li><li><p>aggregation operation type</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056350.png" alt="image-20230525104615998"></p></li></ul><h3 id="Into-the-Weeds"><a href="#Into-the-Weeds" class="headerlink" title="Into the Weeds"></a>Into the Weeds</h3><h4 id="Other-types-of-graphs"><a href="#Other-types-of-graphs" class="headerlink" title="**Other types of graphs **"></a>**Other types of graphs **</h4><p><strong>(multigraphs, hypergraphs, hypernodes, hierarchical graphs)</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056351.png" alt="image-20230525110752250"></p><h4 id="Sampling-Graphs-and-Batching"><a href="#Sampling-Graphs-and-Batching" class="headerlink" title="Sampling Graphs and Batching"></a><strong>Sampling Graphs and Batching</strong></h4><p>随机子图，随机游走多少步，随机游走再加邻居，单点BFS多少步</p><h4 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a><strong>GCN</strong></h4><p><code>GCNConv</code> 是 PyTorch Geometric 中实现 GCN 的模块，它的内部实现如下：<code>GCNConv(x, edge_index)</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056352.png" alt="image-20230525213032091"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GCN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_dim, hidden_dim, output_dim</span>):<br>        <span class="hljs-built_in">super</span>(GCN, self).__init__()<br>        self.fc1 = nn.Linear(input_dim, hidden_dim)<br>        self.fc2 = nn.Linear(hidden_dim, output_dim)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, adj</span>):<br>        <span class="hljs-comment"># 计算规范化的邻接矩阵</span><br>        adj = adj + torch.eye(adj.size(<span class="hljs-number">0</span>))  <span class="hljs-comment"># 加上自环</span><br>        degree = torch.<span class="hljs-built_in">sum</span>(adj, dim=<span class="hljs-number">1</span>)<br>        degree_sqrt = torch.sqrt(degree)<br>        adj_normalized = adj / degree_sqrt.unsqueeze(<span class="hljs-number">1</span>) / degree_sqrt.unsqueeze(<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 计算GCN层的输出</span><br>        x = self.fc1(adj_normalized @ x)<br>        x = torch.relu(x)<br>        x = self.fc2(adj_normalized @ x)<br><br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># 定义输入数据和邻接矩阵</span><br>x = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 10个节点，每个节点5维特征</span><br>adj = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># 10个节点的邻接矩阵</span><br><br><span class="hljs-comment"># 创建GCN网络实例</span><br>gcn = GCN(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 输入特征维度为5，隐藏层维度为10，输出维度为2</span><br><br><span class="hljs-comment"># 计算GCN的输出</span><br>output = gcn(x, adj)<br><br><span class="hljs-comment"># 定义损失函数和优化器</span><br>criterion = nn.CrossEntropyLoss()<br>optimizer = torch.optim.Adam(gcn.parameters(), lr=<span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment"># 训练GCN网络</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    optimizer.zero_grad()<br>    output = gcn(x, adj)<br>    loss = criterion(output, torch.tensor([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]))  <span class="hljs-comment"># 10个节点分为两类</span><br>    loss.backward()<br>    optimizer.step()<br><br></code></pre></td></tr></table></figure><h4 id="Graph-Attention-Networks"><a href="#Graph-Attention-Networks" class="headerlink" title="Graph Attention Networks"></a><strong>Graph Attention Networks</strong></h4><p>当我们考虑一个节点及其1度相邻节点的和聚合时，我们也可以考虑使用加权和</p><p>常用的评分函数是<strong>内积</strong>，评分前常通过<strong>线性映射</strong>将节点转换为查询和关键向量，以提高评分机制的表现力。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056353.png" alt="image-20230525111909292"></p><p>a(l)代表着注意力分数向量；W(l)是对当前层特征做一个映射，相当于一个MLP</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056354.png" alt="image-20230525122735492"></p>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
      <category>GNN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手学深度学习NLP</title>
    <link href="/2023/05/23/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0NLP/"/>
    <url>/2023/05/23/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0NLP/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html">https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html</a></p><p><a href="https://course.d2l.ai/zh-v2/">课程安排 - 动手学深度学习课程 (d2l.ai)</a></p><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><h3 id="时序模型"><a href="#时序模型" class="headerlink" title="时序模型"></a>时序模型</h3><p>当前数据与之前数据相关</p><p>音乐、语言、文本</p><p>与前面所有有关：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100600.png" alt="image-20230515113440168"></p><p>对过去的数据建模，然后预测自己：<strong>自回归模型</strong></p><p>A：<strong>马可夫模型</strong>：当前数据只与最近数据相关；用函数前4个值作为特征，预测下一个值，2层MLP</p><p><code>nn.Sequential(nn.Linear(4, 10),nn.ReLU(),nn.Linear(10, 1))</code></p><p>紫线为单步预测，绿线为长步预测</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100601.png" alt="image-20230515115303920"></p><p>B：<strong>潜变量</strong>：引入潜变量，来概括历史信息  RNN  两个模型，（在实际训练中，还是切成了一段段step，实际可以理解为暗含隐马可夫step）</p><p>​ot利用ht输出（ht由 xt-1 和 ht-1 求出，保存<strong>历史信息</strong>），来推测xt</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100602.png" alt="image-20210818124506982" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100603.png" alt="image-20210818124810932" style="zoom:67%;" /><p>QA：</p><ol><li>RNN甚至可以用来排序？因为可用记住</li><li>数据到底和多长的前面的数据相关呢？transformer自动探索多少个</li><li>传感器、电池故障预测。单步多步不是重点，关键在于负样本数量</li><li>序列也是一维数据，可用用CNN做分类吗？ 可以用1维卷积，效果不错的</li></ol><p>Vocab</p><p>tokenize：将文章按<strong>词</strong>或<strong>字母</strong>划分，如果是词中文需要分词</p><p>Vocab：文本词汇表，可以按单词分也可以按字母分，将单词映射为index。  按频率排序，方便观察、常用数据内存在一起</p><h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><p>估计联合概率p(x1 x2 xT)，序列出现的概率</p><ul><li>做预序列模型 BERT GPT-3</li><li>文本生成</li><li>判断序列更常见      语音识别哪个更正常  打字</li></ul><p>使用计数建模：判断文本出现的概率</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100604.png" alt="image-20210817212714212"></p><p>n元语法：一个单词出现的概率与它前面的n-1个单词有关。n-1阶段马可夫模型</p><p>二元词汇：两个词合起来算一个token</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 扫一边，长度还是为n，但重复的会减少，种类会增加</span><br>bigram_tokens = [pair <span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(corpus[:-<span class="hljs-number">1</span>], corpus[<span class="hljs-number">1</span>:])]<br>trigram_tokens = [triple <span class="hljs-keyword">for</span> triple <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>    corpus[:-<span class="hljs-number">2</span>], corpus[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>], corpus[<span class="hljs-number">2</span>:])]<br>[((<span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;traveller&#x27;</span>), <span class="hljs-number">59</span>),<br> ((<span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;machine&#x27;</span>), <span class="hljs-number">30</span>),]<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100605.png" alt="image-20210817221810317" style="zoom: 67%;" /><h4 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h4><p>将corpus 转为 batchsize，单个长度为num_step</p><p>1.batch间随机；随机起始点，每个单词每次只用一次</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100606.png" alt="image-20230515160816014"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-number">2</span>， step = <span class="hljs-number">5</span><br>X:  tensor([[<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],<br>        [ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]) <br>Y: tensor([[<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>],<br>        [ <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<br>X:  tensor([[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],<br>        [<span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>]]) <br>Y: tensor([[ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],<br></code></pre></td></tr></table></figure><p>2.batch间连续</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">X:  tensor([[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>],<br>        [<span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]]) <br>Y: tensor([[ <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],<br>        [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>]])<br>X:  tensor([[ <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>],<br>        [<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>]]) <br>Y: tensor([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>],<br></code></pre></td></tr></table></figure><p>load_data_time_machine: 封装数据并返回vocab</p><p>x &#x3D; [b,t] y&#x3D;[b,t]                                 <strong>特征抽取</strong></p><p><strong>x</strong> -&gt;onehot-&gt;   <strong>[t, b, infeature]</strong>  -&gt;layer-&gt;   <strong>[t, b,  hidden]</strong>  -&gt;linear-&gt;   <strong>[t*b, outfeature]</strong></p><p>​                                                      定义：**[in, hidden]**  state:( layers * direction, batch, hidden，)</p><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><p>任务定义：给定一串字母，生成下一个或者n个</p><p>模型的好坏（<strong>困惑度</strong>）：每一个词都可以看成分类，将每一个词的交叉熵求和求平均。最后做个指数</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100607.png" alt="image-20210818125137879" style="zoom:67%;" /><p>T个时间上的梯度连乘，需要梯度剪裁。但无法处理梯度消失</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100608.png" alt="image-20230515165612896" style="zoom:50%;" /><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100609.png" alt="image-20210818125528564" style="zoom: 50%;" /><p>视频Tracking：不需要用rnn，直接判断bbox帧间周围的情况</p><h4 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h4><p>h是一个hiddens长的特征记录信息，每一个序列x都会更新下一个h，同时该h能够给出一个o输出，代表着预测的输出</p><p>关注h，h是对历史的建模，从h到o只是一个线性回归</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100602.png" alt="image-20210818124506982" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100603.png" alt="image-20210818124810932" style="zoom:67%;" /><p><strong>参数定义：</strong>五个参数，需要梯度。并且需要定义初始化h的函数 ( (b, hiddens),  )</p><p><strong>forward函数：</strong></p><p>序列输入，所以t一定是在最外面。b的作用仅仅是泛化，b之间互不影响。h也是存储了b个</p><ol><li>输入<code>[b,t]</code>和<code>state</code> 转置onehot转为<code>[t, b, onehot]</code> </li><li>按t遍历输入到网络中，每次输出<code>[b onehot]</code>， 并更新t次state</li><li>(和y计算损失函数，预测的下一个字母)</li><li>最后堆叠输出 <code>[t*b, onehot]</code>，<code>new_state</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 传入[t, b, vocab_size]  以及参数、初始状态  返回   [t*b, vocab_size]</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rnn</span>(<span class="hljs-params">inputs, state, params</span>):<br>    <span class="hljs-comment"># `inputs`的形状：(`时间步数量`，`批量大小`，`词表大小`)</span><br>    W_xh, W_hh, b_h, W_hq, b_q = params<br>    H, = state<br>    outputs = []<br>    <span class="hljs-comment"># `X`的形状：(`批量大小`，`词表大小`)</span><br>    <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> inputs:<br>        <span class="hljs-comment"># 一次序列更新一次H，生成一个Y</span><br>        H = torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h)<br>        Y = torch.mm(H, W_hq) + b_q<br>        outputs.append(Y)<br>    <span class="hljs-keyword">return</span> torch.cat(outputs, dim=<span class="hljs-number">0</span>), (H,)<br><br>对于一个 [t, b, vocab_size]， 根据state，每次传入[b, vocab_size]给出[b]个结果预测<br><br><br><span class="hljs-comment"># 网络执行的方式，X传进来后需要onehot</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, X, state</span>):<br>    X = F.one_hot(X.T, self.vocab_size).<span class="hljs-built_in">type</span>(torch.float32)<br>    <span class="hljs-keyword">return</span> self.forward_fn(X, state, self.params)<br></code></pre></td></tr></table></figure><p><strong>剪裁 ：</strong>梯度二范数 torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params)) &lt;  θ  </p><p><strong>预测</strong>： 用预先给的词初始化h，并不断forward给输出并更新state</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据h和上一个x来预测下一个值x，并更新h</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_ch8</span>(<span class="hljs-params">prefix, num_preds, net, vocab, device</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;在`prefix`后面生成新字符。&quot;&quot;&quot;</span><br>    state = net.begin_state(batch_size=<span class="hljs-number">1</span>, device=device)<br>    outputs = [vocab[prefix[<span class="hljs-number">0</span>]]]<br>    get_input = <span class="hljs-keyword">lambda</span>: torch.tensor([outputs[-<span class="hljs-number">1</span>]], device=device).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    <span class="hljs-comment"># 根据input，更新state</span><br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> prefix[<span class="hljs-number">1</span>:]:  <span class="hljs-comment"># 预热期</span><br>        _, state = net(get_input(), state)<br>        outputs.append(vocab[y])<br>        <br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_preds):  <span class="hljs-comment"># 预测`num_preds`步</span><br>        y, state = net(get_input(), state)<br>        outputs.append(<span class="hljs-built_in">int</span>(y.argmax(dim=<span class="hljs-number">1</span>).reshape(<span class="hljs-number">1</span>)))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([vocab.idx_to_token[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> outputs])<br></code></pre></td></tr></table></figure><p><strong>训练：</strong>一个epoch中，注意batch间如果打乱了的化，state要重新初始化。否者沿用之前的，并且需要<strong>detach_()</strong></p><p><strong>损失函数：</strong>直接CrossEntropy 注意更新前先剪裁梯度。y是[b, t] 传入前先转置一下</p><h4 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h4><p>核心：通过保存state信息，对t个features编码，转为t个num_hiddens</p><p>RNN的定义是没有b的，只需要features num_hiddens，但state有b且多了个1维度</p><p>RNN实际上就是对输入的t个时间序列，进行建模处理，并返回hidden维度信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入维度，隐藏层维度</span><br>rnn_layer = nn.RNN(features, num_hiddens)<br><span class="hljs-comment">#传入数据也是onehot后的， 输出没有输出层，加一层linear, state需要自己传入，</span><br><br><span class="hljs-comment"># X：[t, b, features]    </span><br><span class="hljs-comment"># state： [1, b, num_hiddens]</span><br>Y,   state            = rnn_layer (X ,             state )<br><span class="hljs-comment"># Y [t, b, num_hiddens]   t次最后一个layer的H的cat</span><br><span class="hljs-comment"># state_new [1, b, num_hiddens]  用于传入下一次  1为num_layer</span><br><br><span class="hljs-comment"># 所以网络的输出是t个时间段全部的（num_layer[-1].state值cat，最后一个state）   Y[-1] == state_new </span><br></code></pre></td></tr></table></figure><p>输入数据中的t代表着输入数据的时序长度，很像t次MLP分类，但是前面的数据会影响state从而影响后面的分类</p><p>为什么没有out层？输出不一定要和输入的维度一样，比如我可以只去做一个情感分类，或者只想提取特征。如果想分类，直接输入到全连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Y, state = self.rnn(X, state)<br><span class="hljs-comment"># 全连接层首先将`Y`的形状改为(num_steps * b, `隐藏单元数`)。</span><br>output = self.linear(Y.reshape((-<span class="hljs-number">1</span>, Y.shape[-<span class="hljs-number">1</span>])))<br></code></pre></td></tr></table></figure><h4 id="QA："><a href="#QA：" class="headerlink" title="QA："></a>QA：</h4><ol><li><p>处理视频时序序列，t就是想要关联的帧长度，而onehot则改成了由神经网络抽取出来单帧图片的特征。所以[t,features]输入到rnn后，rnn返回给你[t,features’ ] ，根据这个提取出信息</p></li><li><p>如果用<strong>单词作为预测目标</strong>，<code>onehot</code>将会非常长。不利于预测</p></li><li><p>RNN不能处理长序列：<code>num_hiddens</code>决定着你记录<strong>之前的状态</strong>。但太大会过拟合，太小会无法记录下之前的消息</p></li><li><p>高频词可以对概率开根号，或者随机去除</p></li></ol><h3 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h3><p>添加两个门，<strong>更好的保留以前的信息</strong>：如一群老鼠突然出现一直猫，注意点要转移到猫上。（0~1取值，按位乘）</p><p><strong>遗忘门R：</strong>计算h<del>t</del>时，h<del>t-1</del>h忘记多少    <strong>更新门Z</strong>：h<del>t</del>和现在h<del>t-1</del>所占的比例</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100610.png" alt="image-20210819132116519" style="zoom: 67%;" /><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>获取参数</strong> ：11个  <code>W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q</code></p><p><strong>forward函数</strong>：按照公式写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gru</span>(<span class="hljs-params">inputs, state, params</span>):<br>    W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q = params<br>    H, = state<br>    outputs = []<br>    <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> inputs:<br>        Z = torch.sigmoid((X @ W_xz) + (H @ W_hz) + b_z)<br>        R = torch.sigmoid((X @ W_xr) + (H @ W_hr) + b_r)<br>        H_tilda = torch.tanh((X @ W_xh) + ((R * H) @ W_hh) + b_h)<br>        H = Z * H + (<span class="hljs-number">1</span> - Z) * H_tilda<br>        Y = H @ W_hq + b_q<br>        outputs.append(Y)<br>    <span class="hljs-keyword">return</span> torch.cat(outputs, dim=<span class="hljs-number">0</span>), (H,)<br></code></pre></td></tr></table></figure><p>和前面一样封装到类中，需要传入infeature hidden  <code>get_param</code>  <code>init_state</code>  <code>forward</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = d2l.RNNModelScratch(<span class="hljs-built_in">len</span>(vocab), num_hiddens, device, get_params,<br>                            init_gru_state, gru)<br>d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)<br></code></pre></td></tr></table></figure><h4 id="简洁："><a href="#简洁：" class="headerlink" title="简洁："></a>简洁：</h4><p>封装到RNNModel中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">gru_layer = nn.GRU(num_inputs, num_hiddens)<br>model = d2l.RNNModel(gru_layer, <span class="hljs-built_in">len</span>(vocab))<br><span class="hljs-comment"># state依然是(1, b, num_hiddens)</span><br><span class="hljs-comment"># nn.GRU输入为[t,b,in] 输出为[t,b,hi],[1,b,hi]</span><br></code></pre></td></tr></table></figure><p>对比GRU，虽然计算复杂了，但运算速度反而更快了 242822.8  -&gt;  26820.1   tokens&#x2F;sec</p><h4 id="QA"><a href="#QA" class="headerlink" title="QA:"></a>QA:</h4><ol><li>GRU LSTM参数更多，但稳定性比RNN更好</li><li>尽量不要使用RNN</li></ol><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><p>两个state ：C、H</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100611.png" alt="image-20210819142947789" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100612.png" alt="image-20210819143001209" style="zoom:50%;" /></p><p>F （忘记门） 和 I （输入门）决定以前C和现在C~所占比例，O（输出门）决定C求出来后如何向H转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens)<br><span class="hljs-comment"># state: ([1, b, num_hiddens],[1, b, num_hiddens])   H C</span><br><br>Y, state_new = lstm_layer(X, state)<br><span class="hljs-comment"># Y [t, b, num_hiddens])   最后一个H的集合</span><br><span class="hljs-comment"># state_new ([1, b, num_hiddens],[1, b, num_hiddens])  用于传入下一次  1为num_layer</span><br></code></pre></td></tr></table></figure><p>实际内存难以计算，cudnn会用内存换速度，直接跑来看占用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RNNModel</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;The RNN model.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Defined in :numref:`sec_rnn-concise`&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, rnn_layer, vocab_size, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(RNNModel, self).__init__(**kwargs)<br>        self.rnn = rnn_layer<br>        self.vocab_size = vocab_size<br>        self.num_hiddens = self.rnn.hidden_size<br>        <span class="hljs-comment"># If the RNN is bidirectional (to be introduced later),</span><br>        <span class="hljs-comment"># `num_directions` should be 2, else it should be 1.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.rnn.bidirectional:<br>            self.num_directions = <span class="hljs-number">1</span><br>            self.linear = nn.Linear(self.num_hiddens, self.vocab_size)<br>        <span class="hljs-keyword">else</span>:<br>            self.num_directions = <span class="hljs-number">2</span><br>            self.linear = nn.Linear(self.num_hiddens * <span class="hljs-number">2</span>, self.vocab_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs, state</span>):<br>        X = F.one_hot(inputs.T.long(), self.vocab_size)<br>        X = X.to(torch.float32)<br>        Y, state = self.rnn(X, state)<br>        <span class="hljs-comment"># The fully connected layer will first change the shape of `Y` to</span><br>        <span class="hljs-comment"># (`num_steps` * `batch_size`, `num_hiddens`). Its output shape is</span><br>        <span class="hljs-comment"># (`num_steps` * `batch_size`, `vocab_size`).</span><br>        output = self.linear(Y.reshape((-<span class="hljs-number">1</span>, Y.shape[-<span class="hljs-number">1</span>])))<br>        <span class="hljs-keyword">return</span> output, state<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">begin_state</span>(<span class="hljs-params">self, device, batch_size=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(self.rnn, nn.LSTM):<br>            <span class="hljs-comment"># `nn.GRU` takes a tensor as hidden state</span><br>            <span class="hljs-keyword">return</span>  torch.zeros((self.num_directions * self.rnn.num_layers,<br>                                 batch_size, self.num_hiddens),<br>                                device=device)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># `nn.LSTM` takes a tuple of hidden states</span><br>            <span class="hljs-keyword">return</span> (torch.zeros((<br>                self.num_directions * self.rnn.num_layers,<br>                batch_size, self.num_hiddens), device=device),<br>                    torch.zeros((<br>                        self.num_directions * self.rnn.num_layers,<br>                        batch_size, self.num_hiddens), device=device))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_epoch_ch8</span>(<span class="hljs-params">net, train_iter, loss, updater, device, use_random_iter</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Train a net within one epoch (defined in Chapter 8).</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Defined in :numref:`sec_rnn_scratch`&quot;&quot;&quot;</span><br>    state, timer = <span class="hljs-literal">None</span>, d2l.Timer()<br>    metric = d2l.Accumulator(<span class="hljs-number">2</span>)  <span class="hljs-comment"># Sum of training loss, no. of tokens</span><br>    <span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> train_iter:<br>        <span class="hljs-keyword">if</span> state <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> use_random_iter:<br>            <span class="hljs-comment"># Initialize `state` when either it is the first iteration or</span><br>            <span class="hljs-comment"># using random sampling</span><br>            state = net.begin_state(batch_size=X.shape[<span class="hljs-number">0</span>], device=device)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(net, nn.Module) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(state, <span class="hljs-built_in">tuple</span>):<br>                <span class="hljs-comment"># `state` is a tensor for `nn.GRU`</span><br>                state.detach_()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># `state` is a tuple of tensors for `nn.LSTM` and</span><br>                <span class="hljs-comment"># for our custom scratch implementation</span><br>                <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> state:<br>                    s.detach_()<br>        y = Y.T.reshape(-<span class="hljs-number">1</span>)<br>        X, y = X.to(device), y.to(device)<br>        y_hat, state = net(X, state)<br>        l = loss(y_hat, y.long()).mean()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(updater, torch.optim.Optimizer):<br>            updater.zero_grad()<br>            l.backward()<br>            grad_clipping(net, <span class="hljs-number">1</span>)<br>            updater.step()<br>        <span class="hljs-keyword">else</span>:<br>            l.backward()<br>            grad_clipping(net, <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># Since the `mean` function has been invoked</span><br>            updater(batch_size=<span class="hljs-number">1</span>)<br>        metric.add(l * d2l.size(y), d2l.size(y))<br>    <span class="hljs-keyword">return</span> math.exp(metric[<span class="hljs-number">0</span>] / metric[<span class="hljs-number">1</span>]), metric[<span class="hljs-number">1</span>] / timer.stop()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers)<br>model = d2l.RNNModel(lstm_layer, <span class="hljs-built_in">len</span>(vocab))<br><br>d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)<br></code></pre></td></tr></table></figure><h3 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h3><p>多个隐藏层获得非线性性</p><p>​                             <img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100613.png" alt="image-20210819150224101" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100614.png" alt="image-20230516144012521" style="zoom:50%;" /></p><p>在同一个时刻，保存多个<code>Ht</code>  ,由左下角推理而来</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100615.png" alt="image-20210819150931603"></p><p>state: ([1, b, num_hiddens],[1, b, num_hiddens])  -&gt;([2, b, num_hiddens],[2, b, num_hiddens])   两层够了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens，num_layer)  num_layer决定H个数<br></code></pre></td></tr></table></figure><h3 id="双向"><a href="#双向" class="headerlink" title="双向"></a>双向</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100616.png" alt="image-20230516145522237"></p><p>两个H，一个依赖以前的，一个依赖以后的。相互独立，cat在一起决定输出</p><p>抽取特征，分类，填空、翻译。但不能预测未来，因为反方向不存在</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100617.png" alt="image-20210819160940494" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100618.png" alt="image-20210819161400150" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100619.png" alt="image-20210819161423155" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens，num_layer, bidirectional=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>对句子做特征提取：做翻译、改写，不能做预测，因为完全没有反方向的信息</p><h3 id="机器翻译数据集"><a href="#机器翻译数据集" class="headerlink" title="机器翻译数据集"></a>机器翻译数据集</h3><ul><li><p>读入数据，预处理去除大写、特殊字符。</p></li><li><p>单词化后，英语，法语分别绘制vocab，加入一些特殊字符</p></li><li><p>结尾补上vocab[‘<eos>‘], 批量计算，每一个句子长度要想同，所以限制最大长度，不足补vocab[‘<pad>‘] 转idx</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_array_nmt</span>(<span class="hljs-params">lines, vocab, num_steps</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;将机器翻译的文本序列转换成小批量&quot;&quot;&quot;</span><br>    lines = [vocab[l] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lines]<br>    lines = [l + [vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lines]<br>    array = torch.tensor([truncate_pad(<br>        l, num_steps, vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>]) <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lines])<br>    valid_len = (array != vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>]).<span class="hljs-built_in">type</span>(torch.int32).<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> array, valid_len<br></code></pre></td></tr></table></figure></li><li><p>封装成batch，每次返回 <code>X, X_valid_len, Y, Y_valid_len</code>.   len为实际句子长度</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data_nmt</span>(<span class="hljs-params">batch_size, num_steps, num_examples=<span class="hljs-number">600</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回翻译数据集的迭代器和词表&quot;&quot;&quot;</span><br>    text = preprocess_nmt(read_data_nmt())<br>    source, target = tokenize_nmt(text, num_examples)<br>    src_vocab = d2l.Vocab(source, min_freq=<span class="hljs-number">2</span>,<br>                          reserved_tokens=[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>])<br>    tgt_vocab = d2l.Vocab(target, min_freq=<span class="hljs-number">2</span>,<br>                          reserved_tokens=[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>])<br>    src_array, src_valid_len = build_array_nmt(source, src_vocab, num_steps)<br>    tgt_array, tgt_valid_len = build_array_nmt(target, tgt_vocab, num_steps)<br>    data_arrays = (src_array, src_valid_len, tgt_array, tgt_valid_len)<br>    data_iter = d2l.load_array(data_arrays, batch_size)<br>    <span class="hljs-keyword">return</span> data_iter, src_vocab, tgt_vocab<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> X, X_valid_len, Y, Y_valid_len <span class="hljs-keyword">in</span> train_iter:<br>X: tensor([[<span class="hljs-number">93</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">13</span>, <span class="hljs-number">34</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>]])<br>valid lengths <span class="hljs-keyword">for</span> X: tensor([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br><br>Y: tensor([[  <span class="hljs-number">0</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">105</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">121</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>]], dtype=torch.int32)<br>valid lengths <span class="hljs-keyword">for</span> Y: tensor([<span class="hljs-number">6</span>, <span class="hljs-number">3</span>])<br>    <br>b=<span class="hljs-number">2</span>，每个句子最大长度num_steps=<span class="hljs-number">8</span>    输入为一个句子，输出也为一个句子<br>不同于文本生成：序列中每一个输入都有一个输出<br>机器翻译为一整个序列输入：对应一整个序列输出<br></code></pre></td></tr></table></figure><h3 id="Encoder-Decoder"><a href="#Encoder-Decoder" class="headerlink" title="Encoder-Decoder"></a>Encoder-Decoder</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100620.png" alt="image-20210819171331079" style="zoom:80%;" /><p>encoder最后的隐藏状态作为decoder的输入，decoder还可以有额外输入。decoder时，由于不知道后面的信息，所以需要一个一个输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderDecoder</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;编码器-解码器架构的基类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, encoder, decoder, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(EncoderDecoder, self).__init__(**kwargs)<br>        self.encoder = encoder<br>        self.decoder = decoder<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, enc_X, dec_X, *args</span>):<br>        enc_outputs = self.encoder(enc_X, *args)<br>        dec_state = self.decoder.init_state(enc_outputs, *args)<br>        <span class="hljs-keyword">return</span> self.decoder(dec_X, dec_state)<br></code></pre></td></tr></table></figure><h3 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h3><p>句子生成句子，使用编码器解码器架构</p><p>编码器用于提取句子(生成context)，解码器输入为</p><ul><li>预测阶段：前一个单词<code>(1,b,h)</code> 和 context的concate</li><li>训练阶段：整个单词序列<code>(t,b,h)</code> 和 context的concate，由于context不变，GRU内部其实也是相对于进行了t次</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100621.png" alt="image-20230516154007581"></p><p>encoder可用<strong>双向</strong>，对输入编码后返回编码器最后的状态，作为decoder输入</p><p>训练时decoder需要右移位一下，每次用的正确的输入（强制教学），推理用的上一次输出</p><h4 id="衡量结果"><a href="#衡量结果" class="headerlink" title="衡量结果"></a>衡量结果</h4><p>如何衡量生成序列的好坏</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100623.png" alt="image-20230516154646648" style="zoom:50%;" /><ol><li>编码器获得state后，把最后一次的state <code>[num_layer, b, num_hiddens]</code> 作为解码器的输入state</li><li>解码器负责将state[-1]重复t次，作为历史状态，并和输入Y<code>[b,t]</code> concat <code>[t, b, emb+hid]</code>传入GRU网络</li><li>GRU将t个state作为dense的输入，输出<code>t * b * vocab</code> permute<code>b * t * vocab</code></li></ol><h4 id="model"><a href="#model" class="headerlink" title="model"></a>model</h4><h5 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">输入 b, t<br>输出 [t, b, hiddens] [numlayer, b, hiddens]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Seq2SeqEncoder</span>(d2l.Encoder):<br>    <span class="hljs-string">&quot;&quot;&quot;用于序列到序列学习的循环神经网络编码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, embed_size, num_hiddens, num_layers,</span><br><span class="hljs-params">                 dropout=<span class="hljs-number">0</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(Seq2SeqEncoder, self).__init__(**kwargs)<br>        <span class="hljs-comment"># 嵌入层</span><br>        self.embedding = nn.Embedding(vocab_size, embed_size)<br>        self.rnn = nn.GRU(embed_size, num_hiddens, num_layers,<br>                          dropout=dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, *args</span>):<br>        <span class="hljs-comment"># 输出&#x27;X&#x27;的形状：(batch_size,num_steps,embed_size)</span><br>        X = self.embedding(X)<br>        <span class="hljs-comment"># 在循环神经网络模型中，第一个轴对应于时间步</span><br>        X = X.permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 如果未提及状态，则默认为0</span><br>        output, state = self.rnn(X)<br>        <span class="hljs-comment"># output的形状:(num_steps,batch_size,num_hiddens)</span><br>        <span class="hljs-comment"># state的形状:(num_layers,batch_size,num_hiddens)</span><br>        <span class="hljs-keyword">return</span> output, state<br></code></pre></td></tr></table></figure><h5 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python">输入 X[b, t]   embedding -&gt;  X[t, b, embed_size]  + cat state[t, b, hiddens] = [t, b, em+hiddens]<br>输出[t, b, hiddens] 经过dense [b, t, vocab_size]  <br>一次性得到t次预测做loss(模型内部还是一个一个词输入并且一个个输出，但由于强制学习强制使用已知的正确的词作为前一个词，就可以一次性全部输入到模型中)<br>    predict时每次输出一个，并作为下一个的输入<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Seq2SeqDecoder</span>(d2l.Decoder):<br>    <span class="hljs-string">&quot;&quot;&quot;用于序列到序列学习的循环神经网络解码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, embed_size, num_hiddens, num_layers,</span><br><span class="hljs-params">                 dropout=<span class="hljs-number">0</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(Seq2SeqDecoder, self).__init__(**kwargs)<br>        self.embedding = nn.Embedding(vocab_size, embed_size)<br>        self.rnn = nn.GRU(embed_size + num_hiddens, num_hiddens, num_layers,<br>                          dropout=dropout)<br>        self.dense = nn.Linear(num_hiddens, vocab_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_state</span>(<span class="hljs-params">self, enc_outputs, *args</span>):<br>        <span class="hljs-keyword">return</span> enc_outputs[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, state</span>):<br>        <span class="hljs-comment"># 输出&#x27;X&#x27;的形状：(num_steps,batch_size,embed_size)</span><br>        X = self.embedding(X).permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 广播context，使其具有与X相同的num_steps</span><br>        context = state[-<span class="hljs-number">1</span>].repeat(X.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        X_and_context = torch.cat((X, context), <span class="hljs-number">2</span>)<br>        output, state = self.rnn(X_and_context, state)<br>        output = self.dense(output).permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># output的形状:(batch_size,num_steps,vocab_size)</span><br>        <span class="hljs-comment"># state的形状:(num_layers,batch_size,num_hiddens)</span><br>        <span class="hljs-keyword">return</span> output, state<br></code></pre></td></tr></table></figure><h4 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要根据实际的长度，超出valid_len部分weights为0从而损失为0, 忽略pad</span><br>X = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]) b, t<br>sequence_mask(X, torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))<br>输出 [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaskedSoftmaxCELoss</span>(nn.CrossEntropyLoss):<br>    <span class="hljs-string">&quot;&quot;&quot;带遮蔽的softmax交叉熵损失函数&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># pred的形状：(batch_size,num_steps,vocab_size)</span><br>    <span class="hljs-comment"># label的形状：(batch_size,num_steps)</span><br>    <span class="hljs-comment"># valid_len的形状：(batch_size,)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, pred, label, valid_len</span>):<br>        weights = torch.ones_like(label)<br>        weights = sequence_mask(weights, valid_len)<br>        self.reduction=<span class="hljs-string">&#x27;none&#x27;</span><br>        unweighted_loss = <span class="hljs-built_in">super</span>(MaskedSoftmaxCELoss, self).forward(<br>            pred.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>), label)<br>        weighted_loss = (unweighted_loss * weights).mean(dim=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> weighted_loss<br></code></pre></td></tr></table></figure><h4 id="train"><a href="#train" class="headerlink" title="train"></a>train</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> data_iter:<br>    optimizer.zero_grad()<br>    X, X_valid_len, Y, Y_valid_len = [x.to(device) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> batch]<br>    bos = torch.tensor([tgt_vocab[<span class="hljs-string">&#x27;&lt;bos&gt;&#x27;</span>]] * Y.shape[<span class="hljs-number">0</span>],<br>                       device=device).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    dec_input = torch.cat([bos, Y[:, :-<span class="hljs-number">1</span>]], <span class="hljs-number">1</span>)  <span class="hljs-comment"># 强制教学 你好啊 -&gt;    &lt;bos&gt;你好</span><br>    Y_hat, _ = net(X, dec_input, X_valid_len) <span class="hljs-comment"># 这里X_valid_len没有用上</span><br>    l = loss(Y_hat, Y, Y_valid_len)<br>    l.<span class="hljs-built_in">sum</span>().backward()<span class="hljs-comment"># 反向传播</span><br>    d2l.grad_clipping(net, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="predict"><a href="#predict" class="headerlink" title="predict"></a>predict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_seq2seq</span>(<span class="hljs-params">net, src_sentence, src_vocab, tgt_vocab, num_steps,</span><br><span class="hljs-params">                    device, save_attention_weights=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;序列到序列模型的预测&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 在预测时将net设置为评估模式</span><br>    net.<span class="hljs-built_in">eval</span>()<br>    src_tokens = src_vocab[src_sentence.lower().split(<span class="hljs-string">&#x27; &#x27;</span>)] + [<br>        src_vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]]<br>    enc_valid_len = torch.tensor([<span class="hljs-built_in">len</span>(src_tokens)], device=device)<br>    src_tokens = d2l.truncate_pad(src_tokens, num_steps, src_vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>])<br>    <span class="hljs-comment"># 添加批量轴</span><br>    enc_X = torch.unsqueeze(<br>        torch.tensor(src_tokens, dtype=torch.long, device=device), dim=<span class="hljs-number">0</span>)<br>    enc_outputs = net.encoder(enc_X, enc_valid_len)<br>    dec_state = net.decoder.init_state(enc_outputs, enc_valid_len)<br>    <span class="hljs-comment"># 添加批量轴</span><br>    dec_X = torch.unsqueeze(torch.tensor(<br>        [tgt_vocab[<span class="hljs-string">&#x27;&lt;bos&gt;&#x27;</span>]], dtype=torch.long, device=device), dim=<span class="hljs-number">0</span>)<br>    output_seq, attention_weight_seq = [], []<br>    <span class="hljs-comment"># 输入dec_X为(1, 1) tb都等于</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_steps):<br>        Y, dec_state = net.decoder(dec_X, dec_state)<br>        <span class="hljs-comment"># 我们使用具有预测最高可能性的词元，作为解码器在下一时间步的输入</span><br>        dec_X = Y.argmax(dim=<span class="hljs-number">2</span>)<br>        pred = dec_X.squeeze(dim=<span class="hljs-number">0</span>).<span class="hljs-built_in">type</span>(torch.int32).item()<br>        <span class="hljs-comment"># 保存注意力权重（稍后讨论）</span><br>        <span class="hljs-keyword">if</span> save_attention_weights:<br>            attention_weight_seq.append(net.decoder.attention_weights)<br>        <span class="hljs-comment"># 一旦序列结束词元被预测，输出序列的生成就完成了</span><br>        <span class="hljs-keyword">if</span> pred == tgt_vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]:<br>            <span class="hljs-keyword">break</span><br>        output_seq.append(pred)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(tgt_vocab.to_tokens(output_seq)), attention_weight_seq<br></code></pre></td></tr></table></figure><h4 id="QA：-1"><a href="#QA：-1" class="headerlink" title="QA："></a>QA：</h4><ol><li>word2vec没讲，跳过了</li><li>transformer可以代替seq2seq</li></ol><h3 id="束搜索"><a href="#束搜索" class="headerlink" title="束搜索"></a>束搜索</h3><p>预测时，每一步都是取最优的（贪心），但贪心不一定是全局最优，例如下面第二步取C</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100624.png" alt="image-20230516202920183"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100625.png" alt="image-20230516202927638"></p><p>穷举：指数级 太大了</p><p>束搜索：每次在所有kn个选项中，保留k个最大的。只保留一个就是贪心</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100626.png" alt="image-20230516203605851" style="zoom:50%;" /><h2 id="注意力"><a href="#注意力" class="headerlink" title="注意力"></a>注意力</h2><h3 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h3><p><code>query</code>：输入   <code>key，value</code>  ：已有的一些数据</p><p>核心：根据<code>query</code>和<code>keyi</code>的关系，决定出<code>valuei</code>的权重，加权得到一个最终value</p><h4 id="核回归"><a href="#核回归" class="headerlink" title="核回归"></a>核回归</h4><h5 id="非参数"><a href="#非参数" class="headerlink" title="非参数"></a>非参数</h5><p>query为输入x，根据数据（(xi,yi)）给出预测y。<code>xi-yi</code>是<code>keys-values</code></p><ol><li>最简单的是对y的数据求平均，这样每个数据给出的f(x)都一样</li><li>根据一个权重，加权求和。权重为根据K(距离)函数求出来的。如果k是高斯核，就等价于用高斯距离<code>softmax</code>加权</li></ol><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100627.png" alt="image-20230517120533488"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100628.png" alt="image-20230517121458578"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># X_repeat的形状:(n_test,n_train),</span><br><span class="hljs-comment"># 每一行都包含着相同的测试输入（例如：同样的查询）</span><br>X_repeat = x_test.repeat_interleave(n_train).reshape((-<span class="hljs-number">1</span>, n_train))<br><span class="hljs-comment"># x_train包含着键。attention_weights的形状：(n_test,n_train),</span><br><span class="hljs-comment"># 每一行都包含着要在给定的每个查询的值（y_train）之间分配的注意力权重</span><br>attention_weights = nn.functional.softmax(-(X_repeat - x_train)**<span class="hljs-number">2</span> / <span class="hljs-number">2</span>, dim=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># y_hat的每个元素都是值的加权平均值，其中的权重是注意力权重</span><br>y_hat = torch.matmul(attention_weights, y_train)<br>plot_kernel_reg(y_hat)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100629.png" alt="image-20230517114942706"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100630.png" alt="image-20230517115633471"></p><p>一行代表，对哪个inpute的权重更大。权重给的比较平滑，所以pred也比较平滑</p><h5 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h5><p>引入可学习的<code>w=nn.Parameter(torch.rand((1,), requires_grad=True))</code>  控制高斯核的窗口大小，w越大窗口越小<br>$$<br>\begin{aligned}f(x) &amp;&#x3D; \sum_{i&#x3D;1}^n \alpha(x, x_i) y_i \&amp;&#x3D; \sum_{i&#x3D;1}^n \frac{\exp\left(-\frac{1}{2}((x - x_i)w)^2\right)}{\sum_{j&#x3D;1}^n \exp\left(-\frac{1}{2}((x - x_j)w)^2\right)} y_i \&amp;&#x3D; \sum_{i&#x3D;1}^n \mathrm{softmax}\left(-\frac{1}{2}((x - x_i)w)^2\right) y_i.\end{aligned}<br>$$<br><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100631.png" alt="image-20230517120017210"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100632.png" alt="image-20230517120026332"></p><p>窗口更窄了，只给离得近的分配权重，所以pred更加弯曲</p><h4 id="注意力分数"><a href="#注意力分数" class="headerlink" title="注意力分数"></a>注意力分数</h4><p>拓展到<strong>高维</strong>情况，q k v都是向量</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100633.png" alt="image-20230517121659643"></p><h5 id="Scaled-Dot"><a href="#Scaled-Dot" class="headerlink" title="Scaled Dot"></a>Scaled Dot</h5><ul><li>k和q长度一样：kq做内积后除去根号dk。transformer。两次矩阵乘法，无学习的参数，去除根号d防止梯度问题</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100634.png" alt="image-20230517122729061"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DotProductAttention</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;Scaled dot product attention.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Defined in :numref:`subsec_additive-attention`&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(DotProductAttention, self).__init__(**kwargs)<br>        self.dropout = nn.Dropout(dropout)<br><br>    <span class="hljs-comment"># Shape of `queries`: (`batch_size`, no. of queries, `d`)</span><br>    <span class="hljs-comment"># Shape of `keys`: (`batch_size`, no. of key-value pairs, `d`)</span><br>    <span class="hljs-comment"># Shape of `values`: (`batch_size`, no. of key-value pairs, value</span><br>    <span class="hljs-comment"># dimension)</span><br>    <span class="hljs-comment"># Shape of `valid_lens`: (`batch_size`,) or (`batch_size`, no. of queries)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, queries, keys, values, valid_lens=<span class="hljs-literal">None</span></span>):<br>        d = queries.shape[-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># Set `transpose_b=True` to swap the last two dimensions of `keys`</span><br>        scores = torch.bmm(queries, keys.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)) / math.sqrt(d)<br>        self.attention_weights = masked_softmax(scores, valid_lens)<br>        <span class="hljs-keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)<br></code></pre></td></tr></table></figure><h5 id="additive"><a href="#additive" class="headerlink" title="additive"></a>additive</h5><ul><li>k和q长度一样：k和q  concat输入到隐藏层为h输出为1的MLP，再乘上vT输出为分数值。有参</li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100635.png" alt="image-20230517122801534" style="zoom:67%;" /><p>对于每一个query，我都需要得到一个<code>len(“键-值”对)</code>的向量，多个query就是一个weight矩阵 <code>[len(query), len(“键-值”对)]</code>，weight*values得到加权输出<code>[querys, d(v)]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br>[querys, d(q)]  -》  [querys, d(v)]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdditiveAttention</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;加性注意力&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, num_hiddens, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(AdditiveAttention, self).__init__(**kwargs)<br>        self.W_k = nn.Linear(key_size, num_hiddens, bias=<span class="hljs-literal">False</span>)<br>        self.W_q = nn.Linear(query_size, num_hiddens, bias=<span class="hljs-literal">False</span>)<br>        self.w_v = nn.Linear(num_hiddens, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        self.dropout = nn.Dropout(dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, queries, keys, values, valid_lens</span>):<br>        <span class="hljs-comment"># valid_lens对于每个query 考虑多少个kv</span><br>        queries, keys = self.W_q(queries), self.W_k(keys)<br>        <span class="hljs-comment"># 在维度扩展后，</span><br>        <span class="hljs-comment"># queries的形状：(batch_size，查询的个数，1，num_hidden)</span><br>        <span class="hljs-comment"># key的形状：(batch_size，1，“键－值”对的个数，num_hiddens)</span><br>        <span class="hljs-comment"># 使用广播方式进行求和</span><br>        features = queries.unsqueeze(<span class="hljs-number">2</span>) + keys.unsqueeze(<span class="hljs-number">1</span>)<br>        features = torch.tanh(features)<br>        <span class="hljs-comment"># self.w_v仅有一个输出，因此从形状中移除最后那个维度。</span><br>        <span class="hljs-comment"># scores的形状：(batch_size，查询的个数，“键-值”对的个数)</span><br>        scores = self.w_v(features).squeeze(-<span class="hljs-number">1</span>)<br>        self.attention_weights = masked_softmax(scores, valid_lens) <span class="hljs-comment"># valid_lens强行把scores得分1e-6</span><br>        <span class="hljs-comment"># values的形状：(batch_size，“键－值”对的个数，值的维度)</span><br>        <span class="hljs-keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)<br></code></pre></td></tr></table></figure><p>dropout增加模型的泛化能力</p><p>应用：key value query到底是什么</p><h3 id="Bahdanau-seq2seq"><a href="#Bahdanau-seq2seq" class="headerlink" title="Bahdanau seq2seq"></a>Bahdanau seq2seq</h3><p>翻译时额外添加原句子的对应信息，而不是只用最后一个state。具体用以前的哪个state由attention决定</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100636.png" alt="image-20230517144406568"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100637.png" alt="image-20230524211826420" style="zoom:50%;" /><ul><li>key-value：编码器每一次的RNN 的输出states</li><li>query：解码器上一次输出</li></ul><p>对比之前的改进：之前context直接用最后一个state，现在对所有state拿出来做一个weight</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100638.png" alt="image-20230517150923131"></p><ul><li><code>query</code>：当前state[-1]  <code>[batch_size,1,num_hiddens]</code> </li><li><code>key-value</code>: encoder的output<code>[batch_size,num_steps,num_hiddens]</code></li></ul><p><strong>以前的context</strong>：t次都一样，都是最后的state</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoder的state重复t次，代表着我t次上下文关注点都一样，每一次都是state(b, 1, num_hiddens)</span><br>context = state[-<span class="hljs-number">1</span>].repeat(X.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>X_and_context = torch.cat((X, context), <span class="hljs-number">2</span>)<br>output, state = self.rnn(X_and_context, state)  直接一次性输入到网络<br></code></pre></td></tr></table></figure><p><strong>现在的context：</strong>每次都不一样，为output的加权。<code>C=attention(pre-state, (h1,h2...ht))</code> <strong>不一样所以需要遍历</strong></p><ul><li><code>query</code>为上次state[-1]，代表着当前状态 <code>[batch_size, query=1, num_hiddens]</code>  当前状态的维度为<code>num_hiddens</code></li><li><code>key-value = enc_outputs</code>是encoder的output转置下  <code>[batch_size, num_steps, num_hiddens]</code> 代表着有t次状态，每个状态的维度为<code>num_hiddens</code>，attention对t次状态加权后得到<code>[batch_size, query=1, num_hiddens]</code>, 权重矩阵为<code>[b, query=1, num_steps]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> X:  <span class="hljs-comment"># 每一次query(当前状态都不同，代表着翻译到了哪个单词，不同状态不同注意点)</span><br>    <span class="hljs-comment"># query的形状为(batch_size, 1, num_hiddens)          1代表着一次询问</span><br>    query = torch.unsqueeze(hidden_state[-<span class="hljs-number">1</span>], dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># context的形状为(batch_size,1,num_hiddens)   enc_valid_lens忽略输入的pad</span><br>    context = self.attention(query, enc_outputs, enc_outputs, enc_valid_lens)<br>    <br>    <span class="hljs-comment"># 在特征维度上连结</span><br>    x = torch.cat((context, torch.unsqueeze(x, dim=<span class="hljs-number">1</span>)), dim=-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 将x变形为(t=1, batch_size, embed_size+num_hiddens)</span><br>    out, hidden_state = self.rnn(x.permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>), hidden_state)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100639.png" alt="image-20230525165633633"></p><p>纵坐标为生成的token<code>[&#39;&lt;bos&gt;&#39;, &#39;je&#39;, &#39;suis&#39;, &#39;chez&#39;, &#39;moi&#39;, &#39;.&#39;, &#39;&lt;eos&gt;&#39;]</code><br>横坐标为输入的4个词 <code>[&quot;i&#39;m&quot;, &#39;home&#39;, &#39;.&#39;, &#39;&lt;eos&gt;&#39;]</code></p><h3 id="self-attention！"><a href="#self-attention！" class="headerlink" title="self-attention！"></a>self-attention！</h3><p>同时拉取汇聚全部时间的信息</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100640.png" alt="image-20230517161838017"></p><p>key value query都是x</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100641.png" alt="image-20230517164245269"></p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原来： [querys, d(q)]  -&gt;  [querys, d(v)]</span><br>o = attention(queries, keys, values)   self.attention(query, enc_outputs, enc_outputs)<br><br><span class="hljs-comment"># 现在: [querys=t, d(x)]  -&gt;  [t, d(x)]</span><br>X = self.attention(X, X, X)<br><br><span class="hljs-comment"># 如果是在decoer，则不能看到当前t时刻以后的信息,(b, t) 每一行都是[1, 2, ...n]代表长度</span><br>X = self.attention(X, X, X, <br>                   torch.arange(<span class="hljs-number">1</span>, num_steps + <span class="hljs-number">1</span>, device=X.device).repeat(batch_size, <span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 如果所在预测阶段，Key_value需要不断生成，X为单个字符(1, 1, h) key_value(1, now_t, h) 前t个字符</span><br>    enc_outputs, enc_valid_lens = state[<span class="hljs-number">0</span>], state[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 预测阶段，输出序列是通过词元一个接着一个解码的，</span><br>    <span class="hljs-comment"># 因此state[2][self.i]包含着直到当前时间步第i个块解码的输出表示</span><br>    key_values = torch.cat((state[<span class="hljs-number">2</span>][self.i], X), axis=<span class="hljs-number">1</span>)<br>    state[<span class="hljs-number">2</span>][self.i] = key_values<br><br>    <span class="hljs-comment"># 自注意力</span><br>    X2 = self.attention1(X, key_values, key_values, dec_valid_lens=<span class="hljs-literal">None</span>)<br>    Y = self.addnorm1(X, X2)<br></code></pre></td></tr></table></figure><h4 id="pos-encoding"><a href="#pos-encoding" class="headerlink" title="pos-encoding"></a>pos-encoding</h4><p>失去了位置信息，添加上位置P矩阵。n个词i，每个d维j。也可以是可学习（BERT）<br>$$<br>\begin{aligned} p_{i, 2j} &amp;&#x3D; \sin\left(\frac{i}{10000^{2j&#x2F;d}}\right),\p_{i, 2j+1} &amp;&#x3D; \cos\left(\frac{i}{10000^{2j&#x2F;d}}\right).\end{aligned}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save </span><br>[b, t, d]  -&gt;  [b, t, d]    p:[<span class="hljs-number">1</span>, max_len, num_hiddens]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PositionalEncoding</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;位置编码&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_hiddens, dropout, max_len=<span class="hljs-number">1000</span></span>):<br>        <span class="hljs-built_in">super</span>(PositionalEncoding, self).__init__()<br>        self.dropout = nn.Dropout(dropout)<br>        <span class="hljs-comment"># 创建一个足够长的P</span><br>        self.P = torch.zeros((<span class="hljs-number">1</span>, max_len, num_hiddens))<br>        X = torch.arange(max_len, dtype=torch.float32).reshape(<br>            -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) / torch.<span class="hljs-built_in">pow</span>(<span class="hljs-number">10000</span>, torch.arange(<br>            <span class="hljs-number">0</span>, num_hiddens, <span class="hljs-number">2</span>, dtype=torch.float32) / num_hiddens)<br>        self.P[:, :, <span class="hljs-number">0</span>::<span class="hljs-number">2</span>] = torch.sin(X)<br>        self.P[:, :, <span class="hljs-number">1</span>::<span class="hljs-number">2</span>] = torch.cos(X)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        X = X + self.P[:, :X.shape[<span class="hljs-number">1</span>], :].to(X.device)<br>        <span class="hljs-keyword">return</span> self.dropout(X)<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100642.png" alt="image-20230517164528517" style="zoom:67%;" /><p>QA：</p><ol><li>self-attention理解为一个layer，有输入输出</li><li>BERT 其实是纯self-attention + context-attention</li></ol><h3 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h3><ul><li>encoder-decoder架构</li><li>纯注意力，n个transformer块</li><li>block input-output形状一样</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100643.png" alt="image-20230523122148500"></p><p>编码器的状态信息会同时传给每一个解码器block</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100644.png" alt="image-20230524212752754" style="zoom:50%;" /><h4 id="muti-head-attention"><a href="#muti-head-attention" class="headerlink" title="muti-head-attention"></a>muti-head-attention</h4><p>多个dot attention，也就是多个h。dot attention通过一个多头相当于添加了可学习参数</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100645.png" alt="image-20230523112624348"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">num_hiddens, num_heads = <span class="hljs-number">100</span>, <span class="hljs-number">5</span><br><br>X = torch.ones((b, num_queries, num_hiddens))<br>Y = torch.ones((b, num_kvpairs, num_hiddens))<br>attention = MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens,<br>                               num_hiddens, num_heads, <span class="hljs-number">0.5</span>)<br>attention(X, Y, Y, valid_lens).shape = [b, num_queries, num_hiddens]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save </span><br>t:查询或者“键－值”对的个数<br>transpose_qkv：(b，t，num_hiddens) -&gt; (b*num_heads, t, num_hiddens/num_heads)<br>相对于num_hiddens保存了多个头的信息，输入时拆分出来，为了直接大矩阵乘法去除<span class="hljs-keyword">for</span>循环<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiHeadAttention</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;多头注意力&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span><br><span class="hljs-params">                 num_heads, dropout, bias=<span class="hljs-literal">False</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(MultiHeadAttention, self).__init__(**kwargs)<br>        self.num_heads = num_heads<br>        self.attention = d2l.DotProductAttention(dropout)<br>        self.W_q = nn.Linear(query_size, num_hiddens, bias=bias)<br>        self.W_k = nn.Linear(key_size, num_hiddens, bias=bias)<br>        self.W_v = nn.Linear(value_size, num_hiddens, bias=bias)<br>        self.W_o = nn.Linear(num_hiddens, num_hiddens, bias=bias)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, queries, keys, values, valid_lens</span>):<br>        <span class="hljs-comment"># queries，keys，values的形状:</span><br>        <span class="hljs-comment"># (batch_size，查询或者“键－值”对的个数，num_hiddens)</span><br>        <span class="hljs-comment"># valid_lens　的形状:</span><br>        <span class="hljs-comment"># (batch_size，)或(batch_size，查询的个数)</span><br>        <span class="hljs-comment"># 经过变换后，输出的queries，keys，values　的形状:</span><br>        <span class="hljs-comment"># (batch_size*num_heads，查询或者“键－值”对的个数，</span><br>        <span class="hljs-comment"># num_hiddens/num_heads)</span><br>        queries = transpose_qkv(self.W_q(queries), self.num_heads)<br>        keys = transpose_qkv(self.W_k(keys), self.num_heads)<br>        values = transpose_qkv(self.W_v(values), self.num_heads)<br><br>        <span class="hljs-keyword">if</span> valid_lens <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 在轴0，将第一项（标量或者矢量）复制num_heads次，</span><br>            <span class="hljs-comment"># 然后如此复制第二项，然后诸如此类。</span><br>            valid_lens = torch.repeat_interleave(<br>                valid_lens, repeats=self.num_heads, dim=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># output的形状:(batch_size*num_heads，查询的个数，</span><br>        <span class="hljs-comment"># num_hiddens/num_heads)</span><br>        output = self.attention(queries, keys, values, valid_lens)<br><br>        <span class="hljs-comment"># output_concat的形状:(batch_size，查询的个数，num_hiddens)</span><br>        output_concat = transpose_output(output, self.num_heads)<br>        <span class="hljs-keyword">return</span> self.W_o(output_concat)<br></code></pre></td></tr></table></figure><h4 id="FFN"><a href="#FFN" class="headerlink" title="FFN"></a>FFN</h4><p>基于位置的前馈网络两层 MLP，[b, t, in] -&gt; [b, t, out]</p><p>self-attention是在不同的t之间汇聚信息，而mlp对单个t中的in信息做处理</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100646.png" alt="image-20230524205443098" style="zoom: 50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PositionWiseFFN</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;基于位置的前馈网络&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ffn_num_input=<span class="hljs-number">512</span>, ffn_num_hiddens=<span class="hljs-number">2048</span>, ffn_num_outputs=<span class="hljs-number">512</span>,</span><br><span class="hljs-params">                 **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(PositionWiseFFN, self).__init__(**kwargs)<br>        self.dense1 = nn.Linear(ffn_num_input, ffn_num_hiddens)<br>        self.relu = nn.ReLU()<br>        self.dense2 = nn.Linear(ffn_num_hiddens, ffn_num_outputs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        <span class="hljs-keyword">return</span> self.dense2(self.relu(self.dense1(X)))<br></code></pre></td></tr></table></figure><h4 id="mask-Mutiattention"><a href="#mask-Mutiattention" class="headerlink" title="mask-Mutiattention"></a>mask-Mutiattention</h4><p>predict时，不能使用未来的信息，通过设置有效的attention长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> self.training:<br>    batch_size, num_steps, _ = X.shape<br>    <span class="hljs-comment"># dec_valid_lens的开头:(batch_size,num_steps),</span><br>    <span class="hljs-comment"># 其中每一行是[1,2,...,num_steps] 因为X相对于有num_steps个query，后面的query长度更长</span><br>    dec_valid_lens = torch.arange(<br>        <span class="hljs-number">1</span>, num_steps + <span class="hljs-number">1</span>, device=X.device).repeat(batch_size, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        dec_valid_lens = <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># mask-自注意力</span><br>X2 = self.attention1(X, X, X, dec_valid_lens)  <span class="hljs-comment"># 预测阶段key value需要不断拼接得到</span><br>Y = self.addnorm1(X, X2)<br></code></pre></td></tr></table></figure><h4 id="Context-Attention"><a href="#Context-Attention" class="headerlink" title="Context Attention"></a>Context Attention</h4><p>decoder第二层为context attention，query当前状态，keyvalue为encoder的输出</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100647.png" alt="image-20230524204852405" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">enc_outputs, enc_valid_lens = state[<span class="hljs-number">0</span>], state[<span class="hljs-number">1</span>]<br>Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)<br>Z = self.addnorm2(Y, Y2)<br></code></pre></td></tr></table></figure><h4 id="AddNorm"><a href="#AddNorm" class="headerlink" title="AddNorm"></a>AddNorm</h4><p>残差标准化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddNorm</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;残差连接后进行层规范化&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, normalized_shape, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(AddNorm, self).__init__(**kwargs)<br>        self.dropout = nn.Dropout(dropout)<br>        self.ln = nn.LayerNorm(normalized_shape)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, Y</span>):<br>        <span class="hljs-keyword">return</span> self.ln(self.dropout(Y) + X)<br></code></pre></td></tr></table></figure><h4 id="Encoderblock"><a href="#Encoderblock" class="headerlink" title="Encoderblock"></a>Encoderblock</h4><p>MultiHeadAttention + addnorm1 + ffn + addnorm2  输入输出维度不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.ones((<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>))<br>valid_lens = torch.tensor([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>])<br>encoder_blk = EncoderBlock(<span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">24</span>], <span class="hljs-number">24</span>, <span class="hljs-number">48</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0.5</span>)<br>encoder_blk.<span class="hljs-built_in">eval</span>()<br>encoder_blk(X, valid_lens).shape = [<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderBlock</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;Transformer编码器块&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span><br><span class="hljs-params">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span><br><span class="hljs-params">                 dropout, use_bias=<span class="hljs-literal">False</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(EncoderBlock, self).__init__(**kwargs)<br>        self.attention = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout,<br>            use_bias)<br>        self.addnorm1 = AddNorm(norm_shape, dropout)<br>        self.ffn = PositionWiseFFN(<br>            ffn_num_input, ffn_num_hiddens, num_hiddens)<br>        self.addnorm2 = AddNorm(norm_shape, dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, valid_lens</span>):<br>        Y = self.addnorm1(X, self.attention(X, X, X, valid_lens))<br>        <span class="hljs-keyword">return</span> self.addnorm2(Y, self.ffn(Y))<br></code></pre></td></tr></table></figure><h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p>多个block堆叠。embedding + pos_encoding + 多个EncoderBlock</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">encoder = TransformerEncoder(<br>    <span class="hljs-number">200</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">24</span>], <span class="hljs-number">24</span>, <span class="hljs-number">48</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.5</span>)<br>encoder.<span class="hljs-built_in">eval</span>()<br>encoder(torch.ones((<span class="hljs-number">2</span>, <span class="hljs-number">100</span>), dtype=torch.long), valid_lens).shape<br>torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformerEncoder</span>(d2l.Encoder):<br>    <span class="hljs-string">&quot;&quot;&quot;Transformer编码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, key_size, query_size, value_size,</span><br><span class="hljs-params">                 num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,</span><br><span class="hljs-params">                 num_heads, num_layers, dropout, use_bias=<span class="hljs-literal">False</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(TransformerEncoder, self).__init__(**kwargs)<br>        self.num_hiddens = num_hiddens<br>        self.embedding = nn.Embedding(vocab_size, num_hiddens)<br>        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)<br>        self.blks = nn.Sequential()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_layers):<br>            self.blks.add_module(<span class="hljs-string">&quot;block&quot;</span>+<span class="hljs-built_in">str</span>(i),<br>                EncoderBlock(key_size, query_size, value_size, num_hiddens,<br>                             norm_shape, ffn_num_input, ffn_num_hiddens,<br>                             num_heads, dropout, use_bias))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, valid_lens, *args</span>):<br>        <span class="hljs-comment"># 因为位置编码值在-1和1之间，</span><br>        <span class="hljs-comment"># 因此嵌入值乘以嵌入维度的平方根进行缩放，</span><br>        <span class="hljs-comment"># 然后再与位置编码相加。</span><br>        X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))<br>        self.attention_weights = [<span class="hljs-literal">None</span>] * <span class="hljs-built_in">len</span>(self.blks)<br>        <span class="hljs-keyword">for</span> i, blk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.blks):<br>            X = blk(X, valid_lens)<br>            self.attention_weights[<br>                i] = blk.attention.attention.attention_weights<br>        <span class="hljs-keyword">return</span> X<br></code></pre></td></tr></table></figure><h4 id="Decoderblock"><a href="#Decoderblock" class="headerlink" title="Decoderblock"></a>Decoderblock</h4><p>需要自己的输入和encoder的输出。输入输出维度不变！</p><p><code>self-MultiHeadAttention + addnorm1 + MultiHeadAttention（编码器解码器注意力） + addnorm2  + fnn + addnorm3</code></p><ul><li>第一次mask-self-attention就是<code>attention1(X, X, X, dec_valid_lens)</code>，dec_valid_lens保证不看后面</li><li>第二次需要用到encoder输出<code>attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoderBlock</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;解码器中第i个块&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span><br><span class="hljs-params">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span><br><span class="hljs-params">                 dropout, i, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(DecoderBlock, self).__init__(**kwargs)<br>        self.i = i<br>        self.attention1 = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout)<br>        self.addnorm1 = AddNorm(norm_shape, dropout)<br>        self.attention2 = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout)<br>        self.addnorm2 = AddNorm(norm_shape, dropout)<br>        self.ffn = PositionWiseFFN(ffn_num_input, ffn_num_hiddens,<br>                                   num_hiddens)<br>        self.addnorm3 = AddNorm(norm_shape, dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, state</span>):<br>        enc_outputs, enc_valid_lens = state[<span class="hljs-number">0</span>], state[<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 训练阶段，输出序列的所有词元都在同一时间处理，</span><br>        <span class="hljs-comment"># 因此state[2][self.i]初始化为None。</span><br>        <span class="hljs-comment"># 预测阶段，输出序列是通过词元一个接着一个解码的，</span><br>        <span class="hljs-comment"># 因此state[2][self.i]包含着直到当前时间步第i个块解码的输出表示</span><br>        <span class="hljs-keyword">if</span> state[<span class="hljs-number">2</span>][self.i] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            key_values = X<br>        <span class="hljs-keyword">else</span>:<br>            key_values = torch.cat((state[<span class="hljs-number">2</span>][self.i], X), axis=<span class="hljs-number">1</span>)<br>        state[<span class="hljs-number">2</span>][self.i] = key_values<br>        <span class="hljs-keyword">if</span> self.training:<br>            batch_size, num_steps, _ = X.shape<br>            <span class="hljs-comment"># dec_valid_lens的开头:(batch_size,num_steps),</span><br>            <span class="hljs-comment"># 其中每一行是[1,2,...,num_steps] 因为X相对于有num_steps个query，后面的query长度更长</span><br>            dec_valid_lens = torch.arange(<br>                <span class="hljs-number">1</span>, num_steps + <span class="hljs-number">1</span>, device=X.device).repeat(batch_size, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            dec_valid_lens = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 自注意力</span><br>        X2 = self.attention1(X, key_values, key_values, dec_valid_lens)<br>        Y = self.addnorm1(X, X2)<br>        <span class="hljs-comment"># 编码器－解码器注意力。</span><br>        <span class="hljs-comment"># enc_outputs的开头:(batch_size,num_steps,num_hiddens)</span><br>        Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)<br>        Z = self.addnorm2(Y, Y2)<br>        <span class="hljs-keyword">return</span> self.addnorm3(Z, self.ffn(Z)), state<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">decoder_blk = DecoderBlock(<span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">24</span>], <span class="hljs-number">24</span>, <span class="hljs-number">48</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>)<br>decoder_blk.<span class="hljs-built_in">eval</span>()<br>X = torch.ones((<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>))<br>state = [encoder_blk(X, valid_lens), valid_lens, [<span class="hljs-literal">None</span>]]<br>decoder_blk(X, state)[<span class="hljs-number">0</span>].shape <span class="hljs-comment"># [2, 100, 24]</span><br></code></pre></td></tr></table></figure><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p>embedding + pos_encoding + 多个decoderBlock + dense；decoderBlock需要的state训练时不变，都是encoder给的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformerDecoder</span>(d2l.AttentionDecoder):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, key_size, query_size, value_size,</span><br><span class="hljs-params">                 num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,</span><br><span class="hljs-params">                 num_heads, num_layers, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(TransformerDecoder, self).__init__(**kwargs)<br>        self.num_hiddens = num_hiddens<br>        self.num_layers = num_layers<br>        self.embedding = nn.Embedding(vocab_size, num_hiddens)<br>        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)<br>        self.blks = nn.Sequential()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_layers):<br>            self.blks.add_module(<span class="hljs-string">&quot;block&quot;</span>+<span class="hljs-built_in">str</span>(i),<br>                DecoderBlock(key_size, query_size, value_size, num_hiddens,<br>                             norm_shape, ffn_num_input, ffn_num_hiddens,<br>                             num_heads, dropout, i))<br>        self.dense = nn.Linear(num_hiddens, vocab_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_state</span>(<span class="hljs-params">self, enc_outputs, enc_valid_lens, *args</span>):<br>        <span class="hljs-keyword">return</span> [enc_outputs, enc_valid_lens, [<span class="hljs-literal">None</span>] * self.num_layers]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, state</span>):<br>        X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))<br>        self._attention_weights = [[<span class="hljs-literal">None</span>] * <span class="hljs-built_in">len</span>(self.blks) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">2</span>)]<br>        <span class="hljs-keyword">for</span> i, blk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.blks):<br>            X, state = blk(X, state)<br>            <span class="hljs-comment"># 解码器自注意力权重</span><br>            self._attention_weights[<span class="hljs-number">0</span>][<br>                i] = blk.attention1.attention.attention_weights<br>            <span class="hljs-comment"># “编码器－解码器”自注意力权重</span><br>            self._attention_weights[<span class="hljs-number">1</span>][<br>                i] = blk.attention2.attention.attention_weights<br>        <span class="hljs-keyword">return</span> self.dense(X), state<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">attention_weights</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._attention_weights<br></code></pre></td></tr></table></figure><h4 id="train-1"><a href="#train-1" class="headerlink" title="train"></a>train</h4><p><code>num_hiddens 512 1024， num_heads 8 16</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">num_hiddens, num_layers, dropout, batch_size, num_steps = <span class="hljs-number">32</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">64</span>, <span class="hljs-number">10</span><br>lr, num_epochs, device = <span class="hljs-number">0.005</span>, <span class="hljs-number">200</span>, d2l.try_gpu()<br>ffn_num_input, ffn_num_hiddens, num_heads = <span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">4</span><br>key_size, query_size, value_size = <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span><br>norm_shape = [<span class="hljs-number">32</span>]<br><br>train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps)<br><br>encoder = TransformerEncoder(<br>    <span class="hljs-built_in">len</span>(src_vocab), key_size, query_size, value_size, num_hiddens,<br>    norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,<br>    num_layers, dropout)<br>decoder = TransformerDecoder(<br>    <span class="hljs-built_in">len</span>(tgt_vocab), key_size, query_size, value_size, num_hiddens,<br>    norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,<br>    num_layers, dropout)<br>net = d2l.EncoderDecoder(encoder, decoder)<br>d2l.train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device)<br></code></pre></td></tr></table></figure><h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><p>预测t+1：前t个转为key value，第t个为query</p><h4 id="QA：-2"><a href="#QA：-2" class="headerlink" title="QA："></a>QA：</h4><ol><li>concat特征比加权平均好</li><li>transfomer硬件要求还好，BERT很大</li><li>很多模型只有encoder，如bert</li><li>可以处理图片，抠出一个个patch</li></ol><h3 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h3><p>使用预训练模型提取句子特征，如word2vec(忽略时序)。预训练模型可以不更新，只修改output layer</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100648.png" alt="image-20230523145131209" style="zoom: 33%;" /><p>只有transformer的encoder：<code>block=12 24 hiddensize=768 1024 head=12 16   parameters=110 340M</code>  10亿个词</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul><li>Segment：没有解码器，所以输入输出都输入到encoder，用<sep>分开并且添加额外编码</li><li>Position：可学习</li><li>Token：普通编码</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100649.png" alt="image-20230523150435634"></p><h4 id="训练任务"><a href="#训练任务" class="headerlink" title="训练任务"></a>训练任务</h4><h5 id="带掩码"><a href="#带掩码" class="headerlink" title="带掩码"></a>带掩码</h5><p>transformer是双向的，如何做单向预测？</p><p>带掩码的语言模型：15%将一些词作为<mask>，完形填空</p><p>微调任务时，压根没有没有mask，让模型能在有答案情况下填空：对于mask 80%不变、10%保持、10%替换别的</p><h5 id="下一句子预测"><a href="#下一句子预测" class="headerlink" title="下一句子预测"></a>下一句子预测</h5><p>句子是不是相邻</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100650.png" alt="image-20230523151222497"></p><h4 id="BERT代码"><a href="#BERT代码" class="headerlink" title="BERT代码"></a>BERT代码</h4><p>1.对token添加<cls> <sep></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_tokens_and_segments</span>(<span class="hljs-params">tokens_a, tokens_b=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;获取输入序列的词元及其片段索引&quot;&quot;&quot;</span><br>    tokens = [<span class="hljs-string">&#x27;&lt;cls&gt;&#x27;</span>] + tokens_a + [<span class="hljs-string">&#x27;&lt;sep&gt;&#x27;</span>]<br>    <span class="hljs-comment"># 0和1分别标记片段A和B</span><br>    segments = [<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(tokens_a) + <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> tokens_b <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        tokens += tokens_b + [<span class="hljs-string">&#x27;&lt;sep&gt;&#x27;</span>]<br>        segments += [<span class="hljs-number">1</span>] * (<span class="hljs-built_in">len</span>(tokens_b) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> tokens, segments<br></code></pre></td></tr></table></figure><h5 id="BERTEncoder"><a href="#BERTEncoder" class="headerlink" title="BERTEncoder"></a>BERTEncoder</h5><p>输入tokens，segments [b, t]，返回[b, t, hidden]。Encoder中包含pos_embedding</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERTEncoder</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT编码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, num_hiddens, norm_shape, ffn_num_input,</span><br><span class="hljs-params">                 ffn_num_hiddens, num_heads, num_layers, dropout,</span><br><span class="hljs-params">                 max_len=<span class="hljs-number">1000</span>, key_size=<span class="hljs-number">768</span>, query_size=<span class="hljs-number">768</span>, value_size=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">                 **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(BERTEncoder, self).__init__(**kwargs)<br>        self.token_embedding = nn.Embedding(vocab_size, num_hiddens)<br>        self.segment_embedding = nn.Embedding(<span class="hljs-number">2</span>, num_hiddens)<br>        self.blks = nn.Sequential()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_layers):<br>            self.blks.add_module(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, d2l.EncoderBlock(<br>                key_size, query_size, value_size, num_hiddens, norm_shape,<br>                ffn_num_input, ffn_num_hiddens, num_heads, dropout, <span class="hljs-literal">True</span>))<br>        <span class="hljs-comment"># 在BERT中，位置嵌入是可学习的，因此我们创建一个足够长的位置嵌入参数</span><br>        self.pos_embedding = nn.Parameter(torch.randn(<span class="hljs-number">1</span>, max_len,<br>                                                      num_hiddens))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, tokens, segments, valid_lens</span>):<br>        <span class="hljs-comment"># 在以下代码段中，X的形状保持不变：（批量大小，最大序列长度，num_hiddens）</span><br>        X = self.token_embedding(tokens) + self.segment_embedding(segments)<br>        X = X + self.pos_embedding.data[:, :X.shape[<span class="hljs-number">1</span>], :]<br>        <span class="hljs-keyword">for</span> blk <span class="hljs-keyword">in</span> self.blks:<br>            X = blk(X, valid_lens)<br>        <span class="hljs-keyword">return</span> X<br></code></pre></td></tr></table></figure><h5 id="MaskLM"><a href="#MaskLM" class="headerlink" title="MaskLM"></a>MaskLM</h5><p>对编码器的输出特征encoded_X，在指定位置上pred_positions，提取出该位置特征masked_X去分类</p><p><code>encoded_X：[b, t, hidden]    pred_positions：[b, num_pred]    masked_X：[b, num_pred, hidden]   </code></p><p><code>out: [b, num_pred, vocab_size]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaskLM</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT的掩蔽语言模型任务&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, num_hiddens, num_inputs=<span class="hljs-number">768</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(MaskLM, self).__init__(**kwargs)<br>        self.mlp = nn.Sequential(nn.Linear(num_inputs, num_hiddens),<br>                                 nn.ReLU(),<br>                                 nn.LayerNorm(num_hiddens),<br>                                 nn.Linear(num_hiddens, vocab_size))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, pred_positions</span>):<br>        num_pred_positions = pred_positions.shape[<span class="hljs-number">1</span>]<br>        pred_positions = pred_positions.reshape(-<span class="hljs-number">1</span>)<br>        batch_size = X.shape[<span class="hljs-number">0</span>]<br>        batch_idx = torch.arange(<span class="hljs-number">0</span>, batch_size)<br>        <span class="hljs-comment"># 假设batch_size=2，num_pred_positions=3</span><br>        <span class="hljs-comment"># 那么batch_idx是np.array（[0,0,0,1,1,1]）</span><br>        batch_idx = torch.repeat_interleave(batch_idx, num_pred_positions)<br>        masked_X = X[batch_idx, pred_positions]<br>        masked_X = masked_X.reshape((batch_size, num_pred_positions, -<span class="hljs-number">1</span>))<br>        mlm_Y_hat = self.mlp(masked_X)<br>        <span class="hljs-keyword">return</span> mlm_Y_hat<br></code></pre></td></tr></table></figure><h5 id="NextSentencePred"><a href="#NextSentencePred" class="headerlink" title="NextSentencePred"></a>NextSentencePred</h5><p>对<code>encoded_X[:, 0, :]</code><cls>的特征进行分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NextSentencePred</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT的下一句预测任务&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_inputs, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(NextSentencePred, self).__init__(**kwargs)<br>        self.output = nn.Linear(num_inputs, <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        <span class="hljs-comment"># X的形状：(batchsize,num_hiddens)</span><br>        <span class="hljs-keyword">return</span> self.output(X)<br></code></pre></td></tr></table></figure><h5 id="BERTModel"><a href="#BERTModel" class="headerlink" title="BERTModel"></a>BERTModel</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERTModel</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT模型&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, num_hiddens, norm_shape, ffn_num_input,</span><br><span class="hljs-params">                 ffn_num_hiddens, num_heads, num_layers, dropout,</span><br><span class="hljs-params">                 max_len=<span class="hljs-number">1000</span>, key_size=<span class="hljs-number">768</span>, query_size=<span class="hljs-number">768</span>, value_size=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">                 hid_in_features=<span class="hljs-number">768</span>, mlm_in_features=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">                 nsp_in_features=<span class="hljs-number">768</span></span>):<br>        <span class="hljs-built_in">super</span>(BERTModel, self).__init__()<br>        self.encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape,<br>                    ffn_num_input, ffn_num_hiddens, num_heads, num_layers,<br>                    dropout, max_len=max_len, key_size=key_size,<br>                    query_size=query_size, value_size=value_size)<br>        self.hidden = nn.Sequential(nn.Linear(hid_in_features, num_hiddens),<br>                                    nn.Tanh())<br>        self.mlm = MaskLM(vocab_size, num_hiddens, mlm_in_features)<br>        self.nsp = NextSentencePred(nsp_in_features)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, tokens, segments, valid_lens=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                pred_positions=<span class="hljs-literal">None</span></span>):<br>        encoded_X = self.encoder(tokens, segments, valid_lens)<br>        <span class="hljs-keyword">if</span> pred_positions <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            mlm_Y_hat = self.mlm(encoded_X, pred_positions)<br>        <span class="hljs-keyword">else</span>:<br>            mlm_Y_hat = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 用于下一句预测的多层感知机分类器的隐藏层，0是“&lt;cls&gt;”标记的索引</span><br>        nsp_Y_hat = self.nsp(self.hidden(encoded_X[:, <span class="hljs-number">0</span>, :]))<br>        <span class="hljs-keyword">return</span> encoded_X, mlm_Y_hat, nsp_Y_hat<br></code></pre></td></tr></table></figure><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><ul><li>需要先获得 tokens, segments, is_next ； segments为0、1用于区别句子</li><li>对tokens进行mask替换，返回tokens，positions，positions上原词汇mlm_Y</li><li>pad  和对应 valid_lens。all_mlm_weights0或1用于过滤掉mask中，属于pad的词</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span> (tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X, mlm_Y, nsp_y) <span class="hljs-keyword">in</span> train_iter<br><br>torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 64]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 64]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 10]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 10]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 10]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512]</span>)<br><br>mlm_weights_X <span class="hljs-number">0</span>或<span class="hljs-number">1</span>用于过滤掉<span class="hljs-attribute">mask</span>中，属于pad的词<br></code></pre></td></tr></table></figure><h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>训练是不需要encoder_X,为了提升模型抽取encoder的能力</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">net = d2l.BERTModel(<span class="hljs-built_in">len</span>(vocab), num_hiddens=<span class="hljs-number">128</span>, norm_shape=[<span class="hljs-number">128</span>],<br>                    ffn_num_input=<span class="hljs-number">128</span>, ffn_num_hiddens=<span class="hljs-number">256</span>, num_heads=<span class="hljs-number">2</span>,<br>                    num_layers=<span class="hljs-number">2</span>, dropout=<span class="hljs-number">0.2</span>, key_size=<span class="hljs-number">128</span>, query_size=<span class="hljs-number">128</span>,<br>                    value_size=<span class="hljs-number">128</span>, hid_in_features=<span class="hljs-number">128</span>, mlm_in_features=<span class="hljs-number">128</span>,<br>                    nsp_in_features=<span class="hljs-number">128</span>)<br>devices = d2l.try_all_gpus()<br>loss = nn.CrossEntropyLoss()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_batch_loss_bert</span>(<span class="hljs-params">net, loss, vocab_size, tokens_X,</span><br><span class="hljs-params">                         segments_X, valid_lens_x,</span><br><span class="hljs-params">                         pred_positions_X, mlm_weights_X,</span><br><span class="hljs-params">                         mlm_Y, nsp_y</span>):<br>    <span class="hljs-comment"># 前向传播</span><br>    _, mlm_Y_hat, nsp_Y_hat = net(tokens_X, segments_X,<br>                                  valid_lens_x.reshape(-<span class="hljs-number">1</span>),<br>                                  pred_positions_X)<br>    <span class="hljs-comment"># 计算遮蔽语言模型损失 不计算pad的</span><br>    mlm_l = loss(mlm_Y_hat.reshape(-<span class="hljs-number">1</span>, vocab_size), mlm_Y.reshape(-<span class="hljs-number">1</span>)) *\<br>    mlm_weights_X.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    mlm_l = mlm_l.<span class="hljs-built_in">sum</span>() / (mlm_weights_X.<span class="hljs-built_in">sum</span>() + <span class="hljs-number">1e-8</span>)<br>    <span class="hljs-comment"># 计算下一句子预测任务的损失</span><br>    nsp_l = loss(nsp_Y_hat, nsp_y)<br>    l = mlm_l + nsp_l<br>    <span class="hljs-keyword">return</span> mlm_l, nsp_l, l<br></code></pre></td></tr></table></figure><h4 id="BERT表示文本"><a href="#BERT表示文本" class="headerlink" title="BERT表示文本"></a>BERT表示文本</h4><p>利用BERT获得句子的encoded_X，去进行分类、预测等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_bert_encoding</span>(<span class="hljs-params">net, tokens_a, tokens_b=<span class="hljs-literal">None</span></span>):<br>    tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b)<br>    token_ids = torch.tensor(vocab[tokens], device=devices[<span class="hljs-number">0</span>]).unsqueeze(<span class="hljs-number">0</span>)<br>    segments = torch.tensor(segments, device=devices[<span class="hljs-number">0</span>]).unsqueeze(<span class="hljs-number">0</span>)<br>    valid_len = torch.tensor(<span class="hljs-built_in">len</span>(tokens), device=devices[<span class="hljs-number">0</span>]).unsqueeze(<span class="hljs-number">0</span>)<br>    encoded_X, _, _ = net(token_ids, segments, valid_len)<br>    <span class="hljs-keyword">return</span> encoded_X<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">tokens_a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;crane&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;flying&#x27;</span>]<br>encoded_text = get_bert_encoding(net, tokens_a) [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">128</span>]<br><span class="hljs-comment"># 词元：&#x27;&lt;cls&gt;&#x27;,&#x27;a&#x27;,&#x27;crane&#x27;,&#x27;is&#x27;,&#x27;flying&#x27;,&#x27;&lt;sep&gt;&#x27;</span><br>encoded_text_cls = encoded_text[:, <span class="hljs-number">0</span>, :]  [<span class="hljs-number">1</span>, <span class="hljs-number">128</span>]<br><br>tokens_a, tokens_b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;crane&#x27;</span>, <span class="hljs-string">&#x27;driver&#x27;</span>, <span class="hljs-string">&#x27;came&#x27;</span>], [<span class="hljs-string">&#x27;he&#x27;</span>, <span class="hljs-string">&#x27;just&#x27;</span>, <span class="hljs-string">&#x27;left&#x27;</span>]<br>encoded_pair = get_bert_encoding(net, tokens_a, tokens_b)<br><span class="hljs-comment"># 词元：&#x27;&lt;cls&gt;&#x27;,&#x27;a&#x27;,&#x27;crane&#x27;,&#x27;driver&#x27;,&#x27;came&#x27;,&#x27;&lt;sep&gt;&#x27;,&#x27;he&#x27;,&#x27;just&#x27;, &#x27;left&#x27;,&#x27;&lt;sep&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="QA：-3"><a href="#QA：-3" class="headerlink" title="QA："></a>QA：</h4><ol><li>模型太大？ model分在不同GPU上</li></ol><h3 id="微调BERT"><a href="#微调BERT" class="headerlink" title="微调BERT"></a>微调BERT</h3><p>利用bert对每个词都抽取了特征，我们不需要考虑如何抽取句子特征、词特征了。只需要添加输出层。需要相同Vocab</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100651.png" alt="image-20230523164053828" style="zoom:50%;" /><ul><li><p>句子分类：直接用<cls>的特征，别的也可以但最好cls</p></li><li><p>识别词元是不是特殊词：人名、地名、机构。  对每一个词的特征做二分类</p></li><li><p>问题回答：给出一段话和一个问题。对于一段话中每一个词，预测是不是问题的开始和结束。三分类</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100652.png" alt="image-20230523164551697" style="zoom:50%;" /></li></ul><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><p>只需要用上encoder，hidden是bert中输出到NSP前的处理，这里也用上；相对于替换了NSP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERTClassifier</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, bert</span>):<br>        <span class="hljs-built_in">super</span>(BERTClassifier, self).__init__()<br>        self.encoder = bert.encoder<br>        self.hidden = bert.hidden<br>        self.output = nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs</span>):<br>        tokens_X, segments_X, valid_lens_x = inputs<br>        encoded_X = self.encoder(tokens_X, segments_X, valid_lens_x)<br>        <span class="hljs-keyword">return</span> self.output(self.hidden(encoded_X[:, <span class="hljs-number">0</span>, :]))<br></code></pre></td></tr></table></figure><h4 id="QA-1"><a href="#QA-1" class="headerlink" title="QA:"></a>QA:</h4><ol><li>YOLO基础效果不好，但加了大量trick细节</li><li>通过蒸馏十分之一大小，但精度不会下降很多</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
      <category>动手学深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 - jyy</title>
    <link href="/2023/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20jyy/"/>
    <url>/2023/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20jyy/</url>
    
    <content type="html"><![CDATA[<p>有什么不懂的直接问gpt</p><h3 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404494.png" alt="image-20230512154440672" style="zoom: 67%;" /><p>00 01 10 00 01 10</p><h4 id="源代码角度"><a href="#源代码角度" class="headerlink" title="源代码角度"></a>源代码角度</h4><p>同时我们也可以用C语言实现</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404496.png" alt="image-20230512155633763"></p><p>状态：内存中的所有东西，全部栈帧</p><p>使用栈模拟递归</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404497.png" alt="image-20230512161116475" style="zoom: 67%;" /><h4 id="二进制角度"><a href="#二进制角度" class="headerlink" title="二进制角度"></a>二进制角度</h4><ul><li>状态：内存 + 寄存器</li><li>初始状态：</li><li>迁移：一条01指令</li></ul><p>任何的程序都需要退出，也就是结束。因此需要特别的指令 <code>syscall</code> 把现在的状态交给操作系统</p><p>程序 &#x3D;  普通计算 + <code>syscall</code></p><p>实现与操作系统中别的对象交互</p><ul><li>读写文件  如果有权限，操作系统把状态写入程序的M, R</li><li>改变进程 杀死程序</li></ul><p>如何构造一个<code>printf(&quot;hello world&quot;)</code></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404498.png" alt="image-20230512171448873" style="zoom:67%;" /><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li>收编了所有对象（包含程序状态机和文件），实现霸主地位</li><li>管理多个状态机，根据权限访问。打开文件，屏幕显示</li></ul><p>在程序眼里，操作系统就是<code>syscall</code>，程序 &#x3D; (普通计算 + <code>syscall</code>)  如何只展示<code>syscall</code></p><ul><li><code>strace a.out</code>  去掉计算，只展示用到的所有的系统调用</li></ul><p>c语言的第一条程序是什么，谁定义的，能不能修改</p><p>计算机没有玄学，一切都建立在确定的机制上。bug只要能复现，就能解决</p><h4 id="Python操作系统"><a href="#Python操作系统" class="headerlink" title="Python操作系统"></a>Python操作系统</h4><p><strong>思路</strong></p><ul><li>应用程序 &#x3D; 纯粹计算（Python 代码） + <code>syscall</code>；  状态机</li><li>操作系统 &#x3D; Python <code>syscall</code>实现，有 “假想” 的 I&#x2F;O 设备；   管理状态机</li></ul><p>​    操作系统为方框，程序为圆圈，操作系统管理全部程序，并且会提供红色的<code>syscall</code>指令。蓝色为当前运行程序<br>当<code>spawn</code>创建程序后，操作系统有了选择，到底执行哪一个程序呢？</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404499.png" alt="image-20230527124547932"></p><p><strong>四个 “系统调用” API</strong></p><ul><li><code>choose(xs)</code>: 返回 <code>xs</code> 中的一个随机选项，纯粹的计算不能实现随机</li><li><code>write(s)</code>: 输出字符串 <code>s</code></li><li><code>spawn(fn)</code>: 创建一个可运行的状态机 <code>fn</code></li><li><code>sched()</code>: 随机切换到任意状态机执行（这里是主动切换，实际也存在被OS强制切换）</li></ul><h5 id="demo-code"><a href="#demo-code" class="headerlink" title="demo-code"></a>demo-code</h5><p>我进行状态机切换，肯定需要保存状态（变量值是多少、pc在哪） ： <code>yield</code>  （实际OS由一段汇编代码将当前状态机 (执行流) 的寄存器保存到内存中）<br>每一个进程在操作系统里被视为一个生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatingSystem</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;A minimal executable operating system model.&quot;&quot;&quot;</span><br><br>    SYSCALLS = [<span class="hljs-string">&#x27;choose&#x27;</span>, <span class="hljs-string">&#x27;write&#x27;</span>, <span class="hljs-string">&#x27;spawn&#x27;</span>, <span class="hljs-string">&#x27;sched&#x27;</span>]<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;A &quot;freezed&quot; thread state.&quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func, *args</span>):<br>            self._func = func(*args)<br>            self.retval = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">self</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;Proceed with the thread until its next trap.&quot;&quot;&quot;</span><br>            syscall, args, *_ = self._func.send(self.retval)<br>            self.retval = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">return</span> syscall, args<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, src</span>):<br>        variables = &#123;&#125;<br>        <span class="hljs-built_in">exec</span>(src, variables)<br>        self._main = variables[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        threads = [OperatingSystem.Thread(self._main)]<br>        <span class="hljs-keyword">while</span> threads:  <span class="hljs-comment"># Any thread lives</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">match</span> (t := threads[<span class="hljs-number">0</span>]).step():<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;choose&#x27;</span>, xs:  <span class="hljs-comment"># Return a random choice</span><br>                        t.retval = random.choice(xs)<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;write&#x27;</span>, xs:  <span class="hljs-comment"># Write to debug console</span><br>                        <span class="hljs-built_in">print</span>(xs, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;spawn&#x27;</span>, (fn, args):  <span class="hljs-comment"># Spawn a new thread</span><br>                        threads += [OperatingSystem.Thread(fn, *args)]<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;sched&#x27;</span>, _:  <span class="hljs-comment"># Non-deterministic schedule</span><br>                        random.shuffle(threads)<br>            <span class="hljs-keyword">except</span> StopIteration:  <span class="hljs-comment"># A thread terminates</span><br>                threads.remove(t)<br>                random.shuffle(threads)  <span class="hljs-comment"># sys_sched()</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Usage: <span class="hljs-subst">&#123;sys.argv[<span class="hljs-number">0</span>]&#125;</span> file&#x27;</span>)<br>        exit(<span class="hljs-number">1</span>)<br><br>    src = Path(sys.argv[<span class="hljs-number">1</span>]).read_text()<br>    <span class="hljs-keyword">for</span> syscall <span class="hljs-keyword">in</span> OperatingSystem.SYSCALLS:<br>        src = src.replace(<span class="hljs-string">f&#x27;sys_<span class="hljs-subst">&#123;syscall&#125;</span>&#x27;</span>,        <span class="hljs-comment"># sys_write(...)</span><br>                          <span class="hljs-string">f&#x27;yield &quot;<span class="hljs-subst">&#123;syscall&#125;</span>&quot;, &#x27;</span>)  <span class="hljs-comment">#  -&gt; yield &#x27;write&#x27;, (...)</span><br><br>    OperatingSystem(src).run()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">count = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Tprint</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">global</span> count<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        count += <span class="hljs-number">1</span><br>        sys_write(<span class="hljs-string">f&#x27;#<span class="hljs-subst">&#123;count:02&#125;</span> Hello from <span class="hljs-subst">&#123;name&#125;</span><span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>\n&#x27;</span>)<br>        sys_sched()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    n = sys_choose([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>    sys_write(<span class="hljs-string">f&#x27;#Thread = <span class="hljs-subst">&#123;n&#125;</span>\n&#x27;</span>)<br>    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ABCDE&#x27;</span>[:n]:<br>        sys_spawn(Tprint, name)<br>    sys_sched()<br></code></pre></td></tr></table></figure><h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><p>进程 + 线程 + 终端 + 存储 (崩溃一致性)</p><table><thead><tr><th align="left">系统调用&#x2F;Linux 对应</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left">sys_spawn(fn)&#x2F;pthread_create</td><td align="left">创建从 fn 开始执行的线程</td></tr><tr><td align="left">sys_fork()&#x2F;fork</td><td align="left">创建当前状态机的完整复制</td></tr><tr><td align="left">sys_sched()&#x2F;定时被动调用</td><td align="left">切换到随机的线程&#x2F;进程执行</td></tr><tr><td align="left">sys_choose(xs)&#x2F;rand</td><td align="left">返回一个 xs 中的随机的选择</td></tr><tr><td align="left">sys_write(s)&#x2F;printf</td><td align="left">向调试终端输出字符串 s</td></tr><tr><td align="left">sys_bread(k)&#x2F;read</td><td align="left">读取虚拟设磁盘块 �<em>k</em> 的数据</td></tr><tr><td align="left">sys_bwrite(k, v)&#x2F;write</td><td align="left">向虚拟磁盘块 �<em>k</em> 写入数据 �<em>v</em></td></tr><tr><td align="left">sys_sync()&#x2F;sync</td><td align="left">将所有向虚拟磁盘的数据写入落盘</td></tr><tr><td align="left">sys_crash()&#x2F;长按电源按键</td><td align="left">模拟系统崩溃</td></tr></tbody></table><p><code>mosaic.py</code>：500行操作系统。还实现了打印每一步的状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">T = <span class="hljs-number">3</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Tsum</span>( ):<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        tmp = heap.x<br>        tmp += <span class="hljs-number">1</span><br>        sys_sched()<br>        heap.x = tmp<br>        sys_sched()  <span class="hljs-comment"># 没有这一步, 最小为 n=3  添加后为2</span><br>    heap.done += <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    heap.x = <span class="hljs-number">0</span><br>    heap.done = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):<br>    sys_spawn(Tsum)<br>    <span class="hljs-keyword">while</span> heap.done != T:<br>    sys_sched()<br>    sys_write(<span class="hljs-string">f&#x27;SUM = <span class="hljs-subst">&#123;heap.x&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>不确定性发生在<code>sys_sched()</code>， <code>--check</code> 遍历所有答案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Tsum</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-type">int</span> tmp = sum;<br>    tmp++;<br>    <span class="hljs-comment">// 假设此时可能发生进程/线程切换</span><br>    sum = tmp;<br>    <span class="hljs-comment">// 假设此时可能发生进程/线程切换  没有这个最小值为n</span><br>  &#125;<br>&#125;<br>T个程序执行n次，[<span class="hljs-number">2</span>~n*T]<br></code></pre></td></tr></table></figure><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="多处理器编程"><a href="#多处理器编程" class="headerlink" title="多处理器编程"></a><a href="http://jyywiki.cn/OS/2022/slides/3.slides">多处理器编程</a></h3><p><strong>1.放弃原子性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> balance = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Alipay_withdraw</span><span class="hljs-params">(<span class="hljs-type">int</span> amt)</span> &#123;<br>  <span class="hljs-keyword">if</span> (balance &gt;= amt) &#123;<br>    balance -= amt;<br>    <span class="hljs-keyword">return</span> SUCCESS;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> FAIL;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) sum++;<br></code></pre></td></tr></table></figure><p><code>printf(&quot;a&quot;) </code>为什么不会报错？带了锁</p><p>互斥和原子性是本学期的重要主题</p><p> <strong>2.顺序丧失</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">-O1: R[eax] = sum; R[eax] += N; sum = R[eax]<br>    O1保证最终一致，如果要写入多次，直接一次性写入<br>    最终读出<span class="hljs-number">100000000</span><br>    <br>-O2: sum += N;  <span class="hljs-number">200000000</span><br>    <br>另一个例子： 系统默认done不会改变了<br>    <span class="hljs-keyword">while</span> (!done);<br>    <span class="hljs-comment">// would be optimized to</span><br>    <span class="hljs-keyword">if</span> (!done) <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>3.丧失可见性</strong></p><p>理论上输出 01 10 11, 但其实00也有输出</p><p>处理器也是一个编译器，一条指令拆分多个uops</p><p>如果想写入x时未命中，print就可以先执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">T1</span><span class="hljs-params">()</span> &#123;<br>  x = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> : : <span class="hljs-string">&quot;memory&quot;</span>)</span>; <span class="hljs-comment">// compiler barrier</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;y = %d\n&quot;</span>, y);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">T2</span><span class="hljs-params">()</span> &#123;<br>  y = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> : : <span class="hljs-string">&quot;memory&quot;</span>)</span>; <span class="hljs-comment">// compiler barrier</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %d\n&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="理解并发程序执行"><a href="#理解并发程序执行" class="headerlink" title="理解并发程序执行"></a><a href="http://jyywiki.cn/OS/2022/slides/4.slides">理解并发程序执行</a></h3><p>在<strong>共享内存</strong>实现并发时，一个反例   <code>get set</code>不是原子操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> locked = UNLOCK;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">critical_section</span><span class="hljs-params">()</span> &#123;<br>retry:<br>  <span class="hljs-keyword">if</span> (locked != UNLOCK) &#123;<br>    <span class="hljs-keyword">goto</span> retry;<br>  &#125;<br>  locked = LOCK;<br><br>  <span class="hljs-comment">// critical section</span><br><br>  locked = UNLOCK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Peterson"><a href="#Peterson" class="headerlink" title="Peterson"></a>Peterson</h4><p>棋子代表：我想上厕所；门上贴的人代表着：谁能上厕所</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404500.png" alt="image-20230514163743735" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, turn = A;<br>void TA() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>/* PC=<span class="hljs-number">1</span> */  x = <span class="hljs-number">1</span>;<br>/* PC=<span class="hljs-number">2</span> */  turn = B;<br>/* PC=<span class="hljs-number">3</span> */  <span class="hljs-keyword">while</span> (y &amp;&amp; turn == B) ;<br>            critical_section();<br>/* PC=<span class="hljs-number">4</span> */  x = <span class="hljs-number">0</span>; &#125; &#125;<br>void TB() &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>/* PC=<span class="hljs-number">1</span> */  y = <span class="hljs-number">1</span>;<br>/* PC=<span class="hljs-number">2</span> */  turn = A;<br>/* PC=<span class="hljs-number">3</span> */  <span class="hljs-keyword">while</span> (x &amp;&amp; turn == A) ;<br>            critical_section();<br>/* PC=<span class="hljs-number">4</span> */  y = <span class="hljs-number">0</span>; &#125; &#125;<br></code></pre></td></tr></table></figure><p>证明正确性：直接画出状态机表达出全部状态。</p><h4 id="Model-Checker"><a href="#Model-Checker" class="headerlink" title="Model Checker"></a>Model Checker</h4><p>并发程序 &#x3D; 状态机，画出状态机就可以知道并发程序有没有错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span>:<br>    locked = <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">T1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">yield</span> checkpoint()<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">yield</span> checkpoint()<br>            <span class="hljs-keyword">while</span> self.locked == <span class="hljs-string">&#x27;🔒&#x27;</span>:<br>                <span class="hljs-keyword">yield</span> checkpoint()<br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">yield</span> checkpoint()<br>            self.locked = <span class="hljs-string">&#x27;🔒&#x27;</span><br>            ...<br></code></pre></td></tr></table></figure><p>使用程序去遍历出全部的状态  Model Checker</p><p>没有工具（编程、测试、调试），不做系统</p><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a><a href="http://jyywiki.cn/OS/2022/slides/5.slides">互斥</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  ...<br>&#125; <span class="hljs-type">lock_t</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lk)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lk)</span>;<br></code></pre></td></tr></table></figure><p>还是原来难点：<strong>get set 非原子</strong></p><h4 id="自旋锁-spin-lock"><a href="#自旋锁-spin-lock" class="headerlink" title="自旋锁 spin lock"></a>自旋锁 spin lock</h4><p><strong>硬件</strong>能为我们提供一条 “瞬间完成” 的读 + 写指令</p><p> <code>xchg dest, src</code>  原子的实现交换数据，并返回原来的值。 这样就可以实现两个线程之间的锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">xchg</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *addr, <span class="hljs-type">int</span> newval)</span> &#123;<br>  <span class="hljs-type">int</span> result;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;lock xchg %0, %1&quot;</span></span><br><span class="hljs-params">    : <span class="hljs-string">&quot;+m&quot;</span>(*addr), <span class="hljs-string">&quot;=a&quot;</span>(result) : <span class="hljs-string">&quot;1&quot;</span>(newval))</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span> (xchg(&amp;locked, <span class="hljs-number">1</span>)) ; &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; xchg(&amp;locked, <span class="hljs-number">0</span>); &#125;<br></code></pre></td></tr></table></figure><ul><li>处理器保证，带lock的指令可以锁定总线，xchg默认带lock</li><li>两个cpu共享内存时，带lock指令会锁住memory ，硬件实现，一个bit实现bus lock</li><li>cpu有缓存L1，如何保证缓存一致。当一个cpu锁定memory时，需要把别的cpu的缓存都剔除</li></ul><p><code>Load-Reserved/Store-Conditional</code>，硬件里会实现</p><p>Compare-and-Swap：乐观锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">int</span> *addr, <span class="hljs-type">int</span> cmp_val, <span class="hljs-type">int</span> new_val)</span> &#123;   <br>  <span class="hljs-type">int</span> old_val = *addr;<br>  <span class="hljs-keyword">if</span> (old_val == cmp_val) &#123;<br>    *addr = new_val; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缺陷</strong>：未获得锁的线程在空转，甚至获取锁的线程被OS切换了，所以需要<strong>不拥堵时</strong>使用</p><p>操作系统内部自己使用：操作系统内核的并发数据结构 (短临界区)；关中断</p><h4 id="互斥锁-Mutex-Lock"><a href="#互斥锁-Mutex-Lock" class="headerlink" title="互斥锁  Mutex Lock"></a>互斥锁  Mutex Lock</h4><p>与其干等，不如把cpu让给别的线程执行，<strong>阻塞</strong></p><p>把锁的实现放到<strong>操作系统</strong>里就好！</p><ul><li><pre><code class="c">syscall(SYSCALL_lock, &amp;lk); // 试图获得 `lk`，但如果失败，就切换到其他线程<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br>- ```c<br>  <span class="hljs-built_in">syscall</span>(SYSCALL_unlock, &amp;lk); <span class="hljs-comment">// 释放 `lk`，如果有等待锁的线程就唤醒</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>未得到锁会进入等待队列，释放锁时OS会取出等待队列中一个线程，<strong>OS使用自旋锁</strong>确保自己处理过程是原子的</p><p>上锁失败会睡眠，不占用CPU，但不管有没有竞争都需要进出内核系统调用，带来一定的开销</p><h4 id="Futex-x3D-Spin-Mutex"><a href="#Futex-x3D-Spin-Mutex" class="headerlink" title="Futex &#x3D; Spin + Mutex"></a>Futex &#x3D; Spin + Mutex</h4><p><code>Fast Userspace muTexes</code>，无竞争情况下，能够避免系统调用的开销</p><p><strong>1.自旋锁</strong> (线程直接共享 locked)</p><ul><li>更快的 fast path<ul><li>xchg 成功 → 立即进入临界区，开销很小</li></ul></li><li>更慢的 slow path<ul><li>xchg 失败 → 浪费 CPU 自旋等待</li></ul></li></ul><p><strong>2.睡眠锁</strong> (通过系统调用访问 locked)</p><ul><li>更快的 slow path<ul><li>上锁失败线程不再占用 CPU</li></ul></li><li>更慢的 fast path<ul><li>即便上锁成功也需要进出内核 (syscall)</li></ul></li></ul><p><strong>3.融合</strong>：先原子指令上锁，失败后系统调用睡眠</p><p>线程库的锁就是这样的锁，但还有很多的<strong>优化</strong>以减少系统调用</p><p>code：Kernel为操作系统需要做的，这里使用while模拟</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Futex</span>:<br>    locked, waits = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment"># Model Checker会按行执行，所以这会被视为一个原子操作</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tryacquire</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.locked:<br>            <span class="hljs-comment"># Test-and-set (cmpxchg)</span><br>            <span class="hljs-comment"># Same effect, but more efficient than xchg</span><br>            self.locked = <span class="hljs-string">&#x27;🔒&#x27;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;🔒&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">release</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.waits:<br>            self.waits = self.waits[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">else</span>:<br>            self.locked = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-meta">    @thread</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">t1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> self.tryacquire() == <span class="hljs-string">&#x27;🔒&#x27;</span>:     <span class="hljs-comment"># User</span><br>                self.waits = self.waits + <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-comment"># Kernel</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">in</span> self.waits:      <span class="hljs-comment"># Kernel 实际上这里已经被os剥夺了</span><br>                    <span class="hljs-keyword">pass</span><br>            cs = <span class="hljs-literal">True</span>                         <span class="hljs-comment"># User</span><br>            <span class="hljs-keyword">del</span> cs                            <span class="hljs-comment"># User</span><br>            self.release()                    <span class="hljs-comment"># Kernel</span><br><br><span class="hljs-meta">    @thread</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">t2</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> self.tryacquire() == <span class="hljs-string">&#x27;🔒&#x27;</span>:<br>                self.waits = self.waits + <span class="hljs-string">&#x27;2&#x27;</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">in</span> self.waits:<br>                    <span class="hljs-keyword">pass</span><br>            cs = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">del</span> cs<br>            self.release()<br></code></pre></td></tr></table></figure><p>Fast&#x2F;slow paths:性能优化的途径</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a><a href="http://jyywiki.cn/OS/2022/slides/6.slides">同步</a></h3><p>有了基本的互斥锁，现在需要通过他实现一些线程间的同步机制。有锁时默认使用<code>Futex</code></p><p>线程同步：共同达到互相已知的状态</p><p>生产者消费者(解决并发的万能钥匙)：等价于打印左右括号，左括号往队列加资源，右括号消费资源</p><p><strong>自旋锁、互斥锁、条件变量、信号量、管道(通信)</strong></p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>count计数左括号，是共享资源需要互斥，使用<code>spin lock</code>实现互斥访问count，并且如果不符合条件就反复询问<br>使用管道输入到python程序进行检查</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> n, count = <span class="hljs-number">0</span>;<br>mutex_t lk = MUTEX_INIT();<br><br>void Tproduce() &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>retry:<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">if</span> (count == n) &#123;<br>      mutex_unlock(&amp;lk);<br>      goto retry;<br>    &#125;<br>    count++;<br>    printf(<span class="hljs-string">&quot;(&quot;</span>);<br>    mutex_unlock(&amp;lk);<br>  &#125;<br>&#125;<br><br>void Tconsume() &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>retry:<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>      mutex_unlock(&amp;lk);<br>      goto retry;<br>    &#125;<br>    count--;<br>    printf(<span class="hljs-string">&quot;)&quot;</span>);<br>    mutex_unlock(&amp;lk);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="万能的条件变量"><a href="#万能的条件变量" class="headerlink" title="万能的条件变量"></a>万能的条件变量</h4><p>我希望不要循环，在不满足时进行sleep</p><p>条件变量 API：<strong>在不符合某条件时，等待别人通过cv唤醒我</strong>  cv是程序间的暗号  需要访问共享条件当然要加锁</p><ul><li>wait(cv, mutex) 💤  <code>release(mutex)、sleep</code><ul><li>调用时必须保证已经获得 mutex</li><li>醒来时需要获取mutex</li></ul></li><li>signal&#x2F;notify(cv) 💬 私信：走起<ul><li>如果有线程正在等待 cv，则唤醒其中一个线程</li></ul></li><li>broadcast&#x2F;notifyAll(cv) 📣 所有人：走起<ul><li>唤醒全部正在等待 cv 的线程</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Tproduce</span><span class="hljs-params">()</span> &#123;<br>  mutex_lock(&amp;lk);<br>  <span class="hljs-keyword">if</span> (count == n) cond_wait(&amp;cv, &amp;lk); <span class="hljs-comment">// 睡眠前释放锁；在唤醒后，会重新获取锁</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>); count++; cond_signal(&amp;cv);<br>  mutex_unlock(&amp;lk);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tconsume</span><span class="hljs-params">()</span> &#123;<br>  mutex_lock(&amp;lk);<br>  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) cond_wait(&amp;cv, &amp;lk);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>); count--; cond_signal(&amp;cv);<br>  mutex_unlock(&amp;lk);<br>&#125;<br><br>代码有问题，因为消费者cond_signal(&amp;cv)时会唤醒消费者，因此需要两个条件变量分别用来唤醒P、C<br>或者我直接boradcast唤醒全部，但<span class="hljs-keyword">if</span>检测改成<span class="hljs-keyword">while</span>循环<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConsumer</span>:<br>    locked, count, log, waits = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tryacquire</span>(<span class="hljs-params">self</span>):<br>        self.locked, seen = <span class="hljs-string">&#x27;🔒&#x27;</span>, self.locked<br>        <span class="hljs-keyword">return</span> seen == <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">release</span>(<span class="hljs-params">self</span>):<br>        self.locked = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-meta">    @thread</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tp</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.tryacquire(): <span class="hljs-keyword">pass</span> <span class="hljs-comment"># mutex_lock()</span><br><br>            <span class="hljs-keyword">if</span> self.count == <span class="hljs-number">1</span>:<br>                <span class="hljs-comment"># cond_wait</span><br>                _, self.waits = self.release(), self.waits + <span class="hljs-string">&#x27;1&#x27;</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">in</span> self.waits: <span class="hljs-keyword">pass</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.tryacquire(): <span class="hljs-keyword">pass</span><br><br>            self.log, self.count = self.log + <span class="hljs-string">&#x27;(&#x27;</span>, self.count + <span class="hljs-number">1</span><br>            self.waits = self.waits[<span class="hljs-number">1</span>:] <span class="hljs-comment"># cond_signal</span><br>            self.release() <span class="hljs-comment"># mutex_unlock()</span><br><br><span class="hljs-meta">    @thread</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tc1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.tryacquire(): <span class="hljs-keyword">pass</span><br><br>        <span class="hljs-keyword">if</span> self.count == <span class="hljs-number">0</span>:<br>            _, self.waits = self.release(), self.waits + <span class="hljs-string">&#x27;2&#x27;</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">in</span> self.waits: <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.tryacquire(): <span class="hljs-keyword">pass</span><br><br>        self.log, self.count = self.log + <span class="hljs-string">&#x27;)&#x27;</span>, self.count - <span class="hljs-number">1</span><br><br>        self.waits = self.waits[<span class="hljs-number">1</span>:]<br>        self.release()<br><br><span class="hljs-meta">    @thread</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tc2</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.tryacquire(): <span class="hljs-keyword">pass</span><br><br>        <span class="hljs-keyword">if</span> self.count == <span class="hljs-number">0</span>:<br>            _, self.waits = self.release(), self.waits + <span class="hljs-string">&#x27;3&#x27;</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-keyword">in</span> self.waits: <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> self.tryacquire(): <span class="hljs-keyword">pass</span><br><br>        self.log, self.count = self.log + <span class="hljs-string">&#x27;)&#x27;</span>, self.count - <span class="hljs-number">1</span><br><br>        self.waits = self.waits[<span class="hljs-number">1</span>:]<br>        self.release()<br></code></pre></td></tr></table></figure><p>两个条件变量实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Tproduce</span><span class="hljs-params">()</span> &#123;<br>  mutex_lock(&amp;lk);<br>  <span class="hljs-keyword">if</span> (count == n) cond_wait(&amp;c, &amp;lk); <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>); count++; cond_signal(&amp;p);<br>  mutex_unlock(&amp;lk);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Tconsume</span><span class="hljs-params">()</span> &#123;<br>  mutex_lock(&amp;lk);<br>  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) cond_wait(&amp;p, &amp;lk);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>); count--; cond_signal(&amp;c);<br>  mutex_unlock(&amp;lk);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="while循环-broadcast"><a href="#while循环-broadcast" class="headerlink" title="while循环+broadcast"></a>while循环+broadcast</h5><p>通用模板</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex_lock(&amp;mutex);<br><span class="hljs-keyword">while</span> (!cond) &#123;      cond可以多个条件<br>  wait(&amp;cv, &amp;mutex);<br>&#125;<br>assert(cond);  <span class="hljs-comment">// 互斥锁保证了在此期间条件 cond 总是成立</span><br><br>其他线程条件可能被满足时，就算不满足进入<span class="hljs-keyword">while</span>还是会睡眠<br>broadcast(&amp;cv);<br><br>mutex_unlock(&amp;mutex);<br><br><br><span class="hljs-comment">/// ...计算任务，可能需要更长时间   也就是T(job) &gt;&gt;  T(同步互斥)</span><br></code></pre></td></tr></table></figure><p>作业：打印指定的形状 <code>&lt;&gt;&lt;_</code> 和 <code>&gt;&lt;&gt;_ </code> <a href="http://jyywiki.cn/pages/OS/2022/demos/fish.c">http://jyywiki.cn/pages/OS/2022/demos/fish.c</a></p><p>处理器可以乱序执行，先执行第二条，但13需要顺序执行，硬件实现顺序执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">0</span>   write<br>t = y  <span class="hljs-comment"># 可以先执行</span><br>z = x   read<br></code></pre></td></tr></table></figure><h4 id="信号量PV"><a href="#信号量PV" class="headerlink" title="信号量PV"></a>信号量PV</h4><p>在执行前需要某些东西，没有就睡眠等到有。<code>happens before</code>。<strong>优雅但不全</strong></p><p>最好解决<strong>单一资源</strong>问题，但上面的打印🐟难以实现</p><p>token为资源数量，当token&#x3D;1、0时就代表互斥锁Mutex，没得到就睡眠（但相当于有多把钥匙）</p><p>P： token– if token &lt; 0，线程加入等待队列</p><p>V：token++ if token&lt;&#x3D;0, 唤醒等待队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Semaphore</span>:<br>    token, waits = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">P</span>(<span class="hljs-params">self, tid</span>):<br>        <span class="hljs-keyword">if</span> self.token &gt; <span class="hljs-number">0</span>:<br>            self.token -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            self.waits = self.waits + tid<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">V</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.waits:<br>            self.waits = self.waits[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">else</span>:<br>            self.token += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span> &#123;<br>  P(&amp;empty);   <span class="hljs-comment">// P()返回 -&gt; 得到手环</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>); <span class="hljs-comment">// 假设线程安全</span><br>  V(&amp;fill);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span> &#123;<br>  P(&amp;fill);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br>  V(&amp;empty);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">A -&gt; B      如果使用条件变量，可能出现A已经执行，但B还没进入<br>    s = <span class="hljs-number">0</span><br>    A: V(s)<br>    B: P(S)<br>    <br>join：<br>    s = <span class="hljs-number">0</span><br>    A、B、C: V(s) <br>    main: P(S) * |T|<br></code></pre></td></tr></table></figure><h5 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h5><p>如果想要并行，就需要画出计算图，并让程序按计算图执行：PV很方便</p><p>每条边PV各一次</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404501.png" alt="image-20230526171022426" style="zoom:67%;" /><h5 id="打印🐟"><a href="#打印🐟" class="headerlink" title="打印🐟"></a>打印🐟</h5><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">当前线程想打符号<span class="hljs-string">&#x27;&lt;&#x27;</span> 那就<span class="hljs-function"><span class="hljs-title">P</span>(<span class="hljs-string">&#x27;&lt;&#x27;</span>)</span><br><br>当前线程结束后，根据规则决定谁可以执行 <span class="hljs-function"><span class="hljs-title">V</span>(<span class="hljs-string">&#x27;&gt;&#x27;</span>)   多个就随机</span><br></code></pre></td></tr></table></figure><h5 id="信号量实现条件变量"><a href="#信号量实现条件变量" class="headerlink" title="信号量实现条件变量"></a>信号量实现条件变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">失败：我不能带者锁睡眠，必须要先释放锁，但释放之后不能保证原子性了<br>wait(mutex)&#123;<br>release(mutex)<br><span class="hljs-comment">// 可能被broadcast</span><br>sleep<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>之前实现通信需要共享内存并且锁定，会引发竞争和死锁；因此我们反过来，通过通信来实现共享内存</p><p><code>Do not communicate by sharing memory; instead, share memory by communicating. ——*Effective Go*</code></p><p>管道：不但能同步，还能通信</p><p><code>cat a.txt | wc -l</code> Linux管道就是一种同步机制。 后一个会一边接收一边处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> stream = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">const</span> n = <span class="hljs-number">4</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>    fmt.Println(<span class="hljs-string">&quot;produce&quot;</span>, i)<br>    stream &lt;- i<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    x := &lt;-stream<br>    fmt.Println(<span class="hljs-string">&quot;consume&quot;</span>, x)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>    <span class="hljs-keyword">go</span> produce()<br>  &#125;<br>  consume()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h4><h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>直接上吃饭的条件，并用互斥锁保护起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex_lock(&amp;mutex);<br><span class="hljs-keyword">while</span> (!(avail[lhs] &amp;&amp; avail[rhs])) &#123;<br>  wait(&amp;cv, &amp;mutex);<br>&#125;<br>avail[lhs] = avail[rhs] = <span class="hljs-literal">false</span>;<br>mutex_unlock(&amp;mutex);<br>      <br><span class="hljs-comment">// ...</span><br><br>mutex_lock(&amp;mutex);<br>avail[lhs] = avail[rhs] = <span class="hljs-literal">true</span>;<br>broadcast(&amp;cv);<br>mutex_unlock(&amp;mutex);<br></code></pre></td></tr></table></figure><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 失败的尝试，这里会死锁</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tphilosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>  <span class="hljs-type">int</span> lhs = (N + id - <span class="hljs-number">1</span>) % N;<br>  <span class="hljs-type">int</span> rhs = id % N;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    P(&amp;locks[lhs]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;T%d Got %d\n&quot;</span>, id, lhs + <span class="hljs-number">1</span>);<br>    P(&amp;locks[rhs]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;T%d Got %d\n&quot;</span>, id, rhs + <span class="hljs-number">1</span>);<br>      <br>    <span class="hljs-comment">// ...</span><br><br>    V(&amp;locks[lhs]);<br>    V(&amp;locks[rhs]);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 1.直接锁起来</span><br>mutex_lock(&amp;mutex);<br>P(&amp;locks[lhs]);<br>P(&amp;locks[rhs]);<br>mutex_unlock(&amp;mutex);<br><br><span class="hljs-comment">// 2. 只允许四个人上座 numperson=4   需求变了怎么办？</span><br>P(&amp;numperson);<br>P(&amp;locks[lhs]);<br>P(&amp;locks[rhs]);<br><br><br>V(&amp;numperson);<br></code></pre></td></tr></table></figure><p>需求变了：如果一个人要左边两把右边一把，如何设计？   还是条件变量方便，直接改<code>cond</code>就行</p><h4 id="分布与集中"><a href="#分布与集中" class="headerlink" title="分布与集中"></a>分布与集中</h4><p>集中控制而不是各自协调</p><ul><li>可以知道每一个线程具体运行状况，集中管理</li><li><a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">The Google File System</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Tphilosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>  send_request(id, EAT);<br>  P(allowed[id]); <span class="hljs-comment">// waiter 会把叉子递给哲学家</span><br>  philosopher_eat();<br>  send_request(id, DONE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Twaiter</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    (id, status) = receive_request();<br>    <span class="hljs-keyword">if</span> (status == EAT) &#123; ... &#125;<br>    <span class="hljs-keyword">if</span> (status == DONE) &#123; ... &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>集中的人压力太大？再分级</li></ul><p>信号量可以被操作系统高效实现，避免了broadcast开销</p><h3 id="真实世界的并发编程"><a href="#真实世界的并发编程" class="headerlink" title="真实世界的并发编程"></a>真实世界的并发编程</h3><p><strong>背景回顾</strong>：我们已经掌握了多种并发控制技术：自旋锁、互斥锁、条件变量、信号量。我们已经可以实现共享内存系统上的任意并发&#x2F;并行计算。然而，大家也在使用这些 “底层” 并发控制时发现使用的困难。那么，真实世界的程序员是怎么实现并发程序的？</p><ul><li><strong>高性能计算</strong> (注重任务分解)中的并行编程 (embarrassingly parallel 的数值计算)</li><li><strong>数据中心</strong>(注重系统调用): (协程、Goroutine 和 channel)</li><li>人工智能时代的<strong>分布式机器学习</strong> (GPU 和 Parameter Server)</li><li><strong>用户身边</strong>的并发编程 (Web 和异步编程) (注重易用性)</li></ul><h4 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h4><p>massive computation  源自数值密集型科学计算任务。通常有固定的计算图</p><ul><li>物理系统模拟<ul><li>天气预报、航天、制造、能源、制药、……</li><li>大到宇宙小到量子，有模型就能模拟</li></ul></li><li>矿厂 (现在不那么热了)<ul><li>纯粹的 hash 计算</li></ul></li><li><a href="http://www.hpc100.cn/top100/21/">HPC-China 100</a></li></ul><p><strong>embarrassingly parallel</strong> ：这类问题可以被分解成多个独立的子问题，每个子问题可以在不同的处理器上并行计算，而不需要进行任何进一步的同步或通信。这种问题的并行化非常简单，因为每个子问题都是相互独立的，不需要进行任何协调或同步。</p><p>通常出现在<strong>科学计算、数据分析、图像处理</strong>等领域。例如，在图像处理中，可以将一张大图像分成多个小块，每个小块可以在不同的处理器上并行处理，最后将结果合并成一张完整的图像。在科学计算中，可以将一个大型计算任务分成多个小任务，每个小任务可以在不同的处理器上并行计算，最后将结果合并成一个完整的计算结果。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404502.png" style="zoom: 67%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404503.png" alt="image-20230529102943340" style="zoom: 50%;" />两个线程画图</p><h4 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h4><p><code>“A network of computing and storage resources that enable the delivery of *shared* applications and data.” (CISCO)</code></p><p>以<strong>数据 (存储)</strong> 为中心</p><ul><li>互联网索引与搜索<ul><li>Google</li></ul></li><li>社交网络<ul><li>Facebook&#x2F;Twitter</li></ul></li><li>支撑各类互联网应用<ul><li>通信 (微信&#x2F;QQ 群人数为什么有上限？)、支付 (支付宝)、游戏&#x2F;网盘&#x2F;……</li></ul></li></ul><h5 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h5><p>我希望高可靠、低延时、多副本的分布式 存储 计算系统</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404504.png" alt="image-20230529103310529" style="zoom:67%;" /><p>举个例子：微信先拉黑，再发朋友圈，如果没有一致性，那么朋友圈可能被拉黑的人看到。亚马逊没一致性可能发两个快递</p><h5 id="单机程序"><a href="#单机程序" class="headerlink" title="单机程序"></a><strong>单机程序</strong></h5><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404505.png" alt="image-20230529103721001"></p><p>假设有数千&#x2F;数万个请求同时到达服务器……</p><ul><li>线程能够实现并行处理</li><li>但远多于处理器数量的线程导致性能问题<ul><li>切换开销</li><li>维护开销</li></ul></li></ul><h5 id="协程-协作的线程"><a href="#协程-协作的线程" class="headerlink" title="协程(协作的线程)"></a>协程(协作的线程)</h5><p>和线程概念相同 (独立堆栈、共享内存) ，用户态的线程，由程序员主动控制</p><ul><li>但 “一直执行”，直到 <code>yield()</code>   可以视为<strong>函数调用</strong>， 主动放弃处理器<ul><li>有编译器辅助，切换开销低<ul><li>yield() 是函数调用，只需保存&#x2F;恢复 <code>“callee saved”</code> 寄存器（函数调用保存的寄存器）  <code>RBP</code></li><li>线程切换需要保存&#x2F;恢复全部寄存器</li></ul></li><li>但等待 I&#x2F;O 时，其他协程就不能运行了……<ul><li>失去了并行   go优化</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 只可能是 1122 或 2211</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">T1</span><span class="hljs-params">()</span> &#123; send(<span class="hljs-string">&quot;1&quot;</span>); send(<span class="hljs-string">&quot;1&quot;</span>); yield(); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">T2</span><span class="hljs-params">()</span> &#123; send(<span class="hljs-string">&quot;2&quot;</span>); send(<span class="hljs-string">&quot;2&quot;</span>); yield(); &#125;<br></code></pre></td></tr></table></figure><p><code>Goroutine</code>：概念上是线程，实现上是协程：在遇到IO且可能等待时，<code>yield</code>切换</p><p>如果是协程，线程sleep后计算机就停止了，但go优化成yield切换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">go</span> spinner(<span class="hljs-number">100</span> * time.Millisecond)<br>  <span class="hljs-keyword">const</span> n = <span class="hljs-number">45</span><br>  fibN := fib(n) <span class="hljs-comment">// slow</span><br>  fmt.Printf(<span class="hljs-string">&quot;\rFibonacci(%d) = %d\n&quot;</span>, n, fibN)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinner</span><span class="hljs-params">(delay time.Duration)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> <span class="hljs-string">`-\|/`</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;\r%c&quot;</span>, r)<br>      time.Sleep(delay)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">2</span> &#123; <span class="hljs-keyword">return</span> x &#125;<br>  <span class="hljs-keyword">return</span> fib(x - <span class="hljs-number">1</span>) + fib(x - <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>go之前，java已经形成了大数据处理系统的生态</p><h4 id="人工智能时代的分布式机器学习"><a href="#人工智能时代的分布式机器学习" class="headerlink" title="人工智能时代的分布式机器学习"></a>人工智能时代的分布式机器学习</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404506.png" alt="image-20230529110833871"></p><h5 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h5><p>数据并行：一部分数据这台机器，一部分那台 <code>model = nn.DataParallel(model) </code><br>模型并行：切割计算图</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404507.png" alt="image-20230529111116782"></p><h5 id="SIMP"><a href="#SIMP" class="headerlink" title="SIMP"></a>SIMP</h5><p><code>Single Instruction, Multiple Threads</code></p><p>CPU：多个cpu，但各自运行各自的，都有pc指针</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404509.png" alt="image-20230529112121783"></p><p>GPU：一个pc控制多个执行流，独立寄存器标记线程号</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404510.png" alt="image-20230529112321136" style="zoom:80%;" /><h5 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h5><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404511.png" alt="image-20230529112558826"></p><h5 id="分布式机器学习"><a href="#分布式机器学习" class="headerlink" title="分布式机器学习"></a>分布式机器学习</h5><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404512.png" alt="image-20230529112936378"></p><h4 id="用户身边并发编程"><a href="#用户身边并发编程" class="headerlink" title="用户身边并发编程"></a>用户身边并发编程</h4><p>web2.0：HTML(DOM Tree) + CSS + JS</p><p>特点：不太复杂</p><ul><li>既没有太多计算<ul><li>DOM Tree 也不至于太大 (大了人也看不过来)</li><li>DOM Tree 怎么画浏览器全帮我们搞定了</li></ul></li><li>也没有太多 I&#x2F;O<ul><li>就是一些网络请求</li></ul></li></ul><h5 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h5><p>单线程 + 事件模型</p><ul><li><p>一个线程、按序执行 (run-to-complete)。无并行减少了bug  <strong>主线程执行栈 + 微任务队列</strong></p></li><li><p>耗时的 API (Timer, Ajax, …) 调用会立即返回 + <code>Callback</code></p><ul><li>当Promise被创建时，它处于未完成的状态（pending）。当异步操作完成并且Promise成功解析（resolved）时，或者发生错误导致Promise被拒绝（rejected）时，回调函数会被添加到微任务队列中。</li></ul></li><li><p><strong>坏处</strong>：<code>$.ajax</code> 嵌套 5 层，可维护性已经接近于零了</p></li></ul><h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p><code>Callback</code>没有很好表示流程图 -&gt;  <code>Promise</code></p><p>Chaining</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&quot;/article/promise-chaining/one.js&quot;</span>)<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&quot;/article/promise-chaining/two.js&quot;</span>) )<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&quot;/article/promise-chaining/three.js&quot;</span>) )<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// scripts are loaded, we can use functions declared there</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123; ... &#125; );<br></code></pre></td></tr></table></figure><hr><p>Fork-join</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;A&#x27;</span>) &#125; )<br>b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;B&#x27;</span>) &#125; )<br>c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;C&#x27;</span>) &#125; )<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([a, b, c]).<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) &#125; )<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 封装一个函数，用于加载一张图片</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>    image.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(image); <span class="hljs-comment">// 图片加载成功，将 Promise 标记为成功</span><br>    &#125;;<br>    image.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Failed to load image&#x27;</span>)); <span class="hljs-comment">// 图片加载失败，将 Promise 标记为失败</span><br>    &#125;;<br>    image.<span class="hljs-property">src</span> = url;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 图片加载任务列表</span><br><span class="hljs-keyword">const</span> imageUrls = [<br>  <span class="hljs-string">&#x27;image1.jpg&#x27;</span>,<br>  <span class="hljs-string">&#x27;image2.jpg&#x27;</span>,<br>  <span class="hljs-string">&#x27;image3.jpg&#x27;</span><br>];<br><br><span class="hljs-comment">// 使用 Promise.all() 来处理多个图片加载任务</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(imageUrls.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> <span class="hljs-title function_">loadImage</span>(url)))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">images</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 所有图片加载完成，可以进行展示</span><br>    images.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">image</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(image); <span class="hljs-comment">// 假设将图片添加到页面中</span><br>    &#125;);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 图片加载过程中出现错误</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br><br></code></pre></td></tr></table></figure><h5 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async-Await"></a>Async-Await</h5><p> 一种计算图的描述语言.</p><p>通过使用 <code>async</code> 关键字声明一个函数为异步函数(函数会返回一个<code>Promise</code>对象)，我们可以在函数内部使用 <code>await</code> 关键字来等待一个 Promise 对象的解决（resolve）</p><p>更现代、更优雅的方式来处理异步代码，与 <code>.then</code> 方法相比更易于理解和编写(避免嵌套)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">A = <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> $.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/hello/a&#x27;</span>)<br>B = <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> $.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/hello/b&#x27;</span>)<br>C = <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> $.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/hello/c&#x27;</span>)<br>hello = <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">A</span>(), <span class="hljs-title function_">B</span>(), <span class="hljs-title function_">C</span>()])<br><span class="hljs-title function_">hello</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">alert</span>)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fetch failed!&#x27;</span>) &#125; )<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 异步函数示例</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>    <span class="hljs-keyword">const</span> data = response.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">return</span> data;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Failed to fetch data&#x27;</span>);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 调用异步函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Before fetchData()&#x27;</span>);<br><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data:&#x27;</span>, data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error);<br>  &#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;After fetchData()&#x27;</span>);<br><br><span class="hljs-comment">// res:</span><br>    <span class="hljs-comment">// Before fetchData()</span><br>    <span class="hljs-comment">// After fetchData()</span><br>    <span class="hljs-comment">// Data: [data from API]</span><br></code></pre></td></tr></table></figure><h3 id="并发bug"><a href="#并发bug" class="headerlink" title="并发bug"></a>并发bug</h3><ul><li>死锁</li><li>数据竞争</li><li>原子性和顺序违反</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">assert mode in [XRay, Electron]<br>assert mirror in [On, Off]<br>assert <span class="hljs-title function_">not</span> <span class="hljs-params">(mode == XRay and mirror == Off)</span><br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>表现明显：程序停止了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">lock(&amp;lk);<br><span class="hljs-comment">// lk = LOCKED;</span><br>lock(&amp;lk);<br><span class="hljs-comment">// while (xchg(&amp;lk, LOCKED) == LOCKED) ;</span><br>多层函数调用、隐藏的控制流（中断）<br>        <br>        <br><span class="hljs-type">void</span> <span class="hljs-title function_">Tphilosopher</span><span class="hljs-params">()</span> &#123;<br>  P(&amp;avail[lhs]);<br>  P(&amp;avail[rhs]);<br>  <span class="hljs-comment">// ...</span><br>  V(&amp;avail[lhs]);<br>  V(&amp;avail[rhs]);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Mutual-exclusion - 一张校园卡只能被一个人拥有</li><li>Wait-for - 一个人等其他校园卡时，不会释放已有的校园卡</li><li>No-preemption - 不能抢夺他人的校园卡</li><li>Circular-chain - 形成校园卡的循环等待关系</li></ul><p> <strong>处理方法</strong>：</p><ul><li><strong>预防死锁</strong>（一次性分配资源； 允许抢占； <code>Locker order</code>规定获取锁的顺序，必须从小到大（获得编号最大的进程能运行））</li><li><strong>避免死锁</strong>（<strong>银行家</strong>：在一次分配完后检查是否有安全序列能实现全部运行）</li><li><strong>监测死锁</strong>（<strong>资源分配图</strong>，分配完有没有环）</li><li><strong>解除死锁</strong>（资源剥夺、回滚进程、终止进程）</li></ul><h4 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h4><p>多个线程对同一内存进行读写，先写还是先读产生的结果不同。山寨支付宝判断并修改余额</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404513.png" alt="image-20230530154901555"></p><p>先来先写，多个memory，无法定义谁先来，所以需要避免data race。上锁</p><p><strong>不同的线程</strong>同时访问<strong>同一内存</strong>，且至少有一个是写</p><ul><li>“内存” 可以是地址空间中的任何内存<ul><li>可以是全部变量</li><li>可以是堆区分配的变量</li><li>可以是栈</li></ul></li><li>“访问” 可以是任何代码<ul><li>可能发生在你的代码里</li><li>可以发生在框架代码里</li><li>可能是一行你没有读到过的汇编代码</li><li>可能时一条 ret 指令</li></ul></li></ul><h4 id="原子性违反"><a href="#原子性违反" class="headerlink" title="原子性违反"></a>原子性违反</h4><p>调查100个BUGs，97% 的非死锁并发 bug 都是<strong>原子性</strong>（山寨支付宝）或<strong>顺序错误</strong></p><p> <img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404514.png" alt="image-20230530161346187"></p><h3 id="应对并发bug"><a href="#应对并发bug" class="headerlink" title="应对并发bug"></a>应对并发bug</h3><p>假设程序员会花式犯错</p><p><strong>编译器</strong>：只管翻译代码，不管需求含义</p><p>怎么才能编写出 “正确” (符合 specification) 的程序？</p><ul><li>证明：Annotation verifier (<a href="https://dafny-lang.github.io/dafny/">Dafny</a>), <a href="https://dl.acm.org/doi/10.1145/113446.113468">Refinement types</a></li><li>推测：Specification mining (<a href="http://plse.cs.washington.edu/daikon/">Daikon</a>)</li><li>构造：<a href="https://link.springer.com/article/10.1007/s10009-012-0249-7">Program sketching</a></li><li>编程语言的历史和未来<ul><li>机器语言 → 汇编语言 → 高级语言 → <strong>自然编程语言</strong></li></ul></li></ul><h4 id="防御性编程"><a href="#防御性编程" class="headerlink" title="防御性编程"></a>防御性编程</h4><p>机器永远是对的，代码始终是错的</p><p>防御性编程：把可能不对的情况都检查一遍。<code>assert</code>  大型项目很需要</p><ul><li><p>Peterson 算法中的临界区计数器</p><ul><li><code>assert(nest == 1);</code></li></ul></li><li><p>二叉树的旋转</p><ul><li><code>assert(p-&gt;parent-&gt;left == p || p-&gt;parent-&gt;right == p);</code></li></ul></li><li><p>AA-Deadlock 的检查</p><ul><li><code>if (holding(&amp;lk)) panic();</code></li><li>xv6 spinlock 实现示例</li></ul></li></ul><h4 id="自动运行时检查"><a href="#自动运行时检查" class="headerlink" title="自动运行时检查"></a>自动运行时检查</h4><h5 id="Lockdep死锁检测"><a href="#Lockdep死锁检测" class="headerlink" title="Lockdep死锁检测"></a>Lockdep死锁检测</h5><p><code>Lockdep</code> ：死锁的检查。linux内核</p><p>​每一个锁有一个唯一的site（线程文件行号），上锁解锁日志记录下该site。通过查看所有日志有没有环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lk)</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LOCK   %s\n&quot;</span>, lk-&gt;site);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="data-race检测"><a href="#data-race检测" class="headerlink" title="data race检测"></a>data race检测</h5><p><code>ThreadSanitizer</code>：运行时的数据竞争检查.编译时实现</p><p>两个进程同时读写同一内存，有没有happens-before关系，没有就存在data race (T1-5 T2-5)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404515.png" alt="image-20230531112908484"></p><h4 id="rule-of-thumb"><a href="#rule-of-thumb" class="headerlink" title="rule of thumb"></a>rule of thumb</h4><ul><li>不实现 “完整” 的检查</li><li>允许存在误报&#x2F;漏报</li><li>但实现简单、非常有用</li></ul><h5 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h5><p>“牺牲” 一些内存单元，来预警 memory error 的发生。栈空间多分配一些<code>canary</code>空间作为保护，值被修改了就异常了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAGIC 0x55555555</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOTTOM (STK_SZ / sizeof(u32) - 1)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack</span> &#123;</span> <span class="hljs-type">char</span> data[STK_SZ]; &#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">canary_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">stack</span> *s)</span> &#123;<br>  u32 *ptr = (u32 *)s;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CANARY_SZ; i++)<br>    ptr[BOTTOM - i] = ptr[i] = MAGIC;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">canary_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">stack</span> *s)</span> &#123;<br>  u32 *ptr = (u32 *)s;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CANARY_SZ; i++) &#123;<br>    panic_on(ptr[BOTTOM - i] != MAGIC, <span class="hljs-string">&quot;underflow&quot;</span>);<br>    panic_on(ptr[i] != MAGIC, <span class="hljs-string">&quot;overflow&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>msvc 中 debug mode 的 guard&#x2F;fence&#x2F;canary</p><ul><li>未初始化栈: <code>0xcccccccc </code>  烫</li><li>未初始化堆: <code>0xcdcdcdcd </code> 屯</li><li>对象头尾: <code>0xfdfdfdfd</code></li></ul><h5 id="低配lockdep"><a href="#低配lockdep" class="headerlink" title="低配lockdep"></a>低配lockdep</h5><p>统计自旋的次数，超过某个值肯定不正常</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (xchg(&amp;lk, LOCKED) == LOCKED) &#123;<br>  <span class="hljs-keyword">if</span> (count++ &gt; SPIN_LIMIT) &#123;<br>    panic(<span class="hljs-string">&quot;Spin limit exceeded @ %s:%d\n&quot;</span>, __FILE__, __LINE__);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="低配AddressSanitizer"><a href="#低配AddressSanitizer" class="headerlink" title="低配AddressSanitizer"></a>低配AddressSanitizer</h5><p>并发分配内存时，分配完标记一个颜色</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// allocation</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; (i + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(u32) &lt;= size; i++) &#123;<br>  panic_on(((u32 *)ptr)[i] == MAGIC, <span class="hljs-string">&quot;double-allocation&quot;</span>);<br>  arr[i] = MAGIC;<br>&#125;<br><br><span class="hljs-comment">// free</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; (i + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(u32) &lt;= alloc_size(ptr); i++) &#123;<br>  panic_on(((u32 *)ptr)[i] == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;double-free&quot;</span>);<br>  arr[i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多处理器与中断"><a href="#多处理器与中断" class="headerlink" title="多处理器与中断"></a>多处理器与中断</h3><p>处理器如何实现多线程？中断</p><p><strong>本讲内容</strong>：操作系统内核实现。</p><ul><li>多处理器和中断</li><li>AbstractMachine API</li><li>50 行实现嵌入式操作系统</li></ul><p>多处理器的状态机模型：状态为内存和每一个状态。执行为<strong>任选</strong>一个<code>cpu</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404516.png" alt="image-20230601105219177"></p><p>如果死循环某个CPU就会卡死，而为什么我们写的死循环程序不会卡死电脑？</p><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>下降沿触发的一根线。IF寄存器(interrupter flag) 决定是否响应中断（操作系统可以修改该值）</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404517.png" alt="image-20230601111009780" style="zoom:50%;" /><ul><li>x86 Family<ul><li>询问中断控制器获得中断号 n</li><li>保存 CS, RIP, RFLAGS, SS, RSP 到堆栈</li><li>跳转到 <code>IDT[n]</code> 指定的地址，并设置处理器状态 (例如关闭中断)</li></ul></li></ul><p>关中断实现了 “stop the world”  ，尝试<code>asm volatile (&quot;cli&quot;)</code>被操作系统检测到，会直接报错</p><h4 id="上下文保存"><a href="#上下文保存" class="headerlink" title="上下文保存"></a>上下文保存</h4><p>所有线程都有一块内存用来保存自己的现场</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Context</span> &#123;</span><br>    uint64_ t rax, rbx, rcx, rdx,<br>        rbp, rsi, rdi,<br>        r8，r9，r10, r11,<br>        r12，r13， r14， r15,<br>        rip, cs, rflags,<br>        rsp, ss, rsp0; <br>&#125;;<br></code></pre></td></tr></table></figure><p>中断处理：保存当前的ctx，并返回运行在该cpu上的另一个线程的上下文</p><ul><li><code>tasks[n]</code>是内存中所有线程的状态。next指针把所有状态串联</li><li><code>currents[MAX_CPU]</code> 是每一个cpu当前的状态，都指向tasks中的某一个</li><li><code>current=currents[cpu_current()]</code>是当前cpu状态指针，<code>current-&gt;context = ctx</code>保存现场到内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Task *currents[MAX_CPU];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> current currents[cpu_current()]</span><br><br>Context *<span class="hljs-title function_">on_interrupt</span><span class="hljs-params">(Event ev, Context *ctx)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!current) &#123;<br>    current = &amp;tasks[<span class="hljs-number">0</span>];  <span class="hljs-comment">// First trap for this CPU</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    current-&gt;context = ctx; <span class="hljs-comment">// Keep the stack-saved context</span><br>  &#125;<br><br>  <span class="hljs-comment">// Schedule</span><br>  <span class="hljs-keyword">do</span> &#123;<br>    current = current-&gt;next;<br>  &#125; <span class="hljs-keyword">while</span> (!on_this_cpu(current)); <span class="hljs-comment">// ((current - tasks) % cpu_count() != cpu_current());</span><br><br>  <span class="hljs-keyword">return</span> current-&gt;context;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="50行操作系统"><a href="#50行操作系统" class="headerlink" title="50行操作系统"></a>50行操作系统</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;am.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;klib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;klib-macros.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CPU 8</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">task</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">task</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-type">void</span>      (*entry)(<span class="hljs-type">void</span> *);<br>    Context    *context;<br>  &#125;;<br>  <span class="hljs-type">uint8_t</span> <span class="hljs-built_in">stack</span>[<span class="hljs-number">8192</span>];<br>&#125; Task;  <span class="hljs-comment">// A &quot;state machine&quot;</span><br><br>Task *currents[MAX_CPU];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> current currents[cpu_current()]</span><br><br><span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;  <span class="hljs-comment">// A spin lock</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>   &#123; <span class="hljs-keyword">while</span> (<span class="hljs-type">atomic_xchg</span>(&amp;locked, <span class="hljs-number">1</span>)); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; <span class="hljs-type">atomic_xchg</span>(&amp;locked, <span class="hljs-number">0</span>); &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tasks.h&quot;</span></span><br><br>Context *<span class="hljs-title function_">on_interrupt</span><span class="hljs-params">(Event ev, Context *ctx)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!current) current = &amp;tasks[<span class="hljs-number">0</span>];  <span class="hljs-comment">// First interrupt</span><br>  <span class="hljs-keyword">else</span> current-&gt;context = ctx;  <span class="hljs-comment">// Save pointer to stack-saved context</span><br>  <span class="hljs-keyword">do</span> &#123;<br>    current = current-&gt;next;<br>  &#125; <span class="hljs-keyword">while</span> ((current - tasks) % cpu_count() != cpu_current());<br>  <span class="hljs-keyword">return</span> current-&gt;context;  <span class="hljs-comment">// Restore a new context</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mp_entry</span><span class="hljs-params">()</span> &#123;<br>  yield();  <span class="hljs-comment">// Self-trap; never returns</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  cte_init(on_interrupt);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(tasks); i++) &#123;<br>    Task *task    = &amp;tasks[i];<br>    Area <span class="hljs-built_in">stack</span>    = (Area) &#123; &amp;task-&gt;context + <span class="hljs-number">1</span>, task + <span class="hljs-number">1</span> &#125;; <span class="hljs-comment">// 栈起始结束地址</span><br>    task-&gt;context = kcontext(<span class="hljs-built_in">stack</span>, task-&gt;entry, (<span class="hljs-type">void</span> *)task-&gt;name); <br>    task-&gt;next    = &amp;tasks[(i + <span class="hljs-number">1</span>) % LENGTH(tasks)];<br>  &#125;<br>  mpe_init(mp_entry);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// User-defined tasks</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    lock();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread-%s on CPU #%d\n&quot;</span>, arg, cpu_current());<br>    unlock();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-keyword">volatile</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) ;<br>  &#125;<br>&#125;<br><br>Task tasks[] = &#123;<br>  &#123; .name = <span class="hljs-string">&quot;A&quot;</span>, .entry = func &#125;,<br>  &#123; .name = <span class="hljs-string">&quot;B&quot;</span>, .entry = func &#125;,<br>  &#123; .name = <span class="hljs-string">&quot;C&quot;</span>, .entry = func &#125;,<br>  &#123; .name = <span class="hljs-string">&quot;D&quot;</span>, .entry = func &#125;,<br>  &#123; .name = <span class="hljs-string">&quot;E&quot;</span>, .entry = func &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="fork-execv-exit"><a href="#fork-execv-exit" class="headerlink" title="fork execv exit"></a>fork execv exit</h3><ul><li>应用程序 &#x3D; 纯粹计算（Python 代码） + <code>syscall</code>；  状态机</li><li>操作系统 &#x3D; <code>syscall</code>实现：重要的三个系统调用<ul><li>fork: 对当前状态机状态进行完整复制</li><li>execve: 将当前状态机状态重置为某个可执行文件描述的状态机</li><li>exit: 销毁当前状态机</li></ul></li></ul><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p><code>fork</code>: <strong>完全</strong>复制一份当前的状态 (内存、寄存器现场)，相当于创建了一个新的进程，返回子进程号。<code>unix</code>唯一方法</p><p>因为状态机是复制的，因此总能找到 “父子关系”</p><ul><li>因此有了进程树 (<code>pstree</code>)</li></ul><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">systemd-+-ModemManager--<span class="hljs-number">-2</span>*[&#123;ModemManager&#125;]<br>        |<span class="hljs-type">-NetworkManager</span>--<span class="hljs-number">-2</span>*[&#123;NetworkManager&#125;]<br>        |<span class="hljs-type">-accounts</span>-daemon--<span class="hljs-number">-2</span>*[&#123;accounts-daemon&#125;]<br>        |<span class="hljs-type">-at</span>-spi-bus-laun-+-dbus-daemon<br>        |                 <span class="hljs-type">`-3</span>*[&#123;<span class="hljs-built_in">at</span>-spi-bus-laun&#125;]<br>        |<span class="hljs-type">-at</span>-spi2-registr--<span class="hljs-number">-2</span>*[&#123;<span class="hljs-built_in">at</span>-spi2-registr&#125;]<br>        |<span class="hljs-type">-atd</span><br>        |<span class="hljs-type">-avahi</span>-daemon---avahi-daemon<br>        |<span class="hljs-type">-colord</span>--<span class="hljs-number">-2</span>*[&#123;colord&#125;]<br>        ...<br></code></pre></td></tr></table></figure><p>1个变成了4个。fork出来的子进程也会执行下面的fork(), 除了x不一样其他都一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> x = fork();<br><span class="hljs-type">pid_t</span> y = fork();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, x, y);<br></code></pre></td></tr></table></figure><p>打印了多少个？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>  fork();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>);<br>&#125;<br><br>./a.out          <span class="hljs-number">6</span>个<br>./a.out | cat    <span class="hljs-number">8</span>个  因为如果输入到管道，print的信息会放到缓存中，被同时复制<br></code></pre></td></tr></table></figure><h4 id="execv"><a href="#execv" class="headerlink" title="execv"></a>execv</h4><p><code>execv</code> ：</p><ul><li>将当前进程<strong>重置</strong>成一个可执行文件描述状态机的初始状态</li><li>唯一能够执行程序的系统调用，一切程序的<strong>起点</strong>（fork是父进程调用的）</li><li>传入<strong>参数</strong>和<strong>环境变量</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename,</span><br><span class="hljs-params">           <span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> * <span class="hljs-type">const</span> envp[])</span>;<br><br>ls -al <br><span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-string">&quot; /usr/bin/ls&quot;</span>, [<span class="hljs-string">&quot;ls&quot;</span>， <span class="hljs-string">&quot;-al&quot;</span>]， <span class="hljs-number">0x7ffeaabcda88</span> <span class="hljs-comment">/* 54 vars */</span>)</span> = <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p>环境变量，默认继承父进程</p><ul><li>使用<code>env</code>命令查看<ul><li><code>PATH</code>: 可执行文件搜索路径</li><li><code>PWD</code>: 当前路径</li><li><code>HOME</code>: home 目录</li><li><code>DISPLAY</code>: 图形输出</li><li><code>PS1</code>: shell 的提示符</li></ul></li><li><code>export</code>: 告诉 shell 在创建子进程时设置环境变量<ul><li>小技巧：<code>export ARCH=x86_64-qemu</code> 或 <code>export ARCH=native</code></li></ul></li></ul><p>strace gcc  gcc会先去找可执行的<code>as</code>汇编器程序，去path里找，所以会输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">pid 28369</span>] execve(<span class="hljs-string">&quot;/usr/local/sbin/as&quot;</span>, [<span class="hljs-string">&quot;as&quot;</span>, <span class="hljs-string">&quot;--64&quot;</span>, ...<br>[<span class="hljs-meta">pid 28369</span>] execve(<span class="hljs-string">&quot;/usr/local/bin/as&quot;</span>, [<span class="hljs-string">&quot;as&quot;</span>, <span class="hljs-string">&quot;--64&quot;</span>, ...<br>[<span class="hljs-meta">pid 28369</span>] execve(<span class="hljs-string">&quot;/usr/sbin/as&quot;</span>, [<span class="hljs-string">&quot;as&quot;</span>, <span class="hljs-string">&quot;--64&quot;</span>, ...<br>[<span class="hljs-meta">pid 28369</span>] execve(<span class="hljs-string">&quot;/usr/bin/as&quot;</span>, [<span class="hljs-string">&quot;as&quot;</span>, <span class="hljs-string">&quot;--64&quot;</span>, ..<br></code></pre></td></tr></table></figure><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> _exit(<span class="hljs-type">int</span> status)<br>    销毁当前状态机，并允许有一个返回值<br>    子进程终止会通知父进程 (后续课程解释)<br></code></pre></td></tr></table></figure><p> exit 的几种写法 (它们是不同)</p><ul><li>exit(0)   stdlib.h中声明的 libc 函数<ul><li>会调用 <code>atexit</code></li></ul></li><li><code>_exit(0)</code>  glibc 的 syscall wrapper<ul><li>执行 “exit_group” 系统调用终止整个进程 (所有线程)<ul><li>细心的同学已经在 strace 中发现了</li></ul></li><li>不会调用 <code>atexit</code></li></ul></li><li><code>syscall(SYS_exit, 0)</code><ul><li>执行 “<code>exit</code>” 系统调用终止当前线程</li><li>不会调用 <code>atexit</code></li></ul></li></ul><h4 id="shell中运行-x2F-a-out"><a href="#shell中运行-x2F-a-out" class="headerlink" title="shell中运行.&#x2F;a.out:"></a>shell中运行.&#x2F;a.out:</h4><ol><li>Shell解析命令行输入，发现<code>./a.out</code>是一个可执行文件。</li><li>Shell调用<code>fork()</code>系统调用，创建一个新的子进程。子进程复制父进程的所有资源和代码段。</li><li>子进程调用<code>execve()</code>系统调用，加载并执行<code>a.out</code>可执行文件。<ol><li>如果可执行文件需要进行系统调用，例如读取文件或写入文件，它会使用相应的系统调用，如<code>open()</code>、<code>read()</code>、<code>write()</code>等。</li><li>当可执行文件执行完毕或调用了<code>exit()</code>系统调用来终止进程时，进程会返回到Shell。</li></ol></li><li>shell <code>wail()</code>等待子进程(如果后台运行<code>&amp;</code>就不会等待)</li></ol><p>Shell本身也是一个进程<code>/bin/bash</code>，初始状态读取配置文件<code>~/.bashrc</code>。输入：</p><ul><li>执行内部命令（例如<code>cd</code>或<code>echo</code>）</li><li>执行系统命令（例如<code>ls</code>或<code>grep</code>）（本质上也是可执行文件）</li><li>可执行文件</li></ul><h3 id="Linux中的init"><a href="#Linux中的init" class="headerlink" title="Linux中的init"></a>Linux中的init</h3><ul><li>Linux 操作系统</li><li>Linux 系统启动和 initramfs</li><li>Linux 应用世界的构建</li></ul><p>just for fun</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Hello, everybody out there using minix – I’m doing a (free) operating system (<span class="hljs-keyword">just </span>a hobby, won’t <span class="hljs-keyword">be </span><span class="hljs-keyword">big </span><span class="hljs-keyword">and </span>professional like gnu) for <span class="hljs-number">386</span>(<span class="hljs-number">486</span>) <span class="hljs-built_in">AT</span> <span class="hljs-keyword">clones. </span>This has <span class="hljs-keyword">been </span><span class="hljs-keyword">brewing </span>since April, <span class="hljs-keyword">and </span>is starting to get ready.<br>—— Linus Torvalds (时年 <span class="hljs-number">21</span> 岁)<br></code></pre></td></tr></table></figure><p><code>Minix</code>: 完全用于教学的真实操作系统 1987。Andrew Tanenbaum。  <code>Linux</code> 的起点</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404518.png" alt="image-20230604102002909"></p><h4 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h4><ul><li>加载第一个进程<ul><li>相当于在操作系统中 “放置一个位于初始状态的状态机” **init **    <strong>systemd</strong> </li><li>Single user model (高权限)</li></ul></li><li>包含一些进程可操纵的操作系统对象</li><li>除此之外 “什么也没有”<ul><li>Linux 变为一个中断 (系统调用) 处理程序</li></ul></li></ul><p>Linux Kernel 系统调用上的发行版和应用生态</p><ul><li>系统工具 <a href="https://www.gnu.org/software/coreutils/coreutils.html">coreutils</a>, <a href="https://www.gnu.org/software/binutils/">binutils</a>, <a href="https://systemd.io/">systemd</a>, …</li><li>桌面系统 Gnome, xfce, Android</li><li>应用程序 file manager, vscode, …</li></ul><h4 id="第一个状态机"><a href="#第一个状态机" class="headerlink" title="第一个状态机"></a>第一个状态机</h4><p>1.我们可以控制init程序是谁，比如最简单的<code>helloword</code>。当<code>helloword</code> 退出后，也就是杀死最后一个进程，Kernel panic</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">INIT := /init<br><span class="hljs-comment"># INIT := /minimal</span><br><br>run:<br><span class="hljs-comment"># Run QEMU with the installed kernel and generated initramfs</span><br>qemu-system-x86_64 \<br>  -serial mon:stdio \ <br>  -kernel build/vmlinuz \<br>  -initrd build/initramfs.cpio.gz \<br>  -machine accel=kvm:tcg \<br>  -append <span class="hljs-string">&quot;console=ttyS0 quiet rdinit=<span class="hljs-subst">$(INIT)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>2.改回启动Init程序，其中<code>busybox</code> 是一个程序，但包含很多文件 5000行     <code>busybox  vi</code>      <code>busybox  sh</code>，因此我们的init程序就可以使用命令了，再通过软连接就可以直接执行了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/busybox sh</span><br><br><span class="hljs-comment"># initrd, only busybox and /init</span><br>BB=/bin/busybox<br><br><span class="hljs-comment"># (1) Print something and exit</span><br><span class="hljs-variable">$BB</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31mHello, OS World\033[0m&quot;</span><br><span class="hljs-variable">$BB</span> poweroff -f<br><br><span class="hljs-comment"># (2) Run a shell on the init console</span><br><span class="hljs-variable">$BB</span> sh<br><br><span class="hljs-comment"># (3) Rock&#x27;n Roll!</span><br><span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> $(<span class="hljs-variable">$BB</span> --list); <span class="hljs-keyword">do</span><br>  <span class="hljs-variable">$BB</span> <span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$BB</span> /bin/<span class="hljs-variable">$cmd</span><br><span class="hljs-keyword">done</span><br>    <span class="hljs-comment"># /bin/ls -&gt; /bin/busybox</span><br>    <span class="hljs-comment"># /bin/cat -&gt; /bin/busybox</span><br>    <span class="hljs-comment"># /bin/grep -&gt; /bin/busybox</span><br><span class="hljs-built_in">mkdir</span> -p /tmp<br><span class="hljs-built_in">mkdir</span> -p /proc &amp;&amp; mount -t proc  none /proc<br><span class="hljs-built_in">mkdir</span> -p /sys  &amp;&amp; mount -t sysfs none /sys<br><span class="hljs-built_in">mknod</span> /dev/tty c 4 1<br>setsid /bin/sh &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>至此我们通过init启动了一个独立sh，sh中可以执行我们的指令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">如果我们放一个<span class="hljs-keyword">vi</span> &amp; 在后台<br># pstree<br>init---<span class="hljs-keyword">sh</span>---pstree<br>           -<span class="hljs-keyword">vi</span><br>           <br>指令都是指向busybox，busybox通过系统调用的参数(执行的名称)实现不同的命令<br></code></pre></td></tr></table></figure><h4 id="其他工作"><a href="#其他工作" class="headerlink" title="其他工作"></a>其他工作</h4><p>只是一个内存里的小文件系统</p><ul><li>我们 “看到” 的都是被 init 创造出来的<ul><li>加载剩余必要的驱动程序，例如网卡</li><li>根据 fstab 中的信息挂载文件系统，例如网络驱动器</li><li>将根文件系统和控制权移交<code>pivot_root</code>给另一个程序，例如 systemd</li></ul></li></ul><h3 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h3><p>进程的状态由 (M,R) 组成，R为体系结构中决定的，M的具体实现？</p><h4 id="地址空间内容"><a href="#地址空间内容" class="headerlink" title="地址空间内容"></a>地址空间内容</h4><p><code>pmap pid</code>   读取<code>/proc/pid/maps</code>   <code>strace</code>跟踪可以证明</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 一大堆内存，有的rx为代码pc访问  有的r(字符串常量)  有的rw(变量 栈)</span><br>12345:   executable_program<br>Address           Kbytes     RSS   Dirty Mode   Mapping<br>0000000000400000    2048     976     976 r-x--  executable_program<br>0000000000600000    1024     512     512 rw---  executable_program<br>0000000000700000    4096    2048    2048 rw---    [ anon ]<br>00007f9a28345000    4096    2048    2048 r-x--  libc.so.6<br>00007f9a283d4000    2048       0       0 -----  libc.so.6<br>00007f9a285d4000      16      12       0 r----  libc.so.6<br>00007f9a285d8000       4       4       4 rw---  libc.so.6<br>00007f9a285d9000      16       4       4 rw---    [ stack ]<br><br><span class="hljs-comment"># 猜测对不对的上？ 加一些变量代码，然后调试</span><br></code></pre></td></tr></table></figure><p>如果是动态链接呢？有一个加载的过程，在<code>main</code>之前把动态链接库（如libc.so.6）加载到地址空间中</p><p> 系统调用需要陷入内核，但有些简单的(只读的)可以不用陷入内核执行</p><ul><li><code>vvar</code> ：Virtual Variable  存储内核和用户空间之间共享的变量。这些变量包括与时间相关的信息、线程特定的数据等。</li><li><code>vdso</code>：取这些信息的代码，<strong>不进入内核的系统调用</strong></li></ul><h4 id="空间的管理"><a href="#空间的管理" class="headerlink" title="空间的管理"></a>空间的管理</h4><p>程序空间是变化的：操作系统应该提供一个<strong>修改进程地址空间的系统调用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 映射  fd文件描述符 offset偏移量，提供时把文件内容加载到内存</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br><span class="hljs-comment">// 为 malloc/free 提供了机制</span><br><br><span class="hljs-comment">// 修改映射权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot)</span>;<br></code></pre></td></tr></table></figure><p>分配8G(可以超过内存)会直接分配，使用时才加入内存发生缺页中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GiB * (1024LL * 1024 * 1024)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *p = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">8</span> GiB, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mmap: %lx\n&quot;</span>, (<span class="hljs-type">uintptr_t</span>)p);<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">intptr_t</span>)p == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;cannot map&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  *(p + <span class="hljs-number">2</span> GiB) = <span class="hljs-number">1</span>;<br>  *(p + <span class="hljs-number">4</span> GiB) = <span class="hljs-number">2</span>;<br>  *(p + <span class="hljs-number">7</span> GiB) = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">4</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">6</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">7</span> GiB));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Memory-Mapped File</strong>: 一致性：什么时候将修改写入磁盘？多进程如何共享？</p><h4 id="入侵地址空间"><a href="#入侵地址空间" class="headerlink" title="入侵地址空间"></a>入侵地址空间</h4><p>入侵地址空间就是可以任意操控其他进程</p><ul><li>调试器 (gdb)<ul><li>gdb 可以任意观测和修改程序的状态</li></ul></li><li>Profiler (perf)<ul><li>合理的需求，操作系统就必须支持</li></ul></li></ul><h5 id="金手指"><a href="#金手指" class="headerlink" title="金手指"></a>金手指</h5><p>物理劫持</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404519.png" alt="image-20230605105022909"></p><h5 id="金山游侠"><a href="#金山游侠" class="headerlink" title="金山游侠"></a>金山游侠</h5><p>入侵地址空间，修改<strong>金钱</strong>、<strong>生命</strong>属性</p><p>任何操作系统肯定提供了gdb</p><p>原理为<code>pmap</code>读取内存的内容并修改</p><p>代码扫描所有地址，找出金钱为3000的，消耗一些后找出价钱为2700的，这些地址值都修改就可以修改金钱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-type">long</span> val;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">game</span> <span class="hljs-title">game</span>;</span><br><br>  <span class="hljs-keyword">if</span> (load_game(&amp;game, argv[<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (!feof(<span class="hljs-built_in">stdin</span>)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%s %d) &quot;</span>, game.name, game.pid);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> release;<br><br>    <span class="hljs-keyword">switch</span> (buf[<span class="hljs-number">0</span>]) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-keyword">goto</span> release; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); game.bits = val; reset(&amp;game); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); scan(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); overwrite(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>: reset(&amp;game); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>release:<br>  close_game(&amp;game);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="按键精灵"><a href="#按键精灵" class="headerlink" title="按键精灵"></a>按键精灵</h5><p>大量重复固定任务。这个简单，就是给进程发送键盘&#x2F;鼠标事件</p><ul><li>做个驱动 (可编程键盘&#x2F;鼠标)</li><li>利用操作系统&#x2F;窗口管理器提供的 API<ul><li><a href="https://github.com/jordansissel/xdotool">xdotool</a> (我们用这玩意测试 vscode 的插件)</li><li><a href="https://www.kernel.org/doc/html/latest/input/input.html">evdev</a> (按键显示脚本；主播常用)</li></ul></li></ul><h5 id="变速齿轮"><a href="#变速齿轮" class="headerlink" title="变速齿轮"></a>变速齿轮</h5><p>跳转游戏逻辑更新速度</p><p>程序只是状态机，除了<code>syscall</code>无法感知时间。修改<code>syscall</code>返回值就可以欺骗程序。</p><h5 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 修改 API 调用的值</span><br>set_alarm(<span class="hljs-number">1000</span> / FPS); <span class="hljs-comment">// 希望改成 100 / FPS</span><br><br><span class="hljs-comment">// 锁定生命值</span><br>hp -= damage; <span class="hljs-comment">// 希望 “消除” 此次修改</span><br><span class="hljs-keyword">if</span> (hp &lt; <span class="hljs-number">0</span>) game_over();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>穿越计算机的迷雾</title>
    <link href="/2023/05/12/%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE/"/>
    <url>/2023/05/12/%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="bit入门"><a href="#bit入门" class="headerlink" title="bit入门"></a>bit入门</h3><p>如何用电来表达一个数字：</p><ul><li>1v为1  、2v为2… 但难以计算到底是几v</li><li>开关，0代表无 1代表有。二进制</li></ul><p>如何对二进制实现加法</p><ul><li>对于每一位<ul><li>两个输入一个进位</li><li>一个输出一个进位</li></ul></li><li>多位串联起来<ul><li>低位的进位传递给高位</li></ul></li></ul><h3 id="电与磁"><a href="#电与磁" class="headerlink" title="电与磁"></a>电与磁</h3><p>电能生磁，通过电流通断规律控制衔铁臂上下运动画出莫尔斯电报</p><p>​距离太远？继电器实现不同回路的继电</p><p>磁生电，线圈切割磁感线产生电流：<strong>话筒</strong>  声波-&gt;电流     <strong>扬声器</strong> 电流-&gt;声波   二者可以是同一个东西</p><p>为什么是交流电</p><ul><li>产生更容易，圆周运动</li><li>通过变压器轻松实现升降压，而高压传输损耗更小</li></ul><h3 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h3><ul><li><a href="https://fasionchan.com/computer/logic-gate/relay-logic-gate/">用电磁继电器实现逻辑门</a> 非(1)、与(2)、或(2)、与非(2)、异或门(<code>!AB+A!B</code>两非两与一或&#x3D;8、或 与非 与 &#x3D; 6)</li></ul><p>同门电路<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450617.png" alt="image-20230511153924305"></p><p>与非<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450618.png" alt="image-20230511154215546" style="zoom: 67%;" /></p><p>异或门</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450619.png" alt="image-20230511152444206" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450620.png" alt="image-20230511152733412"></p><ul><li><p>对全加器列出真值表，化简出逻辑表达式，并使用继电器构造出来，22个-&gt;18个  1940年计数器</p><p><code>S = A ⊕ B ⊕ Cin</code></p><p><code>Cout = (A B) + (Cin (A ⊕ B))</code></p></li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450621.png" alt="image-20230511151739600" style="zoom:80%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450622.png" alt="image-20230511172429980"></p><p>至此我们得到了<strong>运算器</strong></p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>为了记录下1bit！！！(后面采用电容存储1bit(DARM 内存；晶体管做触发器SRAM cache))</p><p>二极管：加热的灯丝可以放出电子</p><p>三极管：中间增加一个栅极，可以截断或者放大</p><p><strong>振荡器：</strong>把一个非门的输出接到输入</p><h4 id="触发器："><a href="#触发器：" class="headerlink" title="触发器："></a><strong>触发器：</strong></h4><p>​输出永远相反，而当输入只有一个1时，可以改变输出状态(输入期望也相反)   问题：我只想在想记录时记录</p><p>​输入S置为一后，Q一直会保持1，R(reset)可以将Q置零。都为1不稳定</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450623.png" alt="image-20230511163751743"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450624.png" alt="image-20230511164109382" style="zoom:67%;" /></p><h4 id="D触发器："><a href="#D触发器：" class="headerlink" title="D触发器："></a><strong>D触发器：</strong></h4><p>​增加一个控制端，实现1bit的保存。CP为1时，Q&#x3D;D保存输入，CP为0时，忽略</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450625.png" alt="image-20230511165325821"></p><h4 id="上升沿D触发器："><a href="#上升沿D触发器：" class="headerlink" title="上升沿D触发器："></a><strong>上升沿D触发器</strong>：</h4><p>​CP为上升信号时，触发保存。对于继电器，一次记录可能需要延时1s</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450627.png" alt="image-20230511165731250"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450628.png" alt="image-20230511170247155"></p><h4 id="走马灯：移位寄存器"><a href="#走马灯：移位寄存器" class="headerlink" title="走马灯：移位寄存器"></a><strong>走马灯：移位寄存器</strong></h4><p>​（移位寄存器）振荡器 + 循环连接的上升沿触发器，其中有一个1；每震荡一次1就传递给下一个。<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450629.png" alt="image-20230511170124003"></p><h4 id="寄存器：多个上升D"><a href="#寄存器：多个上升D" class="headerlink" title="寄存器：多个上升D"></a><strong>寄存器：</strong>多个上升D</h4><p>多个CP就可以构成寄存器存储数据</p><h4 id="T触发器："><a href="#T触发器：" class="headerlink" title="T触发器："></a><strong>T触发器：</strong></h4><p>​反转</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450630.png" alt="image-20230511170310516"></p><p>​串联： 二进制计数器，计算上升沿的数量</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450631.png" alt="image-20230511172102638"></p><p>至此我们得到了寄存器，能够缓存一部分数据。</p><p>继电器  -&gt;电子管  -&gt; 晶体管  -&gt;  集成电路</p><h3 id="一连串加法"><a href="#一连串加法" class="headerlink" title="一连串加法"></a>一连串加法</h3><p>之前的加法器只能保证两个输入得到一个输出，但不能连续计算。结合寄存器优化！！</p><p>1.基本思想：使用寄存器保存值，一个数为直接输入，另一个为RA寄存器的值。加法器会<strong>实时</strong>计算两个输入的值</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450632.png" alt="image-20230511190342020"></p><p>2.为了实现连续计算，加法器的输出要直接接到输入</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450633.png" alt="image-20230511190457135"></p><p>​<strong>问题：</strong>共用一条线（<strong>总线</strong>）会冲突，需要添加控制实现轮流使用总线</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450634.png" alt="image-20230511190610102" style="zoom:67%;" /><p>3.添加上总线控制GA，GB，总线控制是<strong>按住</strong>，而寄存器装载是上升沿<strong>按下松开</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450635.png" alt="image-20230511190438862"></p><p>10+3+2</p><p>第一步为装载，2~3为相加</p><ol><li>扳出10（在实际中，取数也是一个自动操作 后面实现），按住GA，延时后按下RA，装载输入1的值为10  </li><li>扳出3， 按住GA，这时候加法器已经得到了实时输出，按下TR，装载输出到寄存器</li><li>再按住GB，代表输出需要占用总线，数据传输到RA时按下RA装载结果，实现一次计算</li><li>重复2过程，扳出数字2…</li></ol><p>4.添加一个<strong>控制器</strong>控制，列出真值表，即可得到控制器电路（K的状态相当于指令，控制器电路需要解析指令）。延时问题后面解决</p><ul><li>上面两个为模式，选择一个</li><li>下面两个为当前模式下的操作，k0~x只有一个为1</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450636.png" alt="image-20230511195305178"></p><p>5.控制器优化，只使用一个控制</p><ol><li><p>既然操作t只有一个为1，那么用循环移位寄存器RR实现</p></li><li><p>延时问题，我现在先让G(控制线先输出)，而数据寄存器R需要再按下开关时才触发</p><p>   松开开关代表切换操作，松开状态下数据参数门打开</p><p>   松开后再按下代表上一个数据已经传过来了，要用快点用，按下瞬间装载数据</p><p>也就是松开实现模式切换，按下实现数据保存</p></li></ol><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450637.png" alt="image-20230511195839855"></p><h3 id="全自动加法"><a href="#全自动加法" class="headerlink" title="全自动加法"></a>全自动加法</h3><p>现在还需要手动将数据输入，能不能一次性全部输入：需要先存储  <strong>存储器！！</strong></p><p>单bit存储：输入和输出共用一条线，通过信号控制输入还是输出，G就相当于总线控制(输出器)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450638.png" alt="image-20230511193329800"></p><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>把多个bit连一起就可以组成一个大数（一行），多个数就可以组成存储器，需要地址译码器选择哪个数据(门牌号)</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450639.png" alt="image-20230511193502167" style="zoom:67%;" /><p>封装一下：输入：地址引线 RW ， 输出n个bit</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450640.png" alt="image-20230511193521662" style="zoom:50%;" /><h4 id="磁芯"><a href="#磁芯" class="headerlink" title="磁芯"></a>磁芯</h4><p>W：不同的电流方向导致不同的磁场方向</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450641.png" alt="image-20230511193659896" style="zoom:50%;" /><p>R：写入一个0，如果原来是0，读出线上电压变化很小。如果原来是1，磁场变化导致读出线上感应电压大</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450642.png" alt="image-20230511193820128" style="zoom:50%;" /><p>1949年10月21磁芯存储器专利</p><h4 id="自动取数"><a href="#自动取数" class="headerlink" title="自动取数"></a>自动取数</h4><p>需要一个计数器ACC，AR寄存计数器的值<strong>（地址寄存器）</strong>，DR寄存数据<strong>（数据寄存器）</strong></p><ol><li>按下K<del>AR</del>锁存当前地址</li><li>按住K<del>RD</del>读取数据，同时按下KDR寄存数据</li><li>按下K<del>AC</del>实现地址增加</li></ol><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450643.png" alt="image-20230511201809307"></p><p>同样使用一个循环移位1器和译码器实现上面的逻辑结构，至此按下三下即可取出一个数据到DR寄存器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450644.png" alt="image-20230511202034724"></p><h4 id="连接加法器"><a href="#连接加法器" class="headerlink" title="连接加法器"></a>连接加法器</h4><p>加法器包含2个操作，存储器包含三个，一共五个</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450645.png" alt="image-20230511202615465"></p><p>将相加还是装载添加到指令中，指令也是从存储器中取，指令通过<strong>EC解析</strong>后，翻译出当前的任务，反过来<strong>影响译码器</strong>，也就是告诉计算机进行的下一步操作。IR + EC + 译码器相当于是控制器</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450646.png" alt="image-20230511203156283" style="zoom:50%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450647.png" alt="image-20230511203046934"></p><p>现代的指令中，数据可以直接包含在指令中。原来的AC更像是现代中的PC指针，指向指令的位置</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450648.png" alt="image-20230511203602817"></p><p>最后，把手动按下K换成一个振荡器，即可实现全自动。需要添加一个中止指令，代表程序结束了</p><p>如何处理进位？额外产生一个进位标志来影响控制器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450649.png" alt="image-20230512122031198"></p><h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><p>SRAM：使用晶体管构建触发器，形成存储器，SRAM，但太贵了6个晶体管一个bit，只用来做cache</p><p>DRAM：使用电容和晶体三极管，2ms刷新一次DRAM，做内存</p><p>ROM：一开始只读，然后可擦除。U盘、固态硬盘</p><p>外存：磁芯 —&gt;  磁盘(机械硬盘 磁头+ 磁道 + 扇区) —&gt;  固态硬盘</p><p>流水线：充分利用CPU和内存，错开执行 取指 译码 运算 写回操作</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450650.png" alt="image-20230512125603868"></p><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>CPU从哪里读取数据：IO接口</p><p>什么时候去读：CPU不知道IO接口到底有没有数据</p><ul><li>不停的读：CPU不能干别的事情了</li><li>定时询问</li><li>中断：中断向量号表示谁请求了中断，再根据中断向量表转到相应中断处理逻辑</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B站秒杀项目</title>
    <link href="/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="B站秒杀项目"><a href="#B站秒杀项目" class="headerlink" title="B站秒杀项目"></a>B站秒杀项目</h1><p><a href="https://www.bilibili.com/video/BV1sf4y1L7KE">视频</a></p><ul><li>前后端结合项目，两种处理页面方式，二者对比可以看orderDetail页面</li><li>前端页面在template下，通过controller返回访问，并<code>model.add添加数据</code>。<code>h:text=&quot;$&#123;goods.goodsName&#125;&quot;</code>区数据， 不可直接访问</li><li>在static下的页面可直接访问，并在页面加载时ajax请求返回json数据，<code>$(&quot;#goodsName&quot;).text(goods.goodsName);</code>根据id注入数据。（代码中的方式，相当于静态化了，视频中一开始是上面的方式，后面才做的静态化）</li></ul><p>秒杀的接口有三个，先在goodsdetail中启用doSeckill1</p><ul><li>doSeckill1:  对应到 <strong>P43</strong>，         update排他+唯一索引实现秒杀(没有做order页面静态化)</li><li>doSeckill2：对应到 <strong>P53</strong>，         order界面静态化 +  redis预减库存 + 内存标记 + MQ</li><li>doSeckill ：最终秒杀方案          一些安全上的优化</li></ul><p>对应到发起请求界面static\goodsDetail.html 52~67行</p><h2 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h2><ol><li>项目框架搭建<ol><li>SpringBoot环境搭建</li><li>集成Thymeleaf,RespBean</li><li>MyBatis</li></ol></li><li>分布式会话<ol><li>用户登录<ol><li>设计数据库</li><li>明文密码二次MD5加密</li><li>参数校验+全局异常处理</li></ol></li><li>共享Session<ol><li>SpringSession</li><li>Redis</li></ol></li></ol></li><li>功能开发<ol><li>商品列表</li><li>商品详情</li><li>秒杀</li><li>订单详情</li></ol></li><li>系统压测<ol><li>JMeter</li><li>自定义变量模拟多用户</li><li>JMeter命令行的使用</li><li>正式压测<ol><li>商品列表</li><li>秒杀</li></ol></li></ol></li><li>页面优化<ol><li>页面缓存+URL缓存+对象缓存</li><li>页面静态化，前后端分离</li><li>静态资源优化</li><li>CDN优化</li></ol></li><li>接口优化<ol><li>Redis预减库存减少数据库的访问</li><li>内存标记减少Redis的访问</li><li>RabbitMQ异步下单<ol><li>SpringBoot整合RabbitMQ</li><li>交换机</li></ol></li></ol></li><li>安全优化<ol><li>秒杀接口地址隐藏</li><li>算术验证码</li><li>接口防刷</li></ol></li><li>主流的秒杀方案</li></ol><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><table><thead><tr><th>技术</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>Spring Boot</td><td>2.6.4</td><td></td></tr><tr><td>MySQL</td><td>8</td><td></td></tr><tr><td><a href="https://github.com/baomidou/generator">MyBatis Plus</a></td><td>3.5.1</td><td></td></tr><tr><td>Swagger2</td><td>2.9.2</td><td>Swagger-models2.9.2版本报错，使用的是1.5.22</td></tr><tr><td><a href="https://doc.xiaominfo.com/">Kinfe4j</a></td><td>2.0.9</td><td>感觉比Swagger UI漂亮的一个工具，访问地址是ip:端口&#x2F;doc.html</td></tr><tr><td>Spring Boot Redis</td><td></td><td></td></tr></tbody></table><p>快（高性能） 准（一致性） 稳（高可用）</p><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>spring 模板，并添加相应依赖，再添加mybatisplus</p><p>配置mybatis-plus  datasource  log</p><p>创建controller service mapper 和mapper.xml， @MapperScan Dao层</p><p>新建测试接口测试</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>创建数据库表以及mapper service controller层</p><p>​pass  &#x3D;  MD5(MD5(pass名为+salt) + salt2)，前端传过来的时候也加密一次。这里salt2是存在数据库里的</p><p>创建一个项目作为逆向生成工具项目，勾选spring web，添加mybatis plus，官网代码生成器</p><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>&#x2F;doLogin</p><p>导入登录界面，前端传密码前用md5加密一下</p><p>添加通用返回类以及枚举对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RespBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title function_">success</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RespBean</span>(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RespBeanEnum</span> &#123;<br>    <span class="hljs-comment">//通用</span><br>    SUCCESS(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;SUCCESS&quot;</span>),<br>    ERROR(<span class="hljs-number">500</span>, <span class="hljs-string">&quot;服务端异常&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>校验在service中，还可以导入<code>spring-boot-starter-validation</code>包然后通过注解<code>@NotNull</code>实现校验。</p><ul><li><p>service如果出现异常，抛出并且<code>全局异常处理</code></p></li><li><p>登录成功后存一个uuid到session，并用cookie(直接返回也可以)返回给前端，前端每次都带上这个；或者返回一个token，前端每次携带</p></li><li><p>添加<code>spring-session-data-redis</code>依赖后可以将session自动存入redis中实现分布式session，</p></li><li><p>或者直接存数据到redis, key为uuid，通过cookie传来。之后相当于每次<strong>通过uuid拿到用户信息</strong>。导入<code>redis</code>包，配置 ip port等，配置类实现redis序列化，object序列化为json</p></li><li><p>使用配置MVC，继承 <code>WebMvcConfigurer</code>实现mvc的配置</p><p>​配置自定义参数配置， 每次取出user传入参数（这里只做了取出参数User，没有拦截请求）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903365.png" alt="image-20230315100229300"></p><p>​    还可以配置拦截器，添加拦截器，拦截哪些请求。（也可以拦截器直接实现参数，自己代码）</p></li></ul><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><p><strong>界面</strong>：商品列表 商品详情 订单 </p><p><strong>表</strong>：商品表 订单表 秒杀商品表（秒杀活动很多，添加一个标识字段不合适）  秒杀订单表</p><p><code>秒杀表</code>：商品ID、秒杀库存、开始结束时间</p><h3 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h3><p>名称 图片 价格 秒杀价 秒杀库存</p><p>由于需要显示的数据包含<code>商品表</code>和<code>秒杀商品表</code>，添加vo继承商品表添加额外信息</p><p><code>toList</code>接口返回商品列表，还需要添加<strong>mvc静态资源映射</strong> ：<code>addResourceHandlers</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903366.png" alt="image-20230307190839362"></p><h3 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h3><p>需要知道秒杀是否开始结束，后端通过时间判断返回给前端一个状态（未开始、进行中、已结束）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903367.png" alt="image-20230307193103679"></p><h3 id="秒杀功能"><a href="#秒杀功能" class="headerlink" title="秒杀功能"></a>秒杀功能</h3><p>&#x2F;doSeckill1  传统秒杀</p><p>传入user，goodsId</p><ul><li>判断该goodsId是否还有库存，库存是看秒杀商品表， <code>进一步：redis预减</code></li><li>判断该userId是否购买过goodId（查看秒杀订单表）：&#x3D;&#x3D;优化：查询redis&#x3D;&#x3D;</li><li>都没问题时，减库存，生成订单，生成秒杀订单          <code>进一步：加入队列</code></li></ul><p>代码中，前端页面需要将接口改为doSeckill1</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>建表，需要额外秒杀商品表（价格、库存、开始结束时间）、秒杀订单（商品id、订单id）</li><li>登录，存入信息到redis，key为时间戳，访问通过cookie携带</li><li>全局异常处理处理业务异常，拦截器拦截未登录用户（cookie时间戳不合理），静态资源配置</li><li>商品列表、商品详情页，秒杀功能</li></ul><h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>jmeter</p><ul><li>QPS：每秒请求次数</li><li>TPS：每秒事务（吞吐量）次数</li><li>一个页面一个TPS可能多次QPS</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903368.png" alt="image-20230314094536441"></p><p>但windos和linux相差可能很多</p><p><strong>配置mysql：</strong>为了安全性创建新用户xx，打开阿里云安全组，关闭防火墙</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">CREATE USER &#x27;xx&#x27;@&#x27;%&#x27; IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br>grant <span class="hljs-attribute">all</span> on *.* <span class="hljs-selector-tag">to</span> &#x27;xx&#x27;@&#x27;%&#x27;;<br><br>sudo firewall-cmd <span class="hljs-attr">--list-ports</span><br>sudo firewall-cmd <span class="hljs-attr">--add-port</span>=<span class="hljs-number">3306</span>/tcp <span class="hljs-attr">--permanent</span><br>sudo firewall-cmd <span class="hljs-attr">--reload</span><br></code></pre></td></tr></table></figure><p><strong>配置redis</strong>  (使用docker)，并配置远程访问以及持久化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"># 持久化<br>mkdir -<span class="hljs-selector-tag">p</span> /root/docker/redis/data<br>mkdir -<span class="hljs-selector-tag">p</span> /root/docker/redis/conf<br>vi /root/docker/redis/conf/redis<span class="hljs-selector-class">.conf</span><br>    # bind <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br>    protected-mode no<br>    appendonly yes<br>requirepass <span class="hljs-number">123123</span><br><br>docker run <span class="hljs-attr">--name</span> my_redis -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -v /root/docker/redis/data:/data -v /root/docker/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf <br><br>redis-server /etc/redis/redis.conf：在容器内执行的命令，启动 Redis 服务，并使用 /etc/redis/redis.conf 作为配置文件。<br><br></code></pre></td></tr></table></figure><p>安装jmeter，配置encodin，导入配置，放到bin目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./jmeter.sh -n -t first.jmx -l result.jtl<br>result.jtl 拿到win 聚合报告下查看<br></code></pre></td></tr></table></figure><p>部署java 到docker容器中,但我mysql redis都装在宿主机，需要合并网络不好访问，所以还是部署出来（或者用dockercompose部署）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"># 使用 openjdk 作为基础镜像<br><span class="hljs-selector-tag">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-alpine<br><br># 设置工作目录<br>WORKDIR /app<br><br># 将打包好的jar复制到容器中<br>COPY target/seckill-demo-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar /app/seckill-demo-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar<br><br># 暴露应用程序端口，起提示作用<br>EXPOSE <span class="hljs-number">8080</span><br><br># 启动应用程序<br>CMD [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app/seckill-demo-0.0.1-SNAPSHOT.jar&quot;</span>]<br><br>docker build -t myapp:v1 .<br>docker run -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> myapp:v1<br></code></pre></td></tr></table></figure><p><strong>问题</strong>：postman可以携带cookie请求成功，但浏览器不可以（跨域）</p><p>​现在没有拦截未登录用户，如果未携带cookie会导致User空指针异常</p><p><strong>小结</strong></p><ul><li>本地项目数据库、redis都用云的，并打包一份项目放到云上</li><li>云上部署，本地运行压测程序进行压测（标准应该云上压测，但比较麻烦）</li></ul><h3 id="配置文件导入多用户"><a href="#配置文件导入多用户" class="headerlink" title="配置文件导入多用户"></a>配置文件导入多用户</h3><ul><li><p>再创建一个用户，登录后把uuid保存下来，放到文件里逗号分隔</p></li><li><p>csv数据文件设置 <strong>定义</strong>变量名称<code>userTicket</code>, <code>$&#123;userTicket&#125;</code> 取出</p></li><li><p>测试&#x2F;user&#x2F;info接口，看下是不是 <strong>返回不同用户</strong></p></li><li><p>商品列表：5000 10 ：460</p></li></ul><p>生成100个用户，并且登录返回ticket,这里也可以生成用户用java，请求用python</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/createuser&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;压测创建配置文件&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">CreateUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        List&lt;TUser&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//生成用户</span><br><span class="hljs-comment">//        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="hljs-comment">//            TUser tUser = new TUser();</span><br><span class="hljs-comment">//            tUser.setId(1233L + i);</span><br><span class="hljs-comment">//            tUser.setNickname(&quot;user&quot; + i);</span><br><span class="hljs-comment">//            tUser.setSalt(&quot;1a2b3c&quot;);</span><br><span class="hljs-comment">//            tUser.setPassword(&quot;05314c6fbe1d0cdb5eab4e80f1bda30a&quot;);</span><br><span class="hljs-comment">//            list.add(tUser);</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        tUserService.saveBatch(list);</span><br><span class="hljs-comment">//        System.out.println(&quot;create user&quot;);</span><br><br>        <span class="hljs-comment">//读取用户</span><br>        list = tUserService.list();<br><br>        <span class="hljs-comment">//登录，生成UserTicket</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">urlString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://localhost:8080/login/doLogin&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\13000\\Desktop\\config.txt&quot;</span>);<br>        <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>            file.delete();<br>        &#125;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;rw&quot;</span>);<br>        randomAccessFile.seek(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-type">TUser</span> <span class="hljs-variable">tUser</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(urlString);<br>            <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">httpURLConnection</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();<br>            httpURLConnection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>            httpURLConnection.setDoOutput(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> httpURLConnection.getOutputStream();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mobile=&quot;</span> + tUser.getId() + <span class="hljs-string">&quot;&amp;password=c38dc3dcb8f0b43ac8ea6a70b5ec7648&quot;</span>;<br>            outputStream.write(params.getBytes());<br>            outputStream.flush();<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> httpURLConnection.getInputStream();<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> ((len = inputStream.read(buff)) &gt;= <span class="hljs-number">0</span>) &#123;<br>                byteArrayOutputStream.write(buff, <span class="hljs-number">0</span>, len);<br>            &#125;<br>            inputStream.close();<br>            byteArrayOutputStream.close();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">respone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteArrayOutputStream.toByteArray());<br>            <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>            <span class="hljs-type">RespBean</span> <span class="hljs-variable">respBean</span> <span class="hljs-operator">=</span> mapper.readValue(respone, RespBean.class);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">userTicket</span> <span class="hljs-operator">=</span> (String) respBean.getObject();<br>            System.out.println(<span class="hljs-string">&quot;create userTicket:&quot;</span> + tUser.getId());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> tUser.getId() + <span class="hljs-string">&quot;,&quot;</span> + userTicket;<br>            randomAccessFile.seek(randomAccessFile.length());<br>            randomAccessFile.write(row.getBytes());<br>            randomAccessFile.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;write to file :&quot;</span> + tUser.getId());<br>        &#125;<br>        randomAccessFile.close();<br>        System.out.println();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="测试秒杀接口"><a href="#测试秒杀接口" class="headerlink" title="测试秒杀接口"></a>测试秒杀接口</h3><p>&#x2F;doSeckill2</p><p>存在超卖问题！！</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="1-对象缓存redis"><a href="#1-对象缓存redis" class="headerlink" title="1.对象缓存redis"></a>1.对象缓存redis</h3><p>通过uuid缓存User对象，数据跟新后要删除redis</p><h3 id="2-页面缓存redis"><a href="#2-页面缓存redis" class="headerlink" title="2.页面缓存redis"></a>2.页面缓存redis</h3><p>把整个页面缓存到redis </p><p>​本来是<code>return ”goodsList“</code> 返回页面   - - 》》优化成 <code>渲染出整个页面</code>再返回，并缓存整个页面。<code>toList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/toList&quot;, produces = &quot;text/html;charset=utf-8&quot;, method = RequestMethod.GET)</span><br><span class="hljs-meta">@ResponseBody</span> <span class="hljs-comment">// 之前是返回字符串走mvc，现在是直接返回html文本</span><br><br>    <span class="hljs-comment">// 先看redis有没有</span><br>    <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> (String) valueOperations.get(<span class="hljs-string">&quot;goodsList&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(html)) &#123;<br>        <span class="hljs-keyword">return</span> html;<br>    &#125;<br>    <span class="hljs-comment">// 数据还是先放到model</span><br>    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    model.addAttribute(<span class="hljs-string">&quot;goodsList&quot;</span>, itGoodsService.findGoodsVo());<br>    <span class="hljs-comment">// 手动渲染goodsList这个界面</span><br>    <span class="hljs-type">WebContext</span> <span class="hljs-variable">webContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebContext</span>(request, response, request.getServletContext(), request.getLocale(), model.asMap());<br>    html = thymeleafViewResolver.getTemplateEngine().process(<span class="hljs-string">&quot;goodsList&quot;</span>, webContext);<br><br>    <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(html)) &#123;<br>        valueOperations.set(<span class="hljs-string">&quot;goodsList&quot;</span>, html, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <span class="hljs-keyword">return</span> html;<br></code></pre></td></tr></table></figure><h3 id="3-页面静态化"><a href="#3-页面静态化" class="headerlink" title="3.页面静态化"></a>3.页面静态化</h3><p>前后端分离</p><ul><li>静态页面放到static下，可以直接&#x2F;path.html访问，加载页面时请求返回json数据 <code>goodsDetail2</code> -&gt; <code>detail</code></li><li>之前跳转是<code>/goods/toDetail?goodsId=1</code>访问接口，现在是<code>/Detail.html?goodsId=1</code>直接访问页面，但加载页面时多一步ajax请求数据</li><li>前端加载数据 根据id注入: <code>$(&quot;#goodsName&quot;).text(goodsVo.goodsName); </code>  本来是Thymeleaf <code>th:text= &quot;$&#123;goodsVo.goodname&#125;&quot;</code></li></ul><p>orderDetial页面同理：</p><ul><li>原来发起doseckill1请求，成功加载数据return detaii跳转页面，失败返回到错误页面（代码就是这样）</li><li>现在发起doseckill2请求，成功后弹框问是否跳转到static下的detaii.html，然后再发起ajax请求加载detail</li></ul><h3 id="4-静态资源缓存"><a href="#4-静态资源缓存" class="headerlink" title="4.静态资源缓存"></a>4.静态资源缓存</h3><p>配置后static下的<code>goodsDetail.html</code>将被缓存，</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment">#静态资源处理</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-comment">#启动默认静态资源处理，默认启动</span><br>    <span class="hljs-attr">add-mappings:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">cache:</span><br>      <span class="hljs-attr">cachecontrol:</span><br>        <span class="hljs-comment">#缓存响应时间，单位秒</span><br>        <span class="hljs-attr">max-age:</span> <span class="hljs-number">3600</span><br>    <span class="hljs-attr">chain:</span><br>      <span class="hljs-comment">#资源配链启动缓存，默认启动</span><br>      <span class="hljs-attr">cache:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启动资源链，默认禁用</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启用压缩资源（gzip，brotil）解析，默认禁用</span><br>      <span class="hljs-attr">compressed:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启用h5应用缓存，默认禁用</span><br>      <span class="hljs-attr">html-application-cache:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">static-locations:</span> <span class="hljs-string">classpath:/static/</span><br></code></pre></td></tr></table></figure><h3 id="5-问题解决"><a href="#5-问题解决" class="headerlink" title="5.问题解决"></a>5.问题解决</h3><p>判断是否重复抢购，存入redis中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">TSeckillOrder tSeckillOrder = (TSeckillOrder) redisTemplate.opsForValue().get(&quot;order:&quot; + user.getId() + &quot;:&quot; + goodsId);<br></code></pre></td></tr></table></figure><p>单纯在减库存时判断商品库存是否为负，为负不再继续，解决超卖。<code>update会加行级别排他锁</code> &#x3D;&#x3D;影响并发量&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">seckillGoodsResult</span> <span class="hljs-operator">=</span> itSeckillGoodsService.update(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;TSeckillGoods&gt;()<br>                                                          .setSql(<span class="hljs-string">&quot;stock_count = &quot;</span> + <span class="hljs-string">&quot;stock_count-1&quot;</span>)<br>                                                          .eq(<span class="hljs-string">&quot;goods_id&quot;</span>, goodsVo.getId())<br>                                                          .gt(<span class="hljs-string">&quot;stock_count&quot;</span>, <span class="hljs-number">0</span>)<br>                                                         );<br><span class="hljs-keyword">if</span> (!seckillGoodsResult) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>订单表加唯一索引(user, goodid)防止单一用户多抢，<code>@Transactional</code>。</p><p>至此：单一购买以及超卖问题都解决了</p><h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>doseckill2</p><ul><li><p>redis预减库存（原子）</p></li><li><p>内存标记减少redis访问</p></li><li><p>用队列进行缓冲</p></li><li><p>静态化 + MQ + redis: QPS：<code>637-&gt;571</code>   反而下降了 </p></li><li><p><strong>分析原因</strong>：数据库在本地但redis在云上，导致redis读取过慢，<strong>redis本地</strong>后**<code>1933 -&gt; 3209</code>**，p55</p></li></ul><h3 id="1-预减库存"><a href="#1-预减库存" class="headerlink" title="1.预减库存"></a>1.<strong>预减库存</strong></h3><ul><li>加载时加入库存量 ;redis是&#x3D;&#x3D;原子操作&#x3D;&#x3D;，减库存时不会有并发问题，保证进入MQ的都是有库存的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().decrement(<span class="hljs-string">&quot;seckillGoods:&quot;</span> + goodsId);<br><span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span>)&#123;<br>    EmptyStockMap.put(goodsId, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 内存标记</span><br>    redisTemplate.opsForValue().increment(<span class="hljs-string">&quot;seckillGoods:&quot;</span> + goodsId);<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.EMPTY_STOCK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-内存标记："><a href="#2-内存标记：" class="headerlink" title="2.内存标记："></a>2.<strong>内存标记：</strong></h3><p>在访问redis前，使用一个map标记商品是否还有库存，减少redis访问（分布式会不会有问题？？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//内存标记，减少Redis的访问</span><br><span class="hljs-keyword">if</span> (EmptyStockMap.get(goodsId)) &#123;<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.EMPTY_STOCK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-消息队列："><a href="#3-消息队列：" class="headerlink" title="3.消息队列："></a>3.<strong>消息队列：</strong></h3><p>有库存要加入mq，传入参数中</p><ul><li>配置文件定义队列和交换机</li><li>MQSender文件封装发送方法</li><li>返回给前端排队中状态码</li><li>MQReceiver完成下单，再判断下库存、重复抢购</li></ul><h3 id="4-前端轮询："><a href="#4-前端轮询：" class="headerlink" title="4.前端轮询："></a><strong>4.前端轮询：</strong></h3><p> 下单后等待，添加一个接口查询是否下单成功</p><h3 id="lua脚本："><a href="#lua脚本：" class="headerlink" title="lua脚本："></a><strong>lua脚本：</strong></h3><p>&#x2F;&#x2F; 减少和增加不是原子的，但会有问题吗？？：redis库存可能负数，但不会超卖</p><p><code>setIfAbsent</code> ：setnx实现加锁，存在以下问题：</p><ul><li>异常了<strong>锁不会销毁</strong>：增加一个5s超时时间</li><li>如果处理时间超过了5s，会导致<strong>删别人的锁</strong>：value是版本号，保证删的是自己加的版本</li><li>（获取版本号 比较 删除）<strong>不是原子操作</strong>：lua脚本实现redis原子化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLock3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> valueOperations.setIfAbsent(<span class="hljs-string">&quot;k1&quot;</span>, value, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">if</span> (isLock) &#123;<br>        valueOperations.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) valueOperations.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + name);<br>        <span class="hljs-comment">//操作结束，删除锁</span><br>        System.out.println(valueOperations.get(<span class="hljs-string">&quot;k1&quot;</span>));<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Boolean) redisTemplate.execute(redisScript, Collections.singletonList(<span class="hljs-string">&quot;k1&quot;</span>), value);<br>        System.out.println(result);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;有线程在使用，请稍后再试&quot;</span>);<br>    &#125;<br>&#125;<br><br>lua：<br> <span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>])==ARGV[<span class="hljs-number">1</span>] then<br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>end<br></code></pre></td></tr></table></figure><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>验证码，存入redis <code>.set(&quot;captcha:&quot; + tUser.getId() + &quot;:&quot; + goodsId, captcha.text() )</code></li><li>对同一用户和商品生成一个唯一地址，拿地址再下单。获取地址需要验证码，地址同样redis</li><li>限流 （网关）</li></ul><p><strong>单接口简单限流</strong>：直接redis，存在5s最后临界问题  ； 漏桶算法；令牌桶算法（令牌不断生成到桶里）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">制访问次数，<span class="hljs-number">5</span>秒内访问<span class="hljs-number">5</span>次<br><span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>captcha = <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) valueOperations.get(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId());<br><span class="hljs-keyword">if</span> (count == <span class="hljs-literal">null</span>) &#123;<br>    valueOperations.set(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId(), <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">5</span>) &#123;<br>    valueOperations.increment(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.ACCESS_LIMIT_REACHED);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通用：</strong>拦截器+注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">需要限制的接口 <br><span class="hljs-meta">@AccessLimit(second = 5, maxCount = 5, needLogin = true)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span><br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AccessLimit &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">second</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maxCount</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器：去出注解中的参数进行判断。同时把user参数的写入也加进来，存入ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<br>        <span class="hljs-comment">// 参数User</span><br>        <span class="hljs-type">TUser</span> <span class="hljs-variable">tUser</span> <span class="hljs-operator">=</span> getUser(request, response);<br>        UserContext.setUser(tUser);<br>        <br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">hm</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>        <span class="hljs-type">AccessLimit</span> <span class="hljs-variable">accessLimit</span> <span class="hljs-operator">=</span> hm.getMethodAnnotation(AccessLimit.class);<br>        <span class="hljs-keyword">if</span> (accessLimit == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> accessLimit.second();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> accessLimit.maxCount();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needLogin</span> <span class="hljs-operator">=</span> accessLimit.needLogin();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>        <span class="hljs-keyword">if</span> (needLogin) &#123;<br>            <span class="hljs-keyword">if</span> (tUser == <span class="hljs-literal">null</span>) &#123;<br>                render(response, RespBeanEnum.SESSION_ERROR);<br>            &#125;<br>            key += <span class="hljs-string">&quot;:&quot;</span> + tUser.getId();<br>        &#125;<br>        <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) valueOperations.get(key);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-literal">null</span>) &#123;<br>            valueOperations.set(key, <span class="hljs-number">1</span>, second, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; maxCount) &#123;<br>            valueOperations.increment(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            render(response, RespBeanEnum.ACCESS_LIMIT_REACHED);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h2><p>网关过滤</p><p>2s 100w请求，20w商品。令牌桶。没获得令牌的直接失败</p><p>快速生成订单：redis （分片） ，再mq</p><p>超卖：分布式锁redisson。加锁解锁消耗：集群</p><p>nacos动态下发商品数量</p><ul><li>框架搭建<ul><li>Thymeleaf, RespBean</li><li>设计数据库 </li><li>全局异常 、通用返回、通用参数</li></ul></li><li>开发<ul><li>商品列表</li><li>商品详情</li><li>订秒杀</li><li>订单详情</li></ul></li><li>压测<ul><li>配置环境</li><li>多用户</li></ul></li><li>优化 页面、对象</li><li>进一步优化Redis预减、内存标记、MQ</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>框架搭建<ul><li>Thymeleaf, RespBean</li><li>设计数据库 </li><li>全局异常 、通用返回、通用参数</li></ul></li><li>开发<ul><li>商品列表</li><li>商品详情</li><li>订秒杀</li><li>订单详情</li></ul></li><li>压测<ul><li>配置环境</li><li>多用户</li></ul></li><li>优化 页面、对象</li><li>进一步优化Redis预减、内存标记、MQ</li></ul><p>笔记：<a href="https://goinggoinggoing.github.io/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE">https://goinggoinggoing.github.io/2023/03/20/B站秒杀项目</a><br>项目地址：<a href="https://github.com/Goinggoinggoing/seckill-study">https://github.com/Goinggoinggoing/seckill-study</a><br>项目来源：程序员来了666， 添加了一些中间过程接口以及注释<br>总结一下，分为三部分<br>第一个部分为基础的实现P43：到这里为了实现不超卖（减少库存的同时判断库存数量）且单一下单（唯一索引）：</p><p>boolean seckillGoodsResult &#x3D; itSeckillGoodsService.update(new UpdateWrapper<TSeckillGoods>()<br>        .setSql(“stock_count &#x3D; “ + “stock_count-1”)<br>        .eq(“goods_id”, goodsVo.getId())<br>        .gt(“stock_count”, 0)  &#x2F;&#x2F;大于零才下单<br>);<br>&#x2F;&#x2F; 防超卖，直接结束，很关键<br>if (!seckillGoodsResult) {<br>    return null;  &#x2F;&#x2F; 否则下单事务直接结束。update是排他锁，一定不会超卖<br>}<br>同时做了一些优化：页面静态化在前后端分离里默认就做了；下单后存入redis，加快是否重复下单判断。：</p><p>第二部分为进一步优化：1.用redis预减库存（减少数据库访问），redis是原子操作，可以防止超卖；2.满足还有库存后进入MQ队列；  3.我还想减少redis访问次数：引入内存标记。</p><p>第三部分为其他优化，比较清晰自己看即可</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建立博客</title>
    <link href="/2023/03/20/%E5%BB%BA%E7%AB%99/"/>
    <url>/2023/03/20/%E5%BB%BA%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>首先优先选择Hexo是因为Node.js已经安装好了，比较方便</p><p>主题选择：Fluid</p><ul><li><p>主题需要简洁，因为博客定位是笔记记录整理</p></li><li><p>需要有一定的美观（因为这个放弃了next主题）</p></li><li><p>基本的页面：首页 归档 分类(支持多级分类) 、标签、搜索功能</p></li></ul><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><ol><li>安装Nodejs</li><li>安装脚手架<code>npm install -g hexo-cli</code></li></ol><h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init blog   <span class="hljs-comment"># 初始化博客</span><br><span class="hljs-built_in">cd</span> blog<br>npm instal<br><br><br>hexo new fistt <span class="hljs-comment"># 创建第一个页面 填写内容</span><br><br>hexo g <span class="hljs-comment"># 生成文件</span><br>hexo s <span class="hljs-comment"># 启动  localhost:4000可以查看博客</span><br></code></pre></td></tr></table></figure><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><ol><li><p>新建 <code>用户名.github.io</code> 的仓库</p></li><li><p>配置博客推送到对应仓库</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span>  <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Goinggoinggoing/Goinggoinggoing.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li><li><p><code>npm install hexo-deployer-git --save</code>  安装git部署插件</p></li><li><p><code>hexo d</code> 推送到仓库</p></li></ol><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><ol><li><p><code>npm install --save hexo-theme-fluid</code></p></li><li><p>修改_config.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span><br>language: zh-CN  <span class="hljs-comment"># 指定语言</span><br></code></pre></td></tr></table></figure></li><li><p>重新生成并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <br>hexo s <br></code></pre></td></tr></table></figure></li></ol><h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><p>​<a href="https://hexo.fluid-dev.com/docs/guide/">官方文档</a></p><h4 id="文章配置"><a href="#文章配置" class="headerlink" title="文章配置"></a>文章配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">开发</span>, <span class="hljs-string">项目</span>]<br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 但可以通过链接访问</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span> <span class="hljs-comment"># 文章排序顺序 越大越前</span><br><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span> <span class="hljs-comment"># 封面图</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post_banner.jpg</span>  <span class="hljs-comment">#顶部图</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br><br></code></pre></td></tr></table></figure><h3 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h3><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><ul><li>修改博客配置文件，<code>post_asset_folder: true</code>，使得每次生成文章时默认携带一个同名文件夹，用来存放图片</li><li>引用图片： <code>![](test.png)</code>   或  <code>&#123;% asset_img test.png 图片引用方法一 %&#125;</code></li><li>存在的问题：本地typora记笔记是记录到  name.asset&#x2F;test.png，这样从本地到博客需要转换很麻烦</li></ul><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>​搭建github图床，每次本地完成后通过PicGo一键上传到图床，即可访问图片</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230402195401606.png" alt="image-20230402195401606"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_淡淡的说非的博客-CSDN博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2023/03/17/mysql/"/>
    <url>/2023/03/17/mysql/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL视频</a></p><p>下面是对章节与视频的对应关系和学习建议</p><p>【MySQL上篇：基础篇】<br>【第1子篇：数据库概述与MySQL安装篇】<br>p01-p11<br>学习建议：零基础同学必看，涉及理解和Windows系统下MySQL安装</p><p>【第2子篇：SQL之SELECT使用篇】<br>p12-p48<br>学习建议：学习SQL的重点，必须重点掌握，建议课后练习多写</p><p>【第3子篇：SQL之DDL、DML、DCL使用篇】<br>p49-p73<br>学习建议：学习SQL的重点，难度较SELECT低，练习写写就能掌握</p><p>【第4子篇：其它数据库对象篇】<br>p74-p93<br>学习建议：对于希望早点学完MySQL基础，开始后续内容的同学，这个子篇可以略过。<br>在工作中，根据公司需要进行学习即可。</p><p>【第5子篇：MySQL8新特性篇】<br>p94-p95<br>学习建议：对于希望早点学完MySQL基础，开始后续内容的同学，这个子篇可以略过。<br>在工作中，根据公司需要进行学习即可。</p><p>【MySQL下篇：高级篇】<br>【第1子篇：MySQL架构篇】<br>p96-p114<br>学习建议：涉及Linux平台安装及一些基本问题，基础不牢固同学需要学习</p><p>【第2子篇：索引及调优篇】<br>p115-p160<br>学习建议：面试和开发的重点，也是重灾区，需要全面细致的学习和掌握</p><p>【第3子篇：事务篇】<br>p161-p186<br>学习建议：面试和开发的重点，需要全面细致的学习和掌握</p><p>【第4子篇：日志与备份篇】<br>p187-p199<br>学习建议：根据实际开发需要，进行相应内容的学习</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式1：也是执行顺序<br>SELECT ...,....,...<br>FROM ...,...,....<br>WHERE 多表的连接条件<br>AND 不包含组函数的过滤条件<br>GROUP BY ...,...<br>HAVING 包含组函数的过滤条件<br>ORDER BY ... ASC/DESC<br>LIMIT ...,...<br>#方式2：<br>SELECT ...,....,...<br>FROM ... JOIN ...<br>ON 多表的连接条件<br>JOIN ...<br>ON ...<br>WHERE 不包含组函数的过滤条件<br>AND/OR 不包含组函数的过滤条件<br>GROUP BY ...,...<br>HAVING 包含组函数的过滤条件<br>ORDER BY ... ASC/DESC<br>LIMIT ...,...<br></code></pre></td></tr></table></figure><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p><ol><li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li><li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li><li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li></ol><ul><li>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。</li><li>然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的 基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。</li><li>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段 。</li><li>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2 。</li><li>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到 虚拟表 vt6 。</li><li>最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表 vt7 。</li><li>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT<br><br>SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5<br>FROM player JOIN team ON player.team_id = team.team_id # 顺序 1<br>WHERE height &gt; 1.80 # 顺序 2<br>GROUP BY player.team_id # 顺序 3<br>HAVING num &gt; 2 # 顺序 4<br>ORDER BY num DESC # 顺序 6<br>LIMIT 2 # 顺序 7<br></code></pre></td></tr></table></figure><h3 id="基础select"><a href="#基础select" class="headerlink" title="基础select"></a>基础select</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs mysql">别名：空行 或 as<br>DISTINCT 去重<br>空值：null <br>着重号：`order`<br>显示表结构：desc employees; <br><br>比较运算符：<br>= ：<br>1 = &#x27;1&#x27;  字符串会被转为整数<br>都是字符串会比较ANSI编码<br>!=<br>    ISNULL<br>    IS Not NULL<br>    BETWEEN x AND y<br>    IN<br>    NOT IN<br>    LIKE  % _<br>RLIKE 正则表达式<br>逻辑运算符<br>NOT 或 !<br>AND 或 &amp;&amp;<br>OR 或 ||<br>XOR<br><br>排序<br>ORDER BY x ASC(DESC), y ASC  多列排序在x相同才比y<br>分页<br>LIMIT [位置偏移量,] 行数     LIMIT 20,10; <br>UNION<br>连接两次查询<br><br>连接<br>SELECT emp.employee_id, dep.department_name<br>    FROM employee emp, department dep<br>    WHERE emp.`department_id` = dep.`department_id`;<br><br>JOIN / INNER JOIN   <br>    LEFT JOIN<br>    RIGHT JOIN<br>    FULL JOIN<br>    最后加上<br>    ON 条件<br>    USING 名称要对应并且值相等<br>    <br>    <br>    还有连接方式是直接选出来后where =条件连接，inner join（inner join即join）和=等号结果一样，但实现原理完全不同，join是基于hashtable连接比较，而=直接就是取笛卡尔集再过滤，所以后者效率低，是O(N^2)，前者是O(LogN)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">聚合函数<br>AVG()<br>SUM()<br>MAX()<br>MIN()<br>count(*) count(1) count(列名)<br>MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。 <br>Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。<br><br>GROUP BY 分组<br>SELECT的字段必须声明在GROUP BY或者聚合函数<br>HAVING 过滤分组<br>WITH ROLLUP 对统计出来的结果再求和，多一行<br><br><br></code></pre></td></tr></table></figure><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="~文件目录"></a>~文件目录</h2><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055458.png" alt="image-20230224113320725"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055459.png" alt="image-20230225090438227"></p><ul><li>Mysql5.7：ibd默认96KB，6个页</li><li>Mysql8.0：ibd默认112KB，结合了frm</li></ul><h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="~逻辑架构"></a>~逻辑架构</h2><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055460.png" alt="image-20230222201134751"></p><ol><li><strong>连接层</strong>TCP握手建立连接，确认账号密码。通过线程池分配线程</li><li><strong>服务层</strong>生成解析树，优化器生成执行计划完成优化 &#x3D;&#x3D;选取-投影-连接&#x3D;&#x3D;</li><li><strong>引擎层</strong>插件式存储引擎层，负责数据的提取和存储  show engines；</li></ol><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055461.png" alt="image-20230222202520557" style="zoom: 80%;" /><ol><li><p><strong>缓存</strong></p><p>缓存必须一模一样，命中率低；更新后还可能失效</p><p><code>show global variables like &quot;%query_cache_type%&quot;;  show status like &#39;%Qcache%&#39;;</code></p></li><li><p><strong>解析器</strong></p><p><strong>词法分析</strong>识别关键字</p><p><strong>语法分析</strong>查看是否满足mysql语法，然后生成语法树</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055462.png" alt="image-20230222203631132"></p></li><li><p><strong>优化器</strong></p><p>找到这其中最好的执行计划。</p><p>比如：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联 (join) 的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from test1 join test2 using(ID)<br>where test1.name=&#x27;zhangwei&#x27; and test2.name=&#x27;mysql高级课程&#x27;;<br><br>方案1：可以先从表 test1 里面取出 name=&#x27;zhangwei&#x27;的记录的 ID 值，再根据 ID 值关联到表 test2，再判<br>断 test2 里面 name的值是否等于 &#x27;mysql高级课程&#x27;。<br><br>方案2：可以先从表 test2 里面取出 name=&#x27;mysql高级课程&#x27; 的记录的 ID 值，再根据 ID 值关联到 test1，<br>再判断 test1 里面 name的值是否等于 zhangwei。<br><br>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化<br>器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。<br>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。<br></code></pre></td></tr></table></figure></li><li><p>执行器</p></li></ol><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="~存储引擎"></a>~存储引擎</h2><h3 id="①引擎"><a href="#①引擎" class="headerlink" title="①引擎"></a>①引擎</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engines;<br>show variables like &#x27;%storage_engine%&#x27; 或 SELECT @@default_storage_engine;<br>SET DEFAULT_STORAGE_ENGINE=MyISAM;   修改 my.cnf 文件：default-storage-engine=MyISAM<br><br></code></pre></td></tr></table></figure><p>不同的表可以设置不同的存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建<br>CREATE TABLE 表名(<br>建表语句;<br>) ENGINE = 存储引擎名称;<br>修改<br>ALTER TABLE 表名 ENGINE = 存储引擎名称;<br></code></pre></td></tr></table></figure><h3 id="②引擎介绍"><a href="#②引擎介绍" class="headerlink" title="②引擎介绍"></a>②引擎介绍</h3><p> 5.5之后，默认InnoDB </p><h4 id="1-InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#1-InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="1 InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>1 InnoDB 引擎：具备外键支持功能的事务存储引擎</h4><ul><li>事务型引擎。确保事务的完整提交(Commit)和回滚(Rollback)。 </li><li>行锁，更新一条数据只锁定一行</li><li>更新和删除效率高</li><li>外键</li><li><code>处理效率差一些，对内存要求(索引即数据，索引和数据存储在一起)</code></li></ul><h4 id="2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="2 MyISAM 引擎：主要的非事务处理存储引擎"></a>2 MyISAM 引擎：主要的非事务处理存储引擎</h4><ul><li>读速度快，针对select insert</li><li>count(*)等数据有额外存储</li></ul><h4 id="3-Archive-引擎：用于数据存档"><a href="#3-Archive-引擎：用于数据存档" class="headerlink" title="3 Archive 引擎：用于数据存档"></a>3 Archive 引擎：用于数据存档</h4><ul><li>只有插入和查询，适合存储大量独立历史记录</li><li>数据压缩，比MyISAM小75&amp;</li></ul><h4 id="4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a>4 Blackhole 引擎：丢弃写操作，读操作会返回空内容</h4><h4 id="5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a>5 CSV 引擎：存储数据时，以逗号分隔各个数据项</h4><h4 id="6-Memory-引擎：置于内存的表"><a href="#6-Memory-引擎：置于内存的表" class="headerlink" title="6 Memory 引擎：置于内存的表"></a>6 Memory 引擎：置于内存的表</h4><p>索引数据结构(B+) InnoDB数据结构  设计原则 性能分析工具 优化 数据库设计</p><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="~索引的数据结构"></a>~索引的数据结构</h2><h3 id="①-索引介绍"><a href="#①-索引介绍" class="headerlink" title="① 索引介绍"></a>① 索引介绍</h3><p>查找一个数据：遍历 索引二叉树(保存value, 地址)  减少磁盘IO</p><p><strong>定义</strong>：为了高效获取数据的数据结构  </p><p>在存储引擎中实现，不同引擎可以不一样结构</p><p><strong>优点</strong>：</p><ol><li><p>类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主 要的原因。 </p></li><li><p>通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。 </p></li><li><p>在实现数据的 参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。 </p></li><li><p>在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。‘</p></li></ol><p><strong>缺点：</strong></p><ol><li>创建和维护需要时间</li><li>索引需要磁盘空间</li><li>提高查询速度 但 降低 &#x3D;&#x3D;更新速度&#x3D;&#x3D;</li></ol><blockquote><p>频繁更新，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p></blockquote><h3 id="②-InnoDB中的索引"><a href="#②-InnoDB中的索引" class="headerlink" title="② InnoDB中的索引"></a>② InnoDB中的索引</h3><h4 id="普通查找"><a href="#普通查找" class="headerlink" title="普通查找"></a>普通查找</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;<br></code></pre></td></tr></table></figure><p>数据以页的形式存储，一页默认为16KB，查找时按照页逐步加载到内存</p><ol><li>数据在一页中（记录物理不连续，单链表，通过页目录实现二分）<ul><li>以主键搜索条件：主键通常为递增的 -&gt; 在 &#x3D;&#x3D;页目录 二分&#x3D;&#x3D; 定位对应槽 ，然后对槽内遍历</li><li>其他列：每一条记录为单链表连接(<strong>逻辑上连续</strong>)， 依次遍历</li></ul></li><li>很多页（页间双向链表连接）<ol><li>首先遍历页。<strong>没有索引无法快速定位</strong></li><li>再查找相应记录</li></ol></li></ol><h4 id="索引雏形"><a href="#索引雏形" class="headerlink" title="索引雏形"></a>索引雏形</h4><p>以<code>ROW_FORMAT = Compact </code>行格式创建表，表的每一条记录处理基本信息还有 是否最大 下一条地址 其他等，以下一条地址串联记录。</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055463.png" alt="image-20230223094205438" style="zoom: 50%;" /><p>为了针对主键设计索引，需要实现主键递增（主键不是自增的有个隐藏主键）</p><ul><li><p>页内是递增的，&#x3D;&#x3D;单向链表&#x3D;&#x3D;</p></li><li><p>页之间主键也是递增的，&#x3D;&#x3D;双向链表&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055464.png" alt="image-20230223094947963"></p></li></ul><blockquote><p>如果具体查找某一个主键还是得遍历全部页，然后页内二分，因此加一层。<br>加一个目录（目录可以连续存放）保存最小值，两次查找</p></blockquote><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055465.png" alt="image-20230223095322576" style="zoom: 67%;" /><h5 id="迭代1"><a href="#迭代1" class="headerlink" title="迭代1"></a>迭代1</h5><p>将目录转为页，<strong>实现快速定位数据页。</strong>目录也是页，用record_type&#x3D;1.通过&#x3D;&#x3D;页目录&#x3D;&#x3D;实现二分</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055466.png" alt="image-20230223100558168"></p><h5 id="迭代2"><a href="#迭代2" class="headerlink" title="迭代2"></a>迭代2</h5><p>一个目录页放不下，多个目录页。具体哪一个目录页要遍历，下面优化</p><h5 id="迭代3"><a href="#迭代3" class="headerlink" title="迭代3"></a>迭代3</h5><p>再往上迭代套娃，<strong>实现快速定位是哪个目录页</strong>。一个页为一次IO。总共3次IO</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055467.png" alt="image-20230223101559060"></p><h5 id="B-TreeB-Tree"><a href="#B-TreeB-Tree" class="headerlink" title="B+TreeB+Tree"></a>B+TreeB+Tree</h5><p>上面的结构就是3层的B+树，可以迭代任意层，但最多不超过4层（最多4次IO）</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055468.png" alt="image-20230223102937530" style="zoom: 33%;" /><p>假设存放记录的页可以100条，目录项的页为1000（页大小16KB，一条记录包含指针8KB主键8KB）条：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li><li>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。 </li><li>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。 </li><li>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！</li><li>一般2-4层，根节点常驻内存，所以1-3次磁盘操作</li></ul><p>页内数据通过&#x3D;&#x3D;链表&#x3D;&#x3D;连接，使用页目录实现&#x3D;&#x3D;二分法&#x3D;&#x3D;定位</p><p>同行页间通过&#x3D;&#x3D;双向链表&#x3D;&#x3D;连接</p><h4 id="常见索引"><a href="#常见索引" class="headerlink" title="常见索引"></a>常见索引</h4><h5 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h5><p><strong>基本的数据存储方式</strong>（叶子节点存放全部记录）。 <code>索引即数据，数据即索引   .ibd文件</code></p><p>在创建时自动构建出来–B+树。</p><blockquote><p> 术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起，只有一种存储方式所以聚簇索引只有一个</p></blockquote><ul><li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 </li><li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快</li></ul><ul><li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式(<del>UUID MD5 HASH</del>)，否则将会出现页分裂</li><li><code>更新主键的代价很高</code> ，一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code> ，第一次找到主键值，第二次根据主键值找到行数据</li></ul><h5 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h5><p>想以别的列作为搜索条件，需要以别的列构建B+树。</p><p>叶子节点存储<strong>索引列</strong>和<strong>主键</strong>。目录项存储<strong>索引列</strong>和<strong>页号</strong>（实际上是索引列和主键联合，后面会说 为保证唯一）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055470.png" alt="image-20230223154220793"></p><p>查询要查两次（<strong>回表</strong>）：先根据筛选条件在普通索引上定位id，再拿id再聚集索引上定位行</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055471.png" alt="image-20230223153459920" style="zoom:50%;" /><h5 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3.联合索引"></a>3.联合索引</h5><p>以c2和c3同时作为排列规则，优先c2，然后c3。别的和二级索引等价</p><h4 id="InnoDB注意事项"><a href="#InnoDB注意事项" class="headerlink" title="InnoDB注意事项"></a>InnoDB注意事项</h4><p><strong>1.根节点位置不变</strong><br>一开始根节点存放数据，满了后复制一份数据存储到别的地址，然后根节点升一级。此外，根节点常驻内存</p><p><strong>2.目录项记录的唯一性</strong><br>二级索引中<code>索引列 + 页号</code>搭配，索引列不唯一插入走哪条路就不知道了。所以默认会将<code>索引列+主键+页号</code>搭配，索引列和主键类似构建了一个联合索引。</p><p><strong>3.一个页面至少两条数据</strong></p><h3 id="③-MyISAM中索引"><a href="#③-MyISAM中索引" class="headerlink" title="③ MyISAM中索引"></a>③ MyISAM中索引</h3><p>索引与数据<strong>分离</strong> .myd存储数据（无序）， .myi存储索引</p><p>B树索引使用存储引擎如表所示：</p><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 <strong>地址</strong> 。&#x3D;&#x3D;相当于二级索引，但第二次是直接去磁盘&#x3D;&#x3D;</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055472.png" alt="image-20230223160434464" style="zoom: 67%;" /><p>​<code>这里是针对主键构建的，还可以根据c2，c3都构建。</code></p><p><strong>对比：</strong></p><ul><li>InnoDB对聚簇索引只需要查找一次，二级索引需要两次。MYISAM都是两次，但第二次很快</li><li>MYISAM索引文件分离</li><li>MYISAM可以没有主键</li></ul><h3 id="④-索引的代价"><a href="#④-索引的代价" class="headerlink" title="④ 索引的代价"></a>④ 索引的代价</h3><ul><li>空间：每一个索引都是一颗b+树</li><li>时间：增删改需要额外维护树结构</li></ul><h3 id="⑤-数据结构选择"><a href="#⑤-数据结构选择" class="headerlink" title="⑤ 数据结构选择"></a>⑤ 数据结构选择</h3><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>hashmap O(1)</p><ol><li>Hash只能进行&#x3D;和in的查询，不能进行范围查询(退化到O n)</li><li>无序 不能order by</li><li>联合索引时，hash值是一起构建的，无法拆开利用</li><li>重复值过多，冲突很多</li></ol><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>HASH索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>但Innodb也可以结合Hash，例如当某个条件WHERE a &#x3D; XXX经常访问时，将该条件对应地址直接存在hash中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%adaptive_hash_index&#x27;;<br></code></pre></td></tr></table></figure><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul><li>一个节点只能有两个子节点</li><li>左子节点 &lt; 本节点; 右子节点 &gt;&#x3D; 本节点</li><li>不平衡时退化</li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055473.png" alt="image-20230223163719556" style="zoom:50%;" /><h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>平衡二叉树且高度差小于1</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055474.png" alt="image-20230223163957242"></p><p>还可以变成多叉树来降低高度</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>每一个节点最多M个子节点，M称为树的阶。<strong>非叶子节点也存放数据</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055475.png" alt="image-20230223164347661"></p><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li>根节点的儿子数的范围是 [2,M]。 </li><li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M&#x2F;2), M]。 </li><li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。 </li><li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li><li>所有叶子节点位于同一层。</li></ol><p> 数据是一块的实现相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><strong>B+ 树和 B 树的<code>差异</code>在于以下几点：</strong></p><ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。 </li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中（小从小到大顺序链接）。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。</li></ol><p><strong>不在中间节点放数据，好处</strong></p><ul><li>数据都在叶子，查询效率稳定</li><li>非叶子无数据，可以存储更多数据，<strong>更矮胖</strong></li><li><strong>范围查找</strong>：叶子节点上直接进行范围查找效率高</li></ul><p>B树层数与节点数关系见：<a href="#B+Tree">B+Tree</a>，整课树能达到GB，不会全部加载到内存，只有根节点是常驻内存的</p><h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="~InnoDB数据存储结构"></a>~InnoDB数据存储结构</h2><p>索引是在存储引擎中实现的，存储引擎<strong>负责数据的读取和写入</strong></p><p>InnoDB将<strong>数据划分为页</strong>（16KB），页是磁盘和内存交换的&#x3D;&#x3D;基本单位&#x3D;&#x3D;，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;%innodb_page_size%&#x27;;<br></code></pre></td></tr></table></figure><p>SQL Server 中页的大小为 <code>8KB</code>，而在 Oracle 中我们用术语 “<code>块</code>“ （Block）来表示 “页”，Oracle 支持的快大小为2KB, 4KB, 8KB, 16KB, 32KB 和 64KB。</p><ul><li>页和页间<code>双向链表</code></li><li>页内数据按主键值<code>单向链表</code></li></ul><h3 id="①-上层结构"><a href="#①-上层结构" class="headerlink" title="① 上层结构"></a>① 上层结构</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055476.png" alt="image-20230224111638558" style="zoom:67%;" /><ul><li><p><strong>区</strong>：包含64个&#x3D;&#x3D;<strong>连续</strong>&#x3D;&#x3D;的页，<code>16*16KB = 1MB</code></p><p>范围查询时需要连续访问多个页，通过数据连续<strong>减少磁盘读取时间</strong> 10ms -&gt; 0.4ms</p><ul><li>随机读取 <code>单页10ms</code>(6ms寻道3ms等待1ms传输)</li><li>顺序读取 40MB&#x2F;s吞吐量，40&#x2F;16kb可以读取2560页，<code>单页0.4ms</code></li></ul></li><li><p><strong>段</strong>：多个区，数据库分配的基本单位：创建表、索引时分配。逻辑概念</p><p><strong>叶子节点</strong>放在一个区里，<strong>非叶子节点</strong>页在一个区里，区的集合叫做段</p></li><li><p><strong>碎片区：</strong>每次创建索引都会申请两整块区，太浪费。为了节约空间<code>碎片区内的页</code>可以服务于不同的段，当达到<code>32个碎片区</code>页面后，就申请完整的区。</p></li><li><p><strong>表空间</strong>：最高层逻辑容器，一个数据库由多个表空间：系统表空间、用户表空间等</p><ul><li><p>独立表空间: 即每张表有一个独立的表空间 .ibd  show variables like ‘innodb_file_per_table’</p></li><li><p>系统表空间 : 系统中所有表的索引外键路径等信息，也用B+树整合为表：<code>数据字典</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055477.png" alt="image-20230225102558798"></p></li></ul></li></ul><h3 id="②-页内结构"><a href="#②-页内结构" class="headerlink" title="② 页内结构"></a>② 页内结构</h3><p>数据页的 <code>16KB</code> 大小的存储空间被划分为<strong>七个部分</strong>：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055478.png" alt="image-20230224113534470" style="zoom:67%;" /><h4 id="第一部分：File-Header-文件头部-和-File-Trailer-文件尾部"><a href="#第一部分：File-Header-文件头部-和-File-Trailer-文件尾部" class="headerlink" title="第一部分：File Header (文件头部) 和 File Trailer (文件尾部)"></a>第一部分：File Header (文件头部) 和 File Trailer (文件尾部)</h4><p>File Header：页编号、页类型（Undo日志 数据页等）、上一页下一页、校验和（hash 文件-&gt;checksum）、日志位置</p><p>File Trailer：校验和（头尾一样代表完整）、日志位置</p><h4 id="第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)"></a>第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)</h4><p><strong>数据记录：</strong> 空闲空间-&gt;用户记录</p><p>最大最小记录：为了能构建B+树，同时是整个链表的首尾</p><h4 id="第三部分：Page-Directory-页目录-和-Page-Header-页面头部"><a href="#第三部分：Page-Directory-页目录-和-Page-Header-页面头部" class="headerlink" title="第三部分：Page Directory (页目录) 和 Page Header (页面头部)"></a>第三部分：Page Directory (页目录) 和 Page Header (页面头部)</h4><p><strong>页目录</strong>：记录分组（<code>直接二分空间太大，跳表</code>），每组4-8个(一个槽)，每个组拿出一个最大值排列出来，然后二分。</p><ul><li>最小记录单成组，最大记录4-8个</li><li>满9就拆分，所以很多都是4个</li></ul><p>页目录就负责记录下每组最大记录的（<code>地址偏移、最大值</code>）</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055479.png" alt="image-20230224121819782" style="zoom:67%;" /><p><strong>页面头部</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055480.png" alt="image-20230224122712920" style="zoom: 33%;" /><h3 id="③-行格式"><a href="#③-行格式" class="headerlink" title="③ 行格式"></a>③ 行格式</h3><p>链表记录的组合方式，为了链表有效组合，需要提供一定的额外信息，<strong>变长字段长度</strong>和<strong>NULL</strong>在&#x3D;&#x3D;InnoDB行格式&#x3D;&#x3D;讲</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055481.png" alt="image-20230224120801440" style="zoom: 50%;" /><p><strong>记录头信息</strong>(5bit)</p><ul><li>delete_mask 是否删除。逻辑删除，同时链表跳过它，并且修改组的数量最值。如果有新数据进来就覆盖一下</li><li>n_owned 每一组最后一条记录负责记下组内的记录个数</li><li>heap_no 页内位置编号  01是最小和最大记录</li><li>record_type 是否为叶子节点</li><li>next_record 链表next，记录偏移量</li></ul><h3 id="④-InnoDB行格式"><a href="#④-InnoDB行格式" class="headerlink" title="④ InnoDB行格式"></a>④ InnoDB行格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table emp3(id int)  row_format=compact;<br>alter table emp3 row_format=compact;<br></code></pre></td></tr></table></figure><ol><li><p>COMPACT</p><ul><li><strong>变长字段长度列表</strong>：对于变长字段不知道实际的长度<code>VARCHAR(8)</code>，需要有一个位子记录下实际上的长度 逆序</li><li><strong>NULL值列</strong>：对于可能为NULL的列，NULL在存储中如果用特殊字符表示会浪费空间，直接用bit位来标识是不是NULL</li><li><strong>记录头信息</strong>：同上</li><li><strong>隐藏列</strong>：<strong>row_id</strong>(行ID，无主键和Unique键时生成)  <strong>transaction_id</strong>(事务ID)  <strong>roll_pointer</strong>(回滚指针)</li></ul><p>.ibd文件讲解</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055482.png" alt="image-20230225091537989"></p><p><strong>行溢出：</strong></p><p>​对于varchar，最长共65535字节: 65532 + 2(长度值) + 1(null值)</p><p>​16KB&#x3D;16384字节，存不下varchar，所以compact存一部分然后存在别的地方，保存下地址</p></li><li><p>Dynamic(MySQL5.7)和Compressed</p><p>Dynamic行溢出只存地址不存数据，Compressed还会用zlib压缩数据</p></li><li><p>Redundant</p><p>字段偏移列表：所有列的偏移地址，等价于变长+NULL，但纯在冗余（对于非varchar）</p></li></ol><h2 id="索引创建"><a href="#索引创建" class="headerlink" title="~索引创建"></a>~索引创建</h2><p>创建完成，.ibd文件会增大</p><h3 id="①-索引基本操作"><a href="#①-索引基本操作" class="headerlink" title="① 索引基本操作"></a>① 索引基本操作</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><ul><li><p>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是<strong>普通索引</strong>、<strong>唯一索引</strong>（UNIQUE）、<strong>主键索引</strong>(UNIQUE+NOT NULL 唯一)、<strong>全文索引</strong>（提高大数据量的检索速度，被solr、ElasticSearch代替）。 </p></li><li><p>按照<code>物理实现</code>方式 ，索引可以分为 2 种：<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。 </p></li><li><p>按照<code>作用字段个数</code> 进行划分，分成<strong>单列索引</strong>和<strong>联合索引</strong>。</p></li></ul><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><strong>隐式：</strong><code>主键、Unique、外键</code> 会自动添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE dept(<br>dept_id INT PRIMARY KEY AUTO_INCREMENT, # <br>dept_name VARCHAR(20)<br>);<br><br>CREATE TABLE emp(<br>emp_id INT PRIMARY KEY AUTO_INCREMENT, # 主键<br>emp_name VARCHAR(20) UNIQUE, # unique<br>dept_id INT,<br>CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id) # 外键<br>)<br></code></pre></td></tr></table></figure><p><strong>显式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name [col_name data_type]<br>[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |<br>DESC]<br></code></pre></td></tr></table></figure><ul><li>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引； </li><li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引； </li><li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </li><li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </li><li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </li><li>ASC 或 DESC 指定升序或者降序的索引值存储。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INDEX (book_name)<br>INDEX multi_idx(book_id, book_name)<br>UNIQUE INDEX book_n(book_name)<br><br>SHOW INDEX FROM test3 \G # 查看全部索引<br><br>EXPLAIN select * from book where book_name = &quot;mysql&quot; # 查看是否用上索引<br></code></pre></td></tr></table></figure><h4 id="添加删除索引"><a href="#添加删除索引" class="headerlink" title="添加删除索引"></a>添加删除索引</h4><p><strong>添加</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_na ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]<br>[index_name] (col_name[length],...) [ASC | DESC]<br>ALTER TABLE book5 ADD INDEX book_n (book_name) ;<br><br>CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name<br>ON table_name (col_name[length],...) [ASC | DESC]<br></code></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_na DROP INDEX index_name;<br><br>DROP INDEX index_name ON table_na;<br><br># 唯一索引不能删除 起约束作用<br></code></pre></td></tr></table></figure><h3 id="②-8-0索引新特性"><a href="#②-8-0索引新特性" class="headerlink" title="② 8.0索引新特性"></a>② 8.0索引新特性</h3><h4 id="降序索引"><a href="#降序索引" class="headerlink" title="降序索引"></a>降序索引</h4><p>MySQL 8.x开始支持降序 DESC，之前版本的会被忽略。<code>多个列排序</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));<br></code></pre></td></tr></table></figure><p>查询时<code>order by a,b desc</code>，没有降序的化效果很差，需要文件排序</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055483.png" alt="image-20230226085758361"></p><h4 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h4><p>索引设置为隐藏索引，查询优化器<code>忽略这个索引</code>（更新时索引树还是会更新）。可以用来<code>验证某个索引性能</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE tablename<br>ADD INDEX indexname (propname [(length)]) INVISIBLE; # 添加隐藏索引<br><br>ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引<br>ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引<br></code></pre></td></tr></table></figure><h3 id="③-索引的设计原则"><a href="#③-索引的设计原则" class="headerlink" title="③ 索引的设计原则"></a>③ 索引的设计原则</h3><p>数据准备 100W条</p><h4 id="适合创建索引"><a href="#适合创建索引" class="headerlink" title="适合创建索引!"></a>适合创建索引!</h4><h5 id="唯一字段"><a href="#唯一字段" class="headerlink" title="唯一字段"></a>唯一字段</h5><p>业务上具有唯一特性的字段，即使是组合字段，也<code>必须建成唯一索引</code>。</p><blockquote><p>不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。（来源：Alibaba） </p></blockquote><h5 id="频繁where字段"><a href="#频繁where字段" class="headerlink" title="频繁where字段"></a>频繁where字段</h5><p>277ms-&gt;20ms</p><h5 id="经常-GROUP-BY-和-ORDER-BY-的列"><a href="#经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="经常 GROUP BY 和 ORDER BY 的列"></a>经常 GROUP BY 和 ORDER BY 的列</h5><h5 id="DISTINCT-字段"><a href="#DISTINCT-字段" class="headerlink" title="DISTINCT 字段"></a>DISTINCT 字段</h5><h5 id="多表JOIN时"><a href="#多表JOIN时" class="headerlink" title="多表JOIN时"></a>多表JOIN时</h5><ul><li><code>连接表的数量尽量不要超过 3 张</code></li><li><code>对 WHERE 条件创建索引</code></li><li><code>对用于连接的字段创建索引</code></li></ul><h5 id="使用前缀创建索引"><a href="#使用前缀创建索引" class="headerlink" title="使用前缀创建索引"></a>使用前缀创建索引</h5><p>不使用整个字符串构建。虽然不能精确查询，但查个大概然后回表查询完整的字符串。<strong>排序时用不上</strong></p><ul><li><code>太长存储空间太大</code></li><li><code>太长比较时需要占用更多时间</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 截取长度的选择：根据区分度    一般20 就可以达到90%以上<br>select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度<br>count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度<br>from shop<br></code></pre></td></tr></table></figure><h5 id="区分度高-散列性高"><a href="#区分度高-散列性高" class="headerlink" title="区分度高(散列性高)"></a>区分度高(散列性高)</h5><p><code>select count(distinct a) / count(*) from t1</code>，超过33%就不错的索引了</p><p>相对应的，像性别字段就不要添加索引</p><h5 id="最频繁的列放到联合索引的左侧"><a href="#最频繁的列放到联合索引的左侧" class="headerlink" title="最频繁的列放到联合索引的左侧"></a>最频繁的列放到联合索引的左侧</h5><p>对应最左前缀原则。</p><h5 id="多个字段都要创建时，联合索引更优"><a href="#多个字段都要创建时，联合索引更优" class="headerlink" title="多个字段都要创建时，联合索引更优"></a>多个字段都要创建时，联合索引更优</h5><ul><li>减少开销：一个联合索引<code>(c1,c2,c3)</code>，相当于<code>(c1)</code>,<code>(c1,c2)</code>,<code>(c1,c2,c3)</code>三个索引</li><li>覆盖索引：<code> select col1,col2,col3 from test where col1=1 and col2=2</code>，无需回表</li><li>效率高：索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1&#x3D;1 and col2&#x3D;2 and  col3&#x3D;3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%&#x3D;100w条数据，然后再回表从100w条数据中找到符合col2&#x3D;2 and col3&#x3D; 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w * (10% *10% *10%)&#x3D;1w，效率提升可想而知！</li></ul><h4 id="限制索引数量"><a href="#限制索引数量" class="headerlink" title="限制索引数量"></a>限制索引数量</h4><p>单表不超过六个：</p><ul><li>索引占用空间</li><li>更新时间</li><li>查询时，优化器需要对可能用到的索引进行比较，太多会降低性能</li></ul><h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="~性能分析工具"></a>~性能分析工具</h2><h3 id="①-优化步骤"><a href="#①-优化步骤" class="headerlink" title="① 优化步骤"></a>① 优化步骤</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055484.png" alt="image-20220627162248635"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055485.png" alt="image-20220627162345815"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055486.png" alt="image-20230226135825018" style="zoom:50%;" /><h3 id="②-查看系统性能-status"><a href="#②-查看系统性能-status" class="headerlink" title="② 查看系统性能 status"></a>② 查看系统性能 status</h3><p><code>SHOW STATUS</code> ：查询一些MySQL数据库服务器的<code>性能参数、执行频率</code>。 %是通配符任意匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW [GLOBAL|SESSION] STATUS LIKE &#x27;参数&#x27;;<br></code></pre></td></tr></table></figure><ul><li><p>Connections：连接MySQL服务器的次数。 </p></li><li><p>Uptime：MySQL服务器的上线时间。 </p></li><li><p>&#x3D;&#x3D;Slow_queries&#x3D;&#x3D;：慢查询的次数。 </p></li><li><p>Innodb_rows_read：Select查询返回的行数 </p></li><li><p>Innodb_rows_inserted：执行INSERT操作插入的行数 </p></li><li><p>Innodb_rows_updated：执行UPDATE操作更新的 行数 </p></li><li><p>Innodb_rows_deleted：执行DELETE操作删除的行数 </p></li><li><p>Com_select：查询操作的次数。 </p></li><li><p>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 </p></li><li><p>Com_update：更新操作 的次数。 </p></li><li><p>Com_delete：删除操作的次数。</p></li><li><p>&#x3D;&#x3D;last_query_cost&#x3D;&#x3D;：查看最后一次操作查询了多少张<strong>数据页</strong>。</p><ul><li>建立了索引，可以有效减少访问的页数。回表的化页数还要增加</li><li>页数多页不用担心，1.页可以在缓冲池或内存中、2.批量顺序读取速度也很快</li></ul></li></ul><h3 id="③-定位执行慢的-SQL：慢查询日志"><a href="#③-定位执行慢的-SQL：慢查询日志" class="headerlink" title="③ 定位执行慢的 SQL：慢查询日志"></a>③ 定位执行慢的 SQL：慢查询日志</h3><p>超过<code>long_query_time</code>的SQL会记录下，默认10s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;%slow_query_log%&#x27;; # 是否打开 以及 保存地址<br>set global slow_query_log=&#x27;ON&#x27;; # 打开<br><br> show variables like &#x27;%long_query_time%&#x27;; # 时间阈值<br> <br> # 设置时间<br> #测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并<br>mysql &gt; set global long_query_time = 1;<br>mysql&gt; show global variables like &#x27;%long_query_time%&#x27;;<br>mysql&gt; set long_query_time=1;<br>mysql&gt; show variables like &#x27;%long_query_time%&#x27;;<br></code></pre></td></tr></table></figure><p><code>show status like &#39;slow_queries&#39;</code> 显示有多少sql超时了</p><p> <code>mysqldumpslow</code> ：日志分析工具，给日志文件就可以定位sql。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#得到返回记录集最多的10个SQL<br>mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log<br><br>#得到访问次数最多的10个SQL<br>mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log<br><br>#得到按照时间排序的前10条里面含有左连接的查询语句<br>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log<br><br>#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况<br>mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more<br></code></pre></td></tr></table></figure><h3 id="④-PROFILE"><a href="#④-PROFILE" class="headerlink" title="④ PROFILE"></a>④ PROFILE</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;profiling&#x27;;<br>set profiling = &#x27;ON&#x27;;<br>show profiles; # 近几个查询<br>show profile; # 最近一个的细节   各个阶段耗时<br>show profile cpu,block io for query 2<br></code></pre></td></tr></table></figure><h3 id="⑤-EXPLAIN"><a href="#⑤-EXPLAIN" class="headerlink" title="⑤ EXPLAIN"></a>⑤ EXPLAIN</h3><p>不考虑各种Cache、不能显示优化工作、不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况 </p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055487.png" alt="image-20220628212049096" style="zoom: 80%;" /><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE s1 (<br>    id INT AUTO_INCREMENT,<br>    key1 VARCHAR(100),<br>    key2 INT,<br>    key3 VARCHAR(100),<br>    key_part1 VARCHAR(100),<br>    key_part2 VARCHAR(100),<br>    key_part3 VARCHAR(100),<br>    common_field VARCHAR(100),<br>    PRIMARY KEY (id),<br>    INDEX idx_key1 (key1),<br>    UNIQUE INDEX idx_key2 (key2),<br>    INDEX idx_key3 (key3),<br>    INDEX idx_key_part(key_part1, key_part2, key_part3)<br>) ENGINE=INNODB CHARSET=utf8;<br><br>CREATE TABLE s2 (<br>    id INT AUTO_INCREMENT,<br>    key1 VARCHAR(100),<br>    key2 INT,<br>    key3 VARCHAR(100),<br>    key_part1 VARCHAR(100),<br>    key_part2 VARCHAR(100),<br>    key_part3 VARCHAR(100),<br>    common_field VARCHAR(100),<br>    PRIMARY KEY (id),<br>    INDEX idx_key1 (key1),<br>    UNIQUE INDEX idx_key2 (key2),<br>    INDEX idx_key3 (key3),<br>    INDEX idx_key_part(key_part1, key_part2, key_part3)<br>) ENGINE=INNODB CHARSET=utf8;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。<br># Function<br>DELIMITER //<br>CREATE FUNCTION rand_string1(n INT)<br>RETURNS VARCHAR(255) #该函数会返回一个字符串<br>BEGIN<br>DECLARE chars_str VARCHAR(100) DEFAULT<br>&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;<br>    DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;<br>    DECLARE i INT DEFAULT 0;<br>    WHILE i &lt; n DO<br>        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));<br>        SET i = i + 1;<br>    END WHILE;<br>    RETURN return_str;<br>END //<br>DELIMITER ;<br><br># 存储过程<br>DELIMITER //<br>CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    SET autocommit = 0;<br>    REPEAT<br>    SET i = i + 1;<br>    INSERT INTO s1 VALUES(<br>        (min_num + i),<br>        rand_string1(6),<br>        (min_num + 30 * i + 5),<br>        rand_string1(6),<br>        rand_string1(10),<br>        rand_string1(5),<br>        rand_string1(10),<br>        rand_string1(10));<br>    UNTIL i = max_num<br>    END REPEAT;<br>    COMMIT;<br>END //<br>DELIMITER ;<br><br>DELIMITER //<br>CREATE PROCEDURE insert_s2 (IN min_num INT (10),IN max_num INT (10))<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    SET autocommit = 0;<br>    REPEAT<br>    SET i = i + 1;<br>    INSERT INTO s2 VALUES(<br>        (min_num + i),<br>        rand_string1(6),<br>        (min_num + 30 * i + 5),<br>        rand_string1(6),<br>        rand_string1(10),<br>        rand_string1(5),<br>        rand_string1(10),<br>        rand_string1(10));<br>    UNTIL i = max_num<br>    END REPEAT;<br>    COMMIT;<br>END //<br>DELIMITER ;<br><br># 调用<br>CALL insert_s1(10001,10000);<br>CALL insert_s2(10001,10000);<br></code></pre></td></tr></table></figure><h4 id="各列作用☆"><a href="#各列作用☆" class="headerlink" title="各列作用☆"></a>各列作用☆</h4><p>一条语句可多个select，一个select可from多个表，一个表一行记录</p><ol><li><p>&#x3D;&#x3D;<strong>table</strong>&#x3D;&#x3D;</p><p>对应表，每行记录都对应一个表。可能有临时表</p><p><code>EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</code> Union会构建临时表去重，一共3个</p></li><li><p>&#x3D;&#x3D;<strong>id</strong>&#x3D;&#x3D;</p><p>对应select个数，如子查询就有多个select</p><p>按照id从小到大执行，同一id前面的是驱动表</p></li><li><p><strong>&#x3D;&#x3D;select_type&#x3D;&#x3D;</strong>  小查询在整个大查询扮演的角色</p><ol><li>simple：简单 以及JOIN <code>EXPLAIN SELECT * FROM s1;</code>  <code>EXPLAIN SELECT * FROM s1 INNER JOIN s2;</code> </li><li>PRIMARY ：UNION最左边，子查询最外面的 <code>EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</code> s1</li><li>UNION：UNION剩下的 s2</li><li>UNION RESULT：UNION产生的临时表</li><li>SUBQUERY ：子查询里面<code>EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#39;a&#39;;</code></li><li>等等p137</li></ol></li><li><p>&#x3D;&#x3D;partition&#x3D;&#x3D;(分区相关)</p></li><li><p>&#x3D;&#x3D;type&#x3D;&#x3D; ☆</p><p>执行查询时的访问方法：<code>system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL</code> 。</p><ul><li><p><code>system</code> 一条记录且数据统计精准（MyISAM、Memory）</p></li><li><p><code>const</code> 主键或唯一二级索引与常数等值匹配</p></li><li><p><code>eq_ref</code> 连接时，被驱动表是通过主键或者唯一二级索引列</p></li><li><p><code>ref</code> 普通的二级索引列与常量进行等值匹配</p></li><li><p><code>index_merge</code> 条件为or时，同时用上多个索引</p></li><li><p>…</p></li><li><p><code>range</code> 索引的范围查询  <code>c1 IN (&#39;a&#39;, &#39;b&#39;)</code>   <code>c1 &gt; &#39;a&#39;</code>  <code>c1 LIKE &#39;abc%&#39;;</code></p></li><li><p><code>index</code> 索引覆盖，但需要扫描全部记录  <code>EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &#39;a&#39;;</code></p><p>​原因：扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p></li><li><p><code>ALL</code> 全表扫描</p><p><strong>system &gt; const &gt; eq_ref &gt; ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p><p>SQL 性能优化的目标：<strong>至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。</strong>（阿里巴巴 开发手册要求）</p></li></ul></li><li><p>&#x3D;&#x3D;possible_keys&#x3D;&#x3D;和&#x3D;&#x3D;key&#x3D;&#x3D;</p><p><code>可能用到的索引</code> 和 <code>实际用的</code>   ：<code>EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39; AND key3 = &#39;a&#39;;</code></p></li><li><p>&#x3D;&#x3D;key_len&#x3D;&#x3D; ☆</p><p>用上的索引字节长度，<strong>检查是否充分利用索引</strong>，主要针对联合索引。加上了变长和null</p><p>长度为 2个索引列 * （数据长度<em>3 utf-8 + 2变长字段 + 1null）  606 &#x3D; 2 * （100</em>3+2+1）</p><p><code>EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#39;a&#39; AND key_part2 = &#39;b&#39;; </code>   606 </p></li><li><p>&#x3D;&#x3D;ref&#x3D;&#x3D;</p><p>和索引列比较的结构是什么：const、s1.id、func等</p><p><code>WHERE s2 = &#39;a&#39;;</code>  <code>s1 INNER JOIN s2 ON s1.id = s2.id;</code>    <code>INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);</code></p></li><li><p>&#x3D;&#x3D;rows&#x3D;&#x3D;☆</p><p>预估的需要读取的记录条数，<code>值越小越好</code>。</p></li><li><p>&#x3D;&#x3D;filtered&#x3D;&#x3D;</p><p>加入条件时，剩下数据的比例。在驱动表中剩下越少，循环下一张表次数也就越少</p></li><li><p>&#x3D;&#x3D;Extra&#x3D;&#x3D;☆</p><ul><li><p><code>No tables used</code> </p></li><li><p><code>Impossible WHERE</code> where 永远false</p></li><li><p><code>Using where</code> 普通列</p></li><li><p><code>No matching min/max row</code> 有聚合函数但没有数据</p></li><li><p><code>Using index</code> 索引覆盖</p></li><li><p><code>Using index condition</code>   索引完后，先过滤key1 LIKE ‘%a’再去主表查询，<code>索引条件下推</code></p><p>​SELECT * FROM s1 WHERE key1 &gt; ‘z’ AND key1 LIKE ‘%a’; </p></li><li><p><code>Using join buffer (Block Nested Loop)</code>  被驱动表无索引，使用内存加速 <code>基于块的嵌套循环算法</code></p></li><li><p><code>Using filesort</code> 对普通列order by，需在内存或磁盘排序。慢！</p></li><li><p><code>Using temporary</code> 使用临时表：DISTINCT、 GROUP BY、UNION。<code>代价很大，最好使用索引来替代临时表</code></p></li></ul></li></ol><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><ol><li>传统格式</li><li>JSON格式  EXPLAIN FORMAT&#x3D;JSON</li><li>TREE格式  EXPLAIN FORMAT&#x3D;tree</li><li>Workbench可视化  快速查看</li></ol><h3 id="⑥-SHOW-WARNINGS"><a href="#⑥-SHOW-WARNINGS" class="headerlink" title="⑥ SHOW WARNINGS"></a>⑥ SHOW WARNINGS</h3><p><strong>查看完整SQL语句</strong>，涉及到内查询等优化器可能会帮我们优化掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * from s1 where key1 in (select key2 from s2 where common_field = &#x27;a&#x27;);<br>show warnings; # 内查询优化成了连接<br></code></pre></td></tr></table></figure><h3 id="⑦-trace：分析优化器执行"><a href="#⑦-trace：分析优化器执行" class="headerlink" title="⑦ trace：分析优化器执行"></a>⑦ trace：分析优化器执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 开启，结果保存到information_schema.optimizer_trace中<br>SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;<br>set optimizer_trace_max_mem_size=1000000;<br><br>select * from student where id &lt; 10;<br><br>select * from information_schema.optimizer_trace\G<br></code></pre></td></tr></table></figure><h3 id="⑧-sys-schema-：MySQL监控分析视图"><a href="#⑧-sys-schema-：MySQL监控分析视图" class="headerlink" title="⑧ sys schema ：MySQL监控分析视图"></a>⑧ sys schema ：MySQL监控分析视图</h3><p>查询需要消耗大量资源。查询结果来自  全部的数据库  的 全部的表</p><p>索引情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 查询冗余索引<br>select * from sys.schema_redundant_indexes;<br>#2. 查询未使用过的索引<br>select * from sys.schema_unused_indexes;<br>#3. 查询索引的使用情况<br>select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted<br>from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27;;<br></code></pre></td></tr></table></figure><p>表相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 查询表的访问量<br>select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from<br>sys.schema_table_statistics group by table_schema,table_name order by io desc;<br># 2. 查询占用bufferpool较多的表<br>select object_schema,object_name,allocated,data<br>from sys.innodb_buffer_stats_by_table order by allocated limit 10;<br># 3. 查看表的全表扫描情况<br>select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;<br></code></pre></td></tr></table></figure><p>语句相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 监控SQL执行的频率<br>select db,exec_count,query from sys.statement_analysis<br>order by exec_count desc;<br>#2. 监控使用了排序的SQL<br>select db,exec_count,first_seen,last_seen,query<br>from sys.statements_with_sorting limit 1;<br>#3. 监控使用了临时表或者磁盘临时表的SQL<br>select db,exec_count,tmp_tables,tmp_disk_tables,query<br>from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0<br>order by (tmp_tables+tmp_disk_tables) desc;<br></code></pre></td></tr></table></figure><p>IO相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 查看消耗磁盘IO的文件<br>select file,avg_read,avg_write,avg_read+avg_write as avg_io<br>from sys.io_global_by_file_by_bytes order by avg_read limit 10;<br></code></pre></td></tr></table></figure><p>Innodb 相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 行锁阻塞情况<br>select * from sys.innodb_lock_waits;<br></code></pre></td></tr></table></figure><h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="~索引优化与查询优化"></a>~索引优化与查询优化</h2><p>需要调优的角度：</p><ul><li>索引失效、没有充分利用到索引——建立索引  <code>物理查询优化</code></li><li>关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化 <code>逻辑查询优化</code></li><li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li><li>数据过多——分库分表</li></ul><h3 id="①-数据准备"><a href="#①-数据准备" class="headerlink" title="① 数据准备"></a>① 数据准备</h3><p><code>学员表</code> 插 <code>50万</code> 条，<code> 班级表</code> 插 <code>1万</code> 条。</p><h3 id="②-索引失效案例☆"><a href="#②-索引失效案例☆" class="headerlink" title="② 索引失效案例☆"></a>② 索引失效案例☆</h3><p>用B+树推理出来即可！</p><h4 id="2-1-全值匹配我最爱"><a href="#2-1-全值匹配我最爱" class="headerlink" title="2.1 全值匹配我最爱"></a>2.1 全值匹配我最爱</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 没有索引时全部遍历<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30;<br></code></pre></td></tr></table></figure><h4 id="2-2-最佳左前缀法则"><a href="#2-2-最佳左前缀法则" class="headerlink" title="2.2 最佳左前缀法则"></a>2.2 最佳左前缀法则</h4><p>最左边能匹配就能用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_age_classid_name ON student(age,classId,name);<br><br># 能用<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId=4;<br><br># 不能用<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId=4 AND student.age=30 AND student.name = &#x27;abcd&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-3-主键插入顺序"><a href="#2-3-主键插入顺序" class="headerlink" title="2.3 主键插入顺序"></a>2.3 主键插入顺序</h4><p>主键<code>AUTO_INCREMENT</code> ，防止<strong>页面分裂</strong>：把本页中的一些记录移动到新创建的这个页中</p><h4 id="2-4-计算、函数、类型转换-自动或手动-导致索引失效"><a href="#2-4-计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="2.4 计算、函数、类型转换(自动或手动)导致索引失效"></a>2.4 计算、函数、类型转换(自动或手动)导致索引失效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_name ON student(NAME);<br># 可以用上<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;<br><br># 函数千奇百怪，不知道返回什么，所以用不上<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-5-类型转换导致索引失效"><a href="#2-5-类型转换导致索引失效" class="headerlink" title="2.5 类型转换导致索引失效"></a>2.5 类型转换导致索引失效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 未使用到索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;<br># 使用到索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-6-范围条件右边的列索引失效"><a href="#2-6-范围条件右边的列索引失效" class="headerlink" title="2.6 范围条件右边的列索引失效"></a>2.6 范围条件右边的列索引失效</h4><p>联合索引，范围查询的后面列无法用上索引。但<code>c2 like &#39;c%&#39;</code>后面的可以用上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CAll proc_drop_index(&#x27;atguigudb2&#x27;, &#x27;student&#x27;);<br>CREATE INDEX idx_age_classid_name ON student(age,name,classId);<br><br># 用不上 key_len=68<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 3 and name &gt; &#x27;c&#x27; and classId = 20;<br># 用得上 key_len=73<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 3 and name like &#x27;c%&#x27; and classId = 20;<br></code></pre></td></tr></table></figure><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。创建的联合索引中，务必把范围涉及到的字段写在最后</p></blockquote><h4 id="2-7-不等于-x3D-或者-lt-gt-索引失效"><a href="#2-7-不等于-x3D-或者-lt-gt-索引失效" class="headerlink" title="2.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效"></a>2.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效</h4><p>不等于不能用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name &lt;&gt; &#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-8-is-null可以使用索引，is-not-null无法使用索引"><a href="#2-8-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="2.8 is null可以使用索引，is not null无法使用索引"></a>2.8 is null可以使用索引，is not null无法使用索引</h4><p>道理同上</p><blockquote><p>结论：最好在设计数据库的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将 INT 类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)。</p><p>扩展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描。</p></blockquote><h4 id="2-9-like以通配符-开头索引失效"><a href="#2-9-like以通配符-开头索引失效" class="headerlink" title="2.9 like以通配符%开头索引失效"></a>2.9 like以通配符%开头索引失效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name LIKE &#x27;%ab&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>拓展：Alibaba《Java开发手册》 </p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><h4 id="2-10-OR-前后存在非索引的列，索引失效"><a href="#2-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="2.10 OR 前后存在非索引的列，索引失效"></a>2.10 OR 前后存在非索引的列，索引失效</h4><p>or纯在非索引导致失效，and不会</p><p>因为OR的含义就是两个只要满足一个即可，因此<code>只有一个条件列进行了索引是没有意义的</code>，只要有条件列没有进行索引，就会进行<code>全表扫描</code>，因此所以的条件列也会失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 加入只有age有索引<br># 未使用到索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;<br></code></pre></td></tr></table></figure><h4 id="2-11-数据库和表的字符集统一使用utf8mb4"><a href="#2-11-数据库和表的字符集统一使用utf8mb4" class="headerlink" title="2.11 数据库和表的字符集统一使用utf8mb4"></a>2.11 数据库和表的字符集统一使用utf8mb4</h4><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不 同的 <code>字符集</code> 进行比较前需要进行 <code>转换</code> 会造成索引失效。</p><h3 id="③-关联查询优化"><a href="#③-关联查询优化" class="headerlink" title="③ 关联查询优化"></a>③ 关联查询优化</h3><h4 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h4><h4 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h4><p>不是绝对的左边为驱动表，如果左边有索引可能会变成被驱动表</p><p>驱动表<code>Using joion buffer</code> 使用缓存；添加索引被驱表可以走索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;<br></code></pre></td></tr></table></figure><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><p>优化器选择驱动表，选择有索引的或者大表作为被驱动表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;<br></code></pre></td></tr></table></figure><h4 id="JOIN原理"><a href="#JOIN原理" class="headerlink" title="JOIN原理"></a>JOIN原理</h4><p>MySQL5.5版本之前，只有嵌套循环。后来引入BNLJ算法优化嵌套查询。8.0.18引入Hash Join</p><h5 id="1-Simple-Nested-Loop-Join"><a href="#1-Simple-Nested-Loop-Join" class="headerlink" title="1.Simple Nested-Loop Join"></a>1.Simple Nested-Loop Join</h5><p>简单嵌套循环连接：相当于两层循环。比较了<code>A * B</code>次，读取了A+AB次记录。</p><h5 id="2-Index-Nested-Loop-Join"><a href="#2-Index-Nested-Loop-Join" class="headerlink" title="2. Index Nested-Loop Join"></a>2. Index Nested-Loop Join</h5><p>索引嵌套循环连接：被驱表走索引然后回表。比较<code>A*height</code>，读取了<code>A+B(match)</code></p><h5 id="3-Block-Nested-Loop-Join"><a href="#3-Block-Nested-Loop-Join" class="headerlink" title="3.Block Nested-Loop Join"></a>3.Block Nested-Loop Join</h5><p>块嵌套循环连接：引入块join buffer，把驱动表（分成一个个块）放在缓存中。被驱动一次比较一块驱动表记录，相当于外层循环变小了</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055488.png" alt="image-20230304103951379"></p><p>通过<code>show variables like &#39;%optimizer_switch%&#39;</code> 查看 <code>block_nested_loop</code>状态。默认是开启的。</p><p>这里缓存的不只是关联表的列，select后面的列也会缓存起来。</p><p>比较了<code>A * B</code>，读取了 <code>A + 块数*B</code>，访问磁盘次数少了</p><blockquote><p> join_buffer_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。</p></blockquote><h5 id="4-Hash-Join"><a href="#4-Hash-Join" class="headerlink" title="4. Hash Join"></a>4. Hash Join</h5><p><strong>等值连接</strong>。对BNLJ进一步优化，针对小表直接建立Hash表，大表每一条比较时间降低到O1</p><p>如果能完全放下小表，时间为A+B。如果不能放下需分块，相当于大表还是一次比较一整块记录，但时间优化到O1</p><h3 id="④-子查询"><a href="#④-子查询" class="headerlink" title="④ 子查询"></a>④ 子查询</h3><p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询 <code>不需要建立临时表</code> ，其 <code>速度比子查询</code> 要快 ，如果查询中使用索引的话，性能就会更好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM student stu1<br>WHERE stu1.`stuno` IN (<br>SELECT monitor<br>FROM class c<br>WHERE monitor IS NOT NULL<br>)<br># 优化<br>EXPLAIN SELECT stu1.* FROM student stu1 JOIN class c<br>ON stu1.`stuno` = c.`monitor`<br>WHERE c.`monitor` is NOT NULL;<br></code></pre></td></tr></table></figure><h3 id="⑤-排序"><a href="#⑤-排序" class="headerlink" title="⑤ 排序"></a>⑤ 排序</h3><p><code>FileSort</code> （内存中，占CPU）或 <code>Index</code> 排序。</p><p>还可以使用联合索引，where用一部分，order后一部分， <code>WHERE a = const AND b = const ORDER BY c</code></p><p>是否用所以还需要看排序代价，不大可以直接排序</p><h4 id="双路和单路排序"><a href="#双路和单路排序" class="headerlink" title="双路和单路排序"></a>双路和单路排序</h4><p>双路：只拿排序列数据，排完序后再全部遍历取出需要列。</p><p>单路：直接所有需要列区排序，但需要更多<code>sort_buffer_size</code>，默认1MB。如果数据量大于<code>max_length_for_sort_data</code>（1024~8192B）转用单路。</p><p>所以select * 在这是大忌。</p><ul><li>where效率高于having，能写在where限定的条件就不要写在having中了 </li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内</li></ul><h3 id="⑥-优化分页查询"><a href="#⑥-优化分页查询" class="headerlink" title="⑥ 优化分页查询"></a>⑥ 优化分页查询</h3><p><code>select * from sutdent limit 1000000,10</code>这种头疼问题</p><p>本来需要回表&gt;1000000，现在只需要回表10；使用连接优化子查询</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055489.png" alt="image-20230304122824862"></p><h3 id="⑦-索引覆盖"><a href="#⑦-索引覆盖" class="headerlink" title="⑦ 索引覆盖"></a>⑦ 索引覆盖</h3><p><code>索引列+主键</code> 包含 <code>SELECT 到 FROM之间查询的列</code> </p><p>索引覆盖可以提高速度，回表的IO很可能是随机IO（数据不连续）。但有维护代价，业务DBA（业务数据架构师）的工作。</p><p>此外，就算使用！&#x3D;导致索引失效，如果可以索引覆盖还是会去使用索引，因为二级索引更小遍历代价更低。</p><h3 id="⑧-索引条件下推"><a href="#⑧-索引条件下推" class="headerlink" title="⑧ 索引条件下推"></a>⑧ 索引条件下推</h3><p>​&#x3D;&#x3D;先过滤再回表&#x3D;&#x3D;</p><p>通常针对联合索引，(c1, c2, c3)   c1能使用但c2 c3用不了。c1用完索引后先c2 c3遍历过滤后再回表。</p><p>ICP的开启和关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set optimizer_switch = &#x27;index_condition_pushdown=on&#x27;  或者off<br><br>执行语句时关闭<br>select /*+ no_icp (table_name) */ * from table_name  where ...<br></code></pre></td></tr></table></figure><h3 id="⑨-其他优化策略"><a href="#⑨-其他优化策略" class="headerlink" title="⑨ 其他优化策略"></a>⑨ 其他优化策略</h3><h4 id="exists-和-in"><a href="#exists-和-in" class="headerlink" title="exists 和 in"></a>exists 和 in</h4><p>exists用外表驱动内表，拿一条条外表数据去内表查（相关子查询）       适合外小内大<br>in反过来，先查询内表，再拿数据去外表走索引                        </p><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT(*)"></a>COUNT(*)</h4><p><code>SELECT COUNT(*) 、 SELECT COUNT(1)</code>基本等价，效率相等，&#x3D;&#x3D;自动选取小空间的二级索引&#x3D;&#x3D;。MyISAM维护了变量</p><p><code>SELECT COUNT(具体字段)</code>尽量建立二级索引。</p><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT(*)"></a>SELECT(*)</h4><ul><li>需要先查询数据字典将*转换为列名</li><li>无法使用覆盖索引</li><li>空间更大</li></ul><h4 id="LIMIT-1"><a href="#LIMIT-1" class="headerlink" title="LIMIT 1"></a>LIMIT 1</h4><p>在确定数据唯一，并且无唯一索引时，可以提前结束扫描，加速。</p><h4 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h4><p>COMMIT 所释放的资源： </p><ul><li>回滚段上用于恢复数据的信息 </li><li>被程序语句获得的锁 </li><li>redo &#x2F; undo log buffer 中的空间 </li><li>管理上述 3 种资源中的内部花费</li></ul><h3 id="⑩-淘宝数据库，主键如何设计的？"><a href="#⑩-淘宝数据库，主键如何设计的？" class="headerlink" title="⑩ 淘宝数据库，主键如何设计的？"></a>⑩ 淘宝数据库，主键如何设计的？</h3><h4 id="自增ID的问题"><a href="#自增ID的问题" class="headerlink" title="自增ID的问题"></a>自增ID的问题</h4><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除 了简单，其他都是缺点，总体来看存在以下几方面的问题：</p><ol><li><p><strong>可靠性不高</strong></p><p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。 </p></li><li><p>**安全性不高 **</p><p>对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F;这样的接口，可以非常容易猜测用户ID的 值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。 </p></li><li><p><strong>性能差</strong> </p><p>自增ID的性能较差，需要在数据库服务器端生成。 </p></li><li><p><strong>交互多</strong> </p><p>业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的 网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。 </p></li><li><p>**局部唯一性 **</p><p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都 是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p></li></ol><h4 id="业务字段做主键"><a href="#业务字段做主键" class="headerlink" title="业务字段做主键"></a>业务字段做主键</h4><p>会员卡中的卡号：但如果用户注销了，购买记录还会给新的人。</p><p>身份证号：隐私问题等</p><blockquote><p>经验： 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业 务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p></blockquote><h4 id="淘宝的主键设计"><a href="#淘宝的主键设计" class="headerlink" title="淘宝的主键设计"></a>淘宝的主键设计</h4><p>淘宝的订单号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1550672064762308113<br>1481195847180308113<br>1431156171142308113<br>1431146631521308113<br><br>猜测：订单ID = 时间 + 去重字段 + 用户ID后6位尾号<br></code></pre></td></tr></table></figure><h4 id="推荐主键设计"><a href="#推荐主键设计" class="headerlink" title="推荐主键设计"></a>推荐主键设计</h4><p><strong>非核心业务</strong> ：对应表的主键自增ID，如告警、日志、监控等信息。</p><p><strong>核心业务</strong> ：<code>主键设计至少应该是全局唯一且是单调递增</code>。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。</p><h5 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h5><p>32个16进制数，纯数占用16B。实际占用36B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）<br><br>时间：100ns区别。秒在前面所以不是自增<br>36字节：字符串存储，且带有无用字符-<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055490.png" alt="image-20230305102015371"></p><h5 id="改造UUID"><a href="#改造UUID" class="headerlink" title="改造UUID"></a><strong>改造UUID</strong></h5><p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0</p><p>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的<code>-</code>字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p><p>MySQL8.0提供<code>uuid_to_bin</code>，<code>bin_to_uuid</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @uuid = UUID();<br>SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);<br></code></pre></td></tr></table></figure><h5 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h5><p>mybatis-plus默认，并且会将id自动set到实体对象中</p><ol><li>能满足高并发分布式系统环境下ID不重复</li><li>基于时间戳，可以保证基本有序递增</li><li>不依赖第三方的库或者中间件</li><li>生成效率极高</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> - <span class="hljs-number">0000000000</span> <span class="hljs-number">0000000000</span> <span class="hljs-number">0000000000</span> <span class="hljs-number">0000000000</span> <span class="hljs-number">0</span> - <span class="hljs-number">0000000000</span> - <span class="hljs-number">000000000000</span><br><br>符号位             时间戳                                机器码      序列号<br><span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="hljs-comment">//</span><br>                | (workerId &lt;&lt; workerIdShift) <span class="hljs-comment">//</span><br>                | sequence;<br></code></pre></td></tr></table></figure><ul><li>41位存储毫秒级时间戳，这个时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的ID生成器开始使用的时间，一般为项目创建时间，就是下面实现中代码的twepoch 属性，生成器根据时间戳插值进行初次尝试创建ID。</li><li>10位存储机器码，最多支持1024台机器，当并发量非常高，同时有多个请求在同一毫秒到达，可以根据机器码进行第二次生成。机器码可以根据实际需求进行二次划分，比如两个机房操作可以一个机房分配5位机器码。</li><li>12位存储序列号，当同一毫秒有多个请求访问到了同一台机器后，此时序列号就派上了用场，为这些请求进行第三次创建，最多每毫秒每台机器产生2的12次方也就是4096个id，满足了大部分场景的需求。</li></ul><blockquote><p>在Web开发中需要跟js打交道，而js支持最大的整型范围为53位，超过这个范围就会丢失精度，53之内可以直接由js读取，超过53位就需要转换成字符串才能保证js处理正确。</p><p>或者53位存储的话，32位存储秒级时间戳，5位存储机器码，16位存储序列化，这样每台机器每秒可以生产65536个不重复的id。</p></blockquote><h2 id="数据库设计规则"><a href="#数据库设计规则" class="headerlink" title="~数据库设计规则"></a>~数据库设计规则</h2><p>什么数据 什么表、crud时的约束检查、减低数据冗余度、方便数据库维护使用</p><p>表结构的调整代价很大</p><h3 id="①-范数"><a href="#①-范数" class="headerlink" title="① 范数"></a>① 范数</h3><p>关系型数据库的基本原则。但有时为了提高性能还会破坏规则，反规范化（降低冗余度，但业务可能复杂了）</p><p>六种：</p><ul><li>第一范式：列不能再分</li><li>第二范式：非主属性消除部分依赖</li><li>第三范式：非主属性消除传递依赖（平衡）</li><li>巴斯-科德范式：候选键只有一个，或者每个候选键都是单属性。主属性消除部分依赖</li><li>第四范式：不存在多组 多值依赖（一对多）：职工表（职工id，孩子姓名，职工课程），需要拆开</li><li>第五范式：理论研究</li></ul><p>找出所有码 -&gt; 主属性、非主属性 -&gt; 检查部分函数依赖 -&gt; 检查传递函数依赖</p><h4 id="键和相关概念"><a href="#键和相关概念" class="headerlink" title="键和相关概念"></a>键和相关概念</h4><ul><li><code>超键</code>：能唯一标识元组的属性集</li><li><code>候选键</code>：超键且不包括多余属性，可以多个 ；码</li><li><code>主键</code>：从候选键中选一个</li><li><code>外键</code>：R1中的属性不是R1的主键，而是R2的</li><li><code>主属性</code>：所有候选键中的所有属性</li><li><code>非主属性</code></li></ul><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>每个字段都<strong>不能拆分</strong>了，如不能把电话、姓名、地址都放到一个字段中。</p><p>first name，lastname是否拆分要看具体的业务需求</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p><strong>所有非主键完全依赖于候选键</strong>，如果存在<code>部分依赖，则抽出来新建表</code></p><p>成绩表：要想知道成绩，完全依赖于（学号、课程号）</p><p>在学生的成绩表中，不再放学生的地址等信息</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>非主属性C直接相关于主属性A，而不能依赖于其他非主属性B：主属性A-&gt;非主属性B-&gt;非属性C</p><p><strong>员工表</strong>中只放部门编号，不放部门其他信息，这些信息可以通过join查询获得</p><p><strong>商品表</strong>中只放商品类别id，不放类别名称</p><h3 id="②-反范式"><a href="#②-反范式" class="headerlink" title="② 反范式"></a>② 反范式</h3><p><code>业务优先</code>，增加冗余字段来提高读性能。空间换时间。<code>冗余字段修改需要同步</code></p><p><strong>员工表</strong>的查询经常要部门名称，加进来；商品表同理。<strong>违反了第三范式</strong></p><p><strong>学生表</strong>和<strong>课程评论表</strong>，查询课程的评论时经常要用学生名称</p><p>学生表100w，评论表100w</p><p>查询某课程的前10000条评论的姓名和评论；反范式化后，把学生姓名加入评论表</p><p>0.1 -&gt; 0.036</p><p>&#x3D;&#x3D;条件&#x3D;&#x3D;：冗余字段不常修改  且  查询时必要</p><h2 id="数据库其他调优"><a href="#数据库其他调优" class="headerlink" title="~数据库其他调优"></a>~数据库其他调优</h2><p>从更大的层面来优化，主要就是下面这张表。垂直分库分表、读写分离</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055491.png" alt="image-20230307161933988"></p><p><strong>目标</strong>：吞吐量更大、响应速度更快</p><p><strong>问题发现</strong>：用户反馈、日志</p><h3 id="①-调优步骤"><a href="#①-调优步骤" class="headerlink" title="① 调优步骤"></a>① 调优步骤</h3><h4 id="1-合适的DBMS"><a href="#1-合适的DBMS" class="headerlink" title="1.合适的DBMS"></a>1.合适的DBMS</h4><p>事务以及安全性要求高，选择SQL Server、Oracle。单表可以存储上亿条数据。</p><h4 id="2-优化表设计"><a href="#2-优化表设计" class="headerlink" title="2.优化表设计"></a>2.优化表设计</h4><p>尽量遵循第三范式 并且 适当运用反范式</p><p>数据类型选择合适的</p><h4 id="3-优化逻辑查询"><a href="#3-优化逻辑查询" class="headerlink" title="3.优化逻辑查询"></a>3.优化逻辑查询</h4><p>SQL的重写：子查询变join</p><h4 id="4-优化物理查询"><a href="#4-优化物理查询" class="headerlink" title="4.优化物理查询"></a>4.优化物理查询</h4><p>索引</p><h4 id="5-使用Redis缓存"><a href="#5-使用Redis缓存" class="headerlink" title="5.使用Redis缓存"></a>5.使用Redis缓存</h4><p>redis支持持久化，除了内存还可以将数据放到硬盘上</p><h4 id="6-库级优化"><a href="#6-库级优化" class="headerlink" title="6.库级优化"></a>6.库级优化</h4><p>站在数据库维度进行优化。</p><p>多台机器读写分离、<code>分库分表</code>切割数据库</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055491.png" alt="image-20230307161933988"></p><h3 id="②-优化MySQL服务器"><a href="#②-优化MySQL服务器" class="headerlink" title="② 优化MySQL服务器"></a>② 优化MySQL服务器</h3><p>硬件层面：<code>大内存</code>、<code>高速磁盘系统(SCSI -&gt; SSD) </code>，<code>合理分布磁盘I/O</code>，<code>配置多处理器</code></p><p>MySQL参数：<code>innodb_buffer_pool_size (表、索引)</code>、<code>key_buffer_size </code>、<code>table_cache </code>、<code>query_cache_size(查询缓存、8.0没有)</code>、<code>sort_buffer_size(排序)</code>、<code>join_buffer_size(join缓存)</code>、<code>max_connections(默认151)</code></p><h3 id="③-表结构优化"><a href="#③-表结构优化" class="headerlink" title="③ 表结构优化"></a>③ 表结构优化</h3><h4 id="冷热数据分离"><a href="#冷热数据分离" class="headerlink" title="冷热数据分离"></a>冷热数据分离</h4><p>拆分：<code>会员表</code> 存储会员登录认证信息，该表中有很多字段，如<code>id、姓名、密码、地址、电 话、个人描述</code>字段。其中<code>地址、电话、个人描述</code>等字段并不常用，可以将这些不常用的字段分解出另一个表。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055492.png" alt="image-20230307161748616"></p><h4 id="增加中间表"><a href="#增加中间表" class="headerlink" title="增加中间表"></a>增加中间表</h4><p>经常需要联合查询的数据，直接多开一个中间表</p><h4 id="增加冗余字段"><a href="#增加冗余字段" class="headerlink" title="增加冗余字段"></a>增加冗余字段</h4><p>反范数</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>整数</strong>：通常int，unsigned要用就用</p><p><strong>TIMESTAMP</strong>：TIMESTAMP存储的时间范围1970-01-01 00:00:01 ~ 2038-01_19-03:14:07。TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。</p><p><strong>DECIMAL</strong>代替FLOAT和DOUBLE存储精确浮点数：精准的浮点数、4B存储9位，且可以存储比bigint大的整型数据</p><h3 id="④-大表优化"><a href="#④-大表优化" class="headerlink" title="④ 大表优化"></a>④ 大表优化</h3><h4 id="1-限定查询的范围"><a href="#1-限定查询的范围" class="headerlink" title="1 限定查询的范围"></a>1 限定查询的范围</h4><p>禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制 在一个月的范围内；</p><h4 id="2-读-x2F-写分离"><a href="#2-读-x2F-写分离" class="headerlink" title="2 读&#x2F;写分离"></a>2 读&#x2F;写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055493.png" alt="image-20230307161543744"></p><h4 id="3-垂直拆分"><a href="#3-垂直拆分" class="headerlink" title="3.垂直拆分"></a>3.垂直拆分</h4><p>冷热数据分离，也可以是经常使用的放一起</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055494.png" alt="image-20230307161824905"></p><h4 id="4-水平拆分"><a href="#4-水平拆分" class="headerlink" title="4.水平拆分"></a>4.水平拆分</h4><p>数据量尽量控制在1000w以内</p><p>按某个属性如年份划分到不同的表</p><p>但表数据还是同一个机器上，并发量还是上不去，还是<code>分库</code>比较好。</p><p>拆分会带来逻辑、部署、运维的复杂度</p><h2 id="事务"><a href="#事务" class="headerlink" title="~事务"></a>~事务</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055495.png" alt="image-20230311180107196"></p><p>MySQL中，只有InnoDB支持事务。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a><strong>ACID</strong></h4><p><strong>原子性（atomicity）：</strong> 不可分割</p><p><strong>一致性（consistency）：</strong> 数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。</p><p><strong>隔离型（isolation）：</strong><code>不能被其他事务干扰</code>，<strong>锁</strong>来实现。下小节为对应隔离级别</p><p><strong>持久性（durability）：</strong> 提交后<code>永久改变</code>。通过 <code>事务日志</code>（<code>重做日志</code> 和 <code>回滚日志</code>）来实现</p><h4 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h4><p>提交或者中止是一个事务生命周期的结束</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055496.png" alt="image-20230311175427170" style="zoom: 50%;" /><h4 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 显式事务会关闭自动提交<br>BEGIN;<br>#或者<br>START TRANSACTION (READ ONLY \ READ WRITE);<br><br>SAVEPOINT savepoint_name<br># 将事务回滚到某个保存点。 事务还没结束<br>ROLLBACK TO [SAVEPOINT]<br><br>## 结束事务<br># 提交事务。当提交事务后，对数据库的修改是永久性的。<br>COMMIT;<br># 回滚事务。即撤销正在进行的所有没有提交的修改<br>ROLLBACK;<br></code></pre></td></tr></table></figure><h4 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;autocommit&#x27;; <br>ON # 每个语句自动提交事务<br>SET autocommit = on\1 ;  OFF\0<br></code></pre></td></tr></table></figure><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>在并发场景下（若干个客户端连接），如何处理隔离</p><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><ol><li><p><strong>脏写</strong>（ Dirty Write ）：B在更新时，A先更新且commit了，但B rollback了，吞掉了A的更新。（实际上A需要排队）</p></li><li><p><strong>脏读</strong>（ Dirty Read ）：读取到了还没commit的数据</p></li><li><p><strong>不可重复读</strong>（ Non-Repeatable Read ）：一个事务两次读之间，值被别的人commit改了，导致每次读取不一样</p></li><li><p><strong>幻读</strong>（ Phantom ）：两次读之间，<code>插入</code>了一些新行（幻影记录）。</p></li></ol><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>解决上面的问题</p><p>1.<strong>读未提交</strong>（Read uncommitted）：内存有直接读内存</p><p>​    这种事务隔离级别下，select语句不加锁。</p><p>​    此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。</p><p>2.<strong>读已提交</strong>（Read committed）：读磁盘  Oracle</p><p>​    可避免 脏读 的发生。</p><p>​    在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。</p><p>3.<strong>可重复读</strong>（Repeatable read）：MySql  <code>SHOW VARIABLES LIKE &#39;tx_isolation&#39;;</code> <code>transaction_isolation</code></p><p>​    事务开始前尽可能创建快照（内存）。</p><p>​查询时<strong>先在快照区</strong>中查找数据的快照，如果快照区中没有该数据的快照，MySQL 就会<strong>再 undo 日志</strong>中查找该数据最新的修改操作，并将其还原到快照区中，然后再将数据返回给事务</p><p>​mysql其实也可以解决幻读，在锁里讲</p><p>4.<strong>串行化</strong>（Serializable ）：</p><p>​    可避免幻读</p><p>​加了行X锁，比如s1查询了id&#x3D;3的数据，s2的插入就会阻塞</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055497.png" alt="image-20230311183443046"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql，想永久修改需要修改配置文件<br>SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#x27;隔离级别&#x27;<br>#其中，隔离级别格式：<br>&gt; READ-UNCOMMITTED<br>&gt; READ-COMMITTED<br>&gt; REPEATABLE-READ<br>&gt; SERIALIZABLE<br></code></pre></td></tr></table></figure><blockquote><p>隔离级别越高，数据一致性就越好，但并发性越弱。</p></blockquote><h2 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h2><p>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。存储引擎层 (innodb) 生成</p><ul><li><p>REDO LOG 称为 <code>重做日志 </code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<strong>持久性</strong>。</p><p><code>&quot;物理级别&quot;</code>上的页修改操作，比如页号xxx，偏移量yyy写入了’zzz’数据。</p></li><li><p>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的<strong>原子性</strong>、一致性。</p><p> <code>逻辑操作</code> 日志，INSERT则会记录一条对应DELETE。用于 <code>事务的回滚</code>和 <code>一致性非锁定读</code></p></li></ul><p>COMMIT用REDO实现，ROLLBACK用UNDO实现。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055498.png" alt="image-20230313105558624"></p><h3 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h3><p>保证事务的<strong>持久性</strong>。</p><ul><li>首先需要读取<code>磁盘</code> -&gt; 内存中的<code>Buffer Pool</code></li><li>发生修改更先更新<code>Buffer Pool</code>，再更新<code>磁盘</code>；更新了但没写入磁盘的叫<code>脏页</code>。</li><li>内存是正确的，但刷盘是比较慢的且可能宕机， 为了保证磁盘数据是正确的：<ol><li>疯狂一直刷盘（代价大），并且事务修改不相邻页面时，IO是<code>随机IO</code></li><li>引入redo日志</li></ol></li></ul><p>WAL技术 (<code>Write-Ahead Logging</code>)：先写日志（写入了就算事务成功），再写磁盘。</p><p>实现更低频率更高速度的刷盘：</p><ul><li>低频：redo日志占用的<code>空间小</code>（存储表空间ID、页号、偏移量以及需要更新的值）</li><li>高速：<code>顺序IO</code></li></ul><h4 id="redo特点"><a href="#redo特点" class="headerlink" title="redo特点"></a>redo特点</h4><ul><li><p><strong>redo日志是顺序写入磁盘的</strong></p><p>一个事务多条语句,一条语句多条redo日志，这些日志是按照<code>产生的顺序写入磁盘的</code>，也就是使用顺序ID，效率比随机IO快。</p></li><li><p><strong>事务执行过程中，redo log不断记录</strong></p><p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p></li></ul><h4 id="redo日志组成"><a href="#redo日志组成" class="headerlink" title="redo日志组成"></a>redo日志组成</h4><ul><li><code>重做日志的缓冲 (redo log buffer)</code>：内存 <code>innodb_log_buffer_size</code> 16MB</li><li><code>重做日志文件 (redo log file) </code>：mysql&#x2F;data&#x2F;ib_logfile0  ib_logfile1</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055499.png" alt="image-20230312214754687"></p><blockquote><p>先持久化日志，再持久化数据(在commit后才会持久化)</p></blockquote><p>至此，关键的刷盘变成了<code>步骤3</code>，由参数<code>innodb_flush_log_at_trx_commit</code>控制</p><ul><li><code>设置为0</code> ：表示每次事务提交时不进行刷盘操作。</li><li><code>设置为2</code> ：表示每次事务提交时都只把 <code>redo log buffer</code> 内容写入 <code>page cache</code>（OS对写入磁盘的优化，由OS决定，有小概率宕机），不进行同步。由os自己决定什么时候同步到磁盘文件。此时MYSQL挂了不影响</li><li><code>设置为1</code> ：表示每次事务提交时都将进行同步（写入<code>page cache</code>并<code>同步磁盘</code>）（ 默认值，持久性的保证 ）</li></ul><p>此外：系统默认master thread每隔<strong>1s</strong>进行一次重做日志的同步：<code>redo log buffer</code>到<code>page cache</code>，然后刷盘</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055500.png" alt="image-20230312223435328"></p><p>或者写满<code>innodb_log_buffer_size</code>后刷盘。</p><h4 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h4><p>一个原子操作为一个<code>Mini-Transaction</code>，如一次插入。但一次插入可能移动多条数据，对应多个redo</p><p>一个MTR里的多个redo需要放在一起（不可分割），但一个事务内的多个MTR可以分割存放</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055501.png" alt="image-20230313101247985" style="zoom:67%;" /><p>t1、t2为两个事务，mtr_t1_1由多条redo组成<br>buffer由block组成，一个block512字节 <code>innodb_log_block_size</code>，对应一个扇区的大小</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055502.png" alt="image-20230313101924121"></p><p>头包含指针、已使用多少等信息</p><h4 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h4><ul><li><p><code>innodb_log_group_home_dir</code> 文件路径</p></li><li><p><code>innodb_log_files_in_group</code> 默认2组</p></li><li><p><code>innodb_log_file_size</code>  单个 redo log 文件设置大小，默认值为 <code>48M</code> </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055503.png" alt="image-20230313104804144"></p><p><code>write pos</code>指针（终点）：当前插入点</p><p><code>checkpoint</code>指针（起点）：checkpoint 和 write pos 之间为在内存中但还没写入磁盘，故障后需要恢复这部分数据</p></li><li><p><code>innodb_flush_log_at_trx_commit</code> 刷盘策略</p></li></ul><h4 id="施放时间"><a href="#施放时间" class="headerlink" title="施放时间"></a>施放时间</h4><ul><li>redo log 在事务的执行过程中不断记录。通常在事务提交时buffer-&gt;file。</li><li>理论上redo log file中的文件在数据写入磁盘（图4）后可以释放</li></ul><h3 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h3><p>更新数据前先更新undo log。在系统表空间，也可以使用独立表空间</p><p><strong>原子性：</strong>要么都做，要么都不做。可能发生意外，如何<code>逻辑恢复</code>到之前状态</p><ul><li>服务器错误、断电</li><li>手动ROLLBACK</li></ul><p>增删改都要记录反向操作</p><blockquote><p> undo日志为了实现持久化，需要同样会<strong>产生redo日志</strong>。</p></blockquote><p>在内存数据更新前先更新undo</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>作用1：回滚数据</strong></li><li><strong>作用2：MVCC</strong>（多版本并发控制）。当读取一条被占用的数据时，用undo读取之前的信息</li></ul><h4 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h4><p><code>innodb_undo_logs</code>个回滚段。一个回滚段多个页，一个页（可服务于多个事务，重用防止浪费）存放undo记录，</p><h4 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h4><ol><li><code>未提交的回滚数据(uncommitted undo information)</code>：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。 （避免脏读）</li><li><code>已经提交但未过期的回滚数据(committed undo information)</code>：该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。（避免不可重复读）</li><li><code>事务已经提交并过期的数据(expired undo information)</code>：事务已经提交，而且数据保存时间已经超过 undo retention参数指定的时间，可覆盖</li></ol><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul><li>正常提交就是提交，redo log file写入了就持久化了。在正常情况下rollback，根据undo日志回滚</li><li>如果没commit且没redo log file但宕机了，数据只内存中，不用改磁盘，事务结束</li><li>如果没commit但有redo log file宕机了，可以选择rollback，或者继续事务</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055505.png" alt="image-20230313161236154"></p><p>行格式中，每行数据都会有一个<code>事务id</code>，以及<code>回滚指针</code>（指向undo的指针）</p><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p>undo log在操作过程中串联起来，记录下数据差异，回滚时逆向进行</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055506.png" alt="image-20230313161721869"></p><ol><li>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除 </li><li>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0 </li><li>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom </li><li>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>实现事务的<code>隔离性</code></p><p>并发访问时的安全性</p><h3 id="并发事务情况"><a href="#并发事务情况" class="headerlink" title="并发事务情况"></a>并发事务情况</h3><ul><li><strong>读-读</strong> ：无影响</li><li><strong>写-写</strong>：<code>脏写</code>  <strong>必须加锁</strong>。 先来的加锁，后来的排队。先来的完成后把后来的激活</li><li><strong>读-写</strong>：<code>脏读、不可重复读、幻读</code>    <strong>重点关注</strong></li></ul><h3 id="读写解决"><a href="#读写解决" class="headerlink" title="读写解决"></a>读写解决</h3><ol><li>读（MVCC），写（加锁）。下章</li><li>读写都加锁。但插入的数据无法加，无法解决幻读 ；读-写 操作彼此需要 <code>排队执行</code> ，影响性能。</li></ol><p>一般情况下我们当然愿意采用 <code>MVCC</code> 来解决 <code>读-写</code> 操作并发执行的问题，但是<strong>业务在某些特殊情况</strong>下，要求必须采用 <code>加锁 </code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p><h3 id="锁的类别"><a href="#锁的类别" class="headerlink" title="锁的类别"></a>锁的类别</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055507.png" alt="image-20230313164720406"></p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>InnoDB可以加表上、也可以加行上</p><ul><li><p>共享锁S：读也可以加X锁，这里是手动加锁。(MVCC中的当前读)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT   LOCK IN SHARE MODE<br>SELECT   FOR UPDATE (nowait 锁了就直接返回、不等待)<br></code></pre></td></tr></table></figure></li><li><p>排他锁X：写锁，会阻断X和S。有S时也不能加X。一直等到超时</p><ul><li>DELETE：X锁</li><li>INSERT：<code>隐式锁</code>，因为一开始没有空间</li><li>UPDATE：<ul><li>修改了主键：先del再insert</li><li>空间没有变：X锁</li><li>空间变化了：相当于修改主键，先del再insert</li></ul></li></ul></li></ul><h4 id="表-行-页-锁"><a href="#表-行-页-锁" class="headerlink" title="表 行 页 锁"></a>表 行 页 锁</h4><p>粒度越小，开销越大，并发性越高。InnoDB提供到行锁</p><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p><strong>不依赖于存储引擎</strong>，策略一样</p><h6 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h6><p>表锁：InnoDB一般在崩溃恢复时才加，MyISAM默认</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">`LOCK TABLES t READ`   `S锁`<br>`LOCK TABLES t WRITE`  `X锁` <br><br># 查看<br>SHOW OPEN TABLES; # 主要关注In_use字段的值<br>或者<br>SHOW OPEN TABLES where In_use &gt; 0;<br><br>UNLOCK TABLES; # 使用此命令解锁当前加锁的表<br></code></pre></td></tr></table></figure><p>MyISAM&#x3D;&#x3D;默认会在执行CRUD时对整个表加锁&#x3D;&#x3D;，只能读-读，导致查询性能下降的原因。InnoDB不加</p><p>注意加锁后，不能操作别的表了</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055508.png" alt="image-20230316144257602"></p><h6 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h6><p>InnoDB原本想加表锁，需要遍历全部数据查看有没有行锁</p><p>A加了行X锁后，自动加一个表的<code>X意向锁</code>（代表A有意向去操作整张表）其他人B就加不了表锁。  存储引擎 <code>维护</code> </p><p>也就是B加锁前，除了看有没有锁，还要看有没有同级别的意向锁的存在</p><ul><li><strong>协调</strong>多粒度锁共存，方便在加表锁时，查看有没有行锁</li></ul><h6 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h6><p><code>AUTO_INCREMENT</code></p><p>多并发下如何实现自增</p><p>直接加锁 等、</p><h6 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h6><p>DDL操作加锁：别人在读数据时，你不能改表结构</p><h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><ul><li><strong>优点：</strong>锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。</li><li><strong>缺点：</strong>对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</li></ul><p>① <strong>记录锁</strong>（Record Locks）</p><p>​<code>LOCK_REC_NOT_GAP</code>，就是正常的X、S锁。只有S-S共享</p><p>​例：一个事务在更新（自动加X），另一个不可以<code>select .. lock in share mode</code>，但可以直接读（MVCC）</p><p>② <strong>间隙锁</strong>（Gap Locks）</p><p>​在RR级别下<strong>解决幻读</strong></p><p>（1）防止间隙内有新数据被插入<br>（2）防止已存在的数据，更新成间隙内的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t WHERE id BETWEEN 100 AND 200；<br>查询后，100~200之间加上间隙锁，禁止再插入数据<br></code></pre></td></tr></table></figure><p>③ <strong>临键锁</strong>（Next-Key Locks）</p><p>​一个<code>记录锁</code>和一个<code>gap锁</code>的合体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">begin;<br>select * from student where id &lt;=8 and id &gt; 3 for update;<br></code></pre></td></tr></table></figure><h5 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h5><p>页锁就是在 <code>页的粒度</code> ，粒度在表和行之间</p><h4 id="乐观锁悲观锁"><a href="#乐观锁悲观锁" class="headerlink" title="乐观锁悲观锁"></a>乐观锁悲观锁</h4><p><strong>悲观锁：</strong>认为别人会影响自己，总是加锁阻塞其他线程。数据库实现 <code>synchronized</code>  <code>ReentrantLock</code> </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055509.png" alt="image-20230316161045465"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055510.png" alt="image-20230316161155532"></p><p>加锁后等待时间较长，所有扫描到的数据都会锁定，因此必须要索引</p><p><strong>乐观锁</strong></p><p>不上锁。</p><p>在表中设计一个 <code>版本字段 version</code> ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 <code>UPDATE ... SET version=version+1 WHERE version=version</code> 。version不一样说明别人修改过了</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055511.png" alt="image-20230316161722838"></p><p>上面可能会导致失败太多，再更新。减库存前先判断</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055512.png" alt="image-20230316161931349"></p><p><code>乐观锁</code> 适合 <code>读操作多</code> ，悲观锁相反</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055513.png" alt="image-20230316162041048"></p><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>整个数据库只读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Flush tables with read lock<br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055514.png" alt="image-20230316163506070"></p><ol><li>互斥条件：资源不能被共享，即每个资源一次只能被一个进程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完后自己释放。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h5 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h5><p><strong>方式1：</strong>等待，直到超时（<code>innodb_lock_wait_timeout</code>&#x3D;50s)。不太好</p><p><strong>方式2：</strong>使用死锁检测处理死锁程序， <code>wait-for graph</code>算法</p><p>需要存储全部事务构建的锁信息，构建等待图，存在环就存在死锁</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055515.png" alt="image-20230316164435644" style="zoom: 80%;" /><p>一旦检测到回路、有死锁，这时候InnoDB存储引擎会选择<code>回滚undo量最小的事务</code>，让其他事务继续执行（<code>innodb_deadlock_detect=on</code>表示开启这个逻辑）。</p><p>复杂度还是比较高</p><h3 id="锁结构"><a href="#锁结构" class="headerlink" title="锁结构"></a>锁结构</h3><p>InnoDB使用锁信息来跟踪行级锁。锁信息（<code>lock_t</code>）存储在锁管理器（<code>lock manager</code>），去锁管理器中查询该行是否被锁定。</p><p><code>InnoDB</code> 存储引擎中的 <code>锁结构</code> 如下：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055516.png" alt="image-20220714132306208"></p><p>结构解析：</p><p><code>1. 锁所在的事务信息 </code>：</p><p>不论是 <code>表锁</code> 还是 <code>行锁</code> ，都是在事务执行过程中生成的，哪个事务生成了这个锁结构 ，这里就记录这个 事务的指针</p><p><code>2. 索引信息</code> ：</p><p>对于 <code>行锁</code> 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><p><code>3. 表锁／行锁信息</code> ：</p><p><code>表锁结构</code> 和 <code>行锁结构</code> 在这个位置的内容是不同的：</p><ul><li><p>表锁：</p><p>记载着是对哪个表加的锁，还有其他的一些信息。</p></li><li><p>行锁：</p><p>记载了三个重要的信息：</p><ul><li><code>Space ID</code> ：记录所在表空间。</li><li><code>Page Number</code> ：记录所在页号。</li><li><code>n_bits </code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个<code>n_bis</code>属性代表使用了多少比特位。</li></ul><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构</p></blockquote></li></ul><p><code>4. type_mode</code> ：</p><p>这是一个32位的数，被分成了 <code>lock_mode</code> 、 <code>lock_type</code> 和 <code>rec_lock_type</code> 三个部分，如图所示：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055517.png" alt="image-20220714133319666"></p><ul><li>锁的模式（ <code>lock_mode</code> ），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code> （十进制的 0 ）：表示共享意向锁，也就是 <code>IS锁</code> 。 </li><li><code>LOCK_IX</code> （十进制的 1 ）：表示独占意向锁，也就是 <code>IX锁</code> 。 </li><li><code>LOCK_S</code> （十进制的 2 ）：表示共享锁，也就是 <code>S锁</code> 。 </li><li><code>LOCK_X</code> （十进制的 3 ）：表示独占锁，也就是 <code>X锁</code> 。 </li><li><code>LOCK_AUTO_INC</code> （十进制的 4 ）：表示 <code>AUTO-INC锁</code> 。</li></ul></li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（ <code>lock_type</code> ），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code> （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC </code>（十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（ <code>rec_lock_type</code> ），使用其余的位来表示。只有在 <code>lock_type</code> 的值为 <code>LOCK_REC</code> 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code> （十进制的 0 ）：表示 <code>next-key锁</code> 。</li><li><code>LOCK_GAP</code> （十进制的 512 ）：也就是当第10个比特位置为1时，表示 <code>gap锁</code> 。</li><li><code>LOCK_REC_NOT_GAP</code> （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 <code>记录锁</code> 。</li><li><code>LOCK_INSERT_INTENTION</code> （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><code>is_waiting</code> 属性呢？基于内存空间的节省，所以把 <code>is_waiting</code> 属性放到了 <code>type_mode</code> 这个32 位的数字中：<ul><li><code>LOCK_WAIT</code> （十进制的 256 ） ：当第9个比特位置为 1 时，表示 <code>is_waiting</code> 为 <code>true</code> ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 <code>is_waiting</code> 为 <code>false</code> ，也就是当前事务获取锁成功。</li></ul></li></ul><p><code>5. 其他信息</code> ：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p><p><code>6. 一堆比特位</code> ：</p><p>如果是 <code>行锁结构</code> 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 <code>n_bits</code> 属性 表示的。InnoDB数据页中的每条记录在 <code>记录头信息</code> 中都包含一个 <code>heap_no</code> 属性，伪记录 <code>Infimum</code> 的 <code>heap_no</code> 值为 0 ， <code>Supremum</code> 的 <code>heap_no</code> 值为 1 ，之后每插入一条记录， <code>heap_no</code> 值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 <code>heap_no</code> ，即一个比特位映射 到页内的一条记录。</p><h3 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询正在被锁阻塞的sql语句。<br>SELECT * FROM information_schema.INNODB_TRX\G;<br># 查询锁等待情况<br>SELECT * FROM data_lock_waits\G;<br># 查询锁的情况<br>SELECT * from performance_schema.data_locks\G;<br></code></pre></td></tr></table></figure><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC （Multiversion Concurrency Control），隔离级别我们可以设置，MVCC是如何实现隔离级别(RM和RR)</p><p>解决<code>读-写</code>冲突，读不加锁。读为<strong>快照读</strong>，写为<strong>当前读</strong></p><p>组成：<code>隐藏字段</code>、<code>undo日志</code>、<code>ReadView</code></p><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>基本的<code>select</code>。隔离级别不是串行级别</p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>为读到最新数据，加锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁，锁上后别人不能修改<br>SELECT * FROM student FOR UPDATE; # 排他锁<br>INSERT INTO student values ... # 排他锁<br>DELETE FROM student WHERE ... # 排他锁<br>UPDATE student SET ... # 排他锁<br></code></pre></td></tr></table></figure><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><h4 id="隔离级别-1"><a href="#隔离级别-1" class="headerlink" title="隔离级别"></a>隔离级别</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055518.png" alt="image-20230317134757906" style="zoom:67%;" /><h4 id="隐藏字段、Undo-Log版本链"><a href="#隐藏字段、Undo-Log版本链" class="headerlink" title="隐藏字段、Undo Log版本链"></a>隐藏字段、Undo Log版本链</h4><ul><li>隐藏字段包含：<ul><li><code>trx_id</code> ：最后一次修改的事务id</li><li><code>roll_pointer</code>: 操作的记录信息</li></ul></li><li>Undo Log版本链：包含历史信息</li></ul><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><p>如事务8插入了一条数据</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055519.png" alt="image-20230317135028917"></p><p>此时两个事务分别进行2次修改，注意他们不能同时更新，只能一个commit后再一个更新：<code>写锁</code></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055520.png" alt="image-20230317135251185" style="zoom:67%;" /><p>在完成后，第一条为记录，历史版本串成了undo日志</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055521.png" alt="image-20230317135348858"></p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>MVCC 的实现依赖于：<code>隐藏字段</code>、<code>Undo Log</code>、<code>Read View</code>。</p><p><strong>ReadView</strong>: <strong>事务</strong>在进行<strong>快照读</strong>时产生的 <strong>读视图</strong>（一对一）。有一个数组记录活跃事务ID</p><ul><li><code>READ UNCOMMITTED</code> ：读未提交，就是最新数据。&#x3D;&#x3D;不使用&#x3D;&#x3D;</li><li><code>READ COMMITTED</code>：每次读之前都会新生成一个视图</li><li><code>REPEATABLE READ</code>：第一次读时生成</li><li><code>SERIALIZABLE</code>：从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。并发度急剧下降，不建议使用。</li></ul><h4 id="ReadView组成"><a href="#ReadView组成" class="headerlink" title="ReadView组成"></a>ReadView组成</h4><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ol><li><p><code>creator_trx_id</code> ，创建这个 Read View 的事务 ID。</p><blockquote><p>说明：只有在<strong>CUD</strong>才会为 事务分配事务id，否则在<strong>R</strong>事务中的事务id值都默认为0。</p></blockquote></li><li><p><code>trx_ids</code> ，表示在生成ReadView时当前系统中活跃的读写事务的 <code>事务id列表</code> 。</p></li><li><p><code>up_limit_id</code> ，活跃的事务中最小的事务 ID。</p></li><li><p><code>low_limit_id</code> ，表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是系 统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p></li></ol><blockquote><p>为什么需要: 如果读到了在trx_ids中的，或者大于low_limit_id，什么数据被修改了，那就要回滚undo读历史版本</p><p>up_limit_id 作用就是方便比较，小于up_limit_id 的就可以直接读</p></blockquote><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p><code>trx_ids</code> ：   [<code>up_limit_id</code>  …     ]   <code>low_limit_id</code> </p><p><strong>规则：</strong></p><ul><li>快照读：如果改事务读到的行记录的<code>trx_id</code>&gt;&#x3D;<code>low_limit_id</code> || <code>trx_id</code> in <code>trx_ids</code> ,   说明这个行版本在事务创建后被修改过，就需要沿着Undo<strong>一直倒退</strong>到事务创建时的版本：<code>trx_id</code>&lt;<code>low_limit_id</code> || <code>trx_id</code> not in <code>trx_ids</code> 。</li><li>当前读：必须读取最新版本，也就是直接读到的数据</li></ul><p>步骤判断：</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><p>再根据生成规则，<code>READ COMMITTED</code>(每次读生成)  <code>REPEATABLE READ</code>(事务生成时生成)，这两种隔离级别都实现了。</p><h4 id="幻读解决"><a href="#幻读解决" class="headerlink" title="幻读解决"></a>幻读解决</h4><p><strong>快照读：</strong>插入的数据一定是活跃的事务或未来的事务：<code>trx_id</code>&gt;&#x3D;<code>low_limit_id</code> || <code>trx_id</code> in <code>trx_ids</code> ，也不能倒退版本，根据规则就被MVCC直接忽略了</p><p><strong>当前读：</strong>MVCC无法解决。A查询id&gt;3,B插入id&#x3D;6，A更新id&#x3D;6(当前读)，至此之后A都会读到幻影记录6.</p><p>​解决办法：在A查询id&gt;3时，自动添加<strong>间隙锁</strong>(RR并且有索引)。</p><p><a href="https://blog.csdn.net/Edwin_Hu/article/details/124392174">MVCC 幻读问题</a></p><p><a href="https://blog.csdn.net/Edwin_Hu/article/details/124392174">间隙锁原理</a></p><h2 id="事务总结"><a href="#事务总结" class="headerlink" title="事务总结"></a>事务总结</h2><p><strong>原子性：</strong> <code>undo日志</code>实现回滚，保证操作原子性</p><p><strong>隔离型：</strong>读-读、读-写（锁 或者 MVCC+锁）、写-写(锁)</p><p><strong>持久性：</strong> <code>redu日志</code>实现，数据持久化前，先把操作持久化</p><p>目标：<strong>一致性：</strong>  数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://www.bilibili.com/video/BV1vg411p7uJ">字节数据库优化</a>  <a href="https://mp.weixin.qq.com/s/CaSVhAJgycjjbCxAkII2ZA">慢 SQL 分析与优化</a></p><p><strong>InnoDB</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055522.png" alt="image-20221206102707216"></p><p><strong>回表查询</strong>：先根据筛选条件在普通索引上定位id，再拿id再聚集索引上定位行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> id, name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;shenjian&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> id, name, sex <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;shenjian&#x27;</span>; 需要回表<br></code></pre></td></tr></table></figure><p>limit: 先查询全部数据，再进行过滤   优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">（全部sn<span class="hljs-operator">=</span><span class="hljs-string">&#x27;XD12345678&#x27;</span>的数据要回表）<br><span class="hljs-keyword">SELECT</span> o1.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> sn<span class="hljs-operator">=</span><span class="hljs-string">&#x27;XD12345678&#x27;</span> LIMIT <span class="hljs-number">10000</span>,<span class="hljs-number">10</span> <br><br>（只回表<span class="hljs-number">10</span>条数据）<br><span class="hljs-keyword">SELECT</span> o1.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders o1<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> sn<span class="hljs-operator">=</span><span class="hljs-string">&#x27;XD12345678&#x27;</span> LIMIT <span class="hljs-number">10000</span>,<span class="hljs-number">10</span>) o2<br><span class="hljs-keyword">ON</span> o1.id <span class="hljs-operator">=</span> o2.id;<br></code></pre></td></tr></table></figure><p>不使用子查询：先查外表，外表大很慢</p><p>IN代替or：IN会将数组先排序，然后用二分去查找</p><p>少用select *</p><p>where groupby having  先where过滤</p><p>exists和in区别，要用<strong>小表驱动大表</strong>，因为是以驱动表建立for循环　<strong>被驱动表走索引</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">exists用外表驱动内表，拿一条条外表数据去内标查       适合外小内大<br><span class="hljs-keyword">in</span>反过来，先查询内表，再拿数据去外表走索引<br>子查询<span class="hljs-keyword">in</span> exists:https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/wpc2018/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">122948692</span><br></code></pre></td></tr></table></figure><p>join的驱动</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>）当连接查询没有<span class="hljs-keyword">where</span>条件时<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> 前面的表是驱动表，后面的表是被驱动表<br><span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> 后面的表是驱动表，前面的表是被驱动表<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">join</span> 会自动选择表数据比较少的作为驱动表<br>straight_join(≈<span class="hljs-keyword">join</span>) 直接选择左边的表作为驱动表（语义上与<span class="hljs-keyword">join</span>类似，但去除了<span class="hljs-keyword">join</span>自动选择小表作为驱动表的特性）<br><br><span class="hljs-number">2</span>）当连接查询有<span class="hljs-keyword">where</span>条件时，带<span class="hljs-keyword">where</span>条件的表是驱动表，否则是被驱动表<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot笔记</title>
    <link href="/2022/12/30/springboot/"/>
    <url>/2022/12/30/springboot/</url>
    
    <content type="html"><![CDATA[<h3 id="0-对比"><a href="#0-对比" class="headerlink" title="0.对比"></a>0.对比</h3><p>模板化的大量配置文件，不需要tomcat运行。遵循约定，简化配置</p><p>springboot只是进一步的升级，简化项目搭建和开发。引入依赖，几行配置</p><p>springboot 微框架 &#x3D; springmvc 控制器+ spring core项目管理</p><ul><li>spring存在父容器spring.xml,子容器springmvc.xml。springboot只有一个</li><li>内嵌tomcat</li><li>简化maven，自动配置spring springmvc，没有xml</li></ul><p>约定：</p><ul><li>只有一个入口类 xxxxApplication.java，在所有子包目录之上； 需要main项目启动函数</li><li>配置文件：根目录resources中application.yml | application.properties</li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050658.png" alt="image-20221216212408119" style="zoom: 80%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050660.png" alt="image-20221216202540351"></p><h3 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1.快速开始"></a>1.快速开始</h3><ol><li><pre><code class="xml">创建spring项目，勾选springweb or创建maven项目继承父项目 便于维护版本&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">   <br><span class="hljs-number">2.</span> 配置文件变成小树叶<br><br><span class="hljs-number">3.</span> ```java<br>   @SpringBootApplication 入口类，整个项目的总入口<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminApplication</span> &#123;<br>   <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>           <span class="hljs-comment">// 入口类对象，参数（可以动态设置参数，如端口等）</span><br>           SpringApplication.<span class="hljs-built_in">run</span>(AdminApplication.<span class="hljs-keyword">class</span>, args);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>写一个@RestController</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs j'a'v">@SpringBootApplication<br>    @SpringBootConfiguration  加载spring springmvc环境<br>    @EnableAutoConfiguration  开启自动配置 自动配置核心注解，配置spring以及第三方环境 <br>    @ComponentScan 组件扫描 当前包以及子包 <br>    &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;<br></code></pre></td></tr></table></figure><h3 id="2-多配置文件"><a href="#2-多配置文件" class="headerlink" title="2.多配置文件"></a>2.多配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br> <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-comment"># 规定走dev环境</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>      <br></code></pre></td></tr></table></figure><p>多环境情况：application为公共的</p><p>​application.yml          application-test.yml        application-dev.yml       application-prod.yml </p><p>此外，以外部生产配置文件启动（包含数据库隐私等）</p><p>java -jar –spring.config.location &#x3D; filepath  xxx.jar</p><h3 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3.创建对象"></a>3.创建对象</h3><p>springboot 微框架 &#x3D; springmvc 控制器</p><p>​ + spring  管理项目对象</p><p><strong>spring创建对象</strong></p><ol><li>&lt; bean &gt;</li><li>注解实现创建对象，需要扫描@Componet ，只是名称不同，为了更好的理解</li></ol><ul><li>@Controller</li><li>@Service</li><li>@Repository</li></ul><p><strong>Springboot</strong>：</p><ol><li><p>@configuration 定义配置类   相当于xml。 </p><p>​里面@Bean ，用在方法上，返回值交给工厂。默认方法名是id（或者@bean(“beanid”)）。 相当于&lt; bean&gt;</p></li><li><p>注解实现创建对象，启动时自动扫描了     指定名称: @Service(“helloImpl”)   @Qualifier(value &#x3D; “helloImpl”)</p><ul><li>@Controller</li><li>@Service</li><li>@Repository</li></ul></li></ol><h3 id="4-属性注入"><a href="#4-属性注入" class="headerlink" title="4.属性注入"></a>4.属性注入</h3><p>和spring一样，但都通过注解实现。包含引用类型和基本类型</p><ol><li><p>@Value(“${user.name}”)   @Value(“xiaoming”)     单个注入</p><ul><li>数组也可以直接注入，yml逗号隔开</li><li>maps: “{‘aa’:’你好’}”   #{${maps}}</li></ul></li><li><p>批量注入，用在类上， @ConfigurationProperties(“spring.datasource”)</p><p>自动找spring.datasource里面的属性，按名称注入到类的属性中，需要提供set方法</p></li></ol><p>@Autowired</p><h3 id="5-JSP集成"><a href="#5-JSP集成" class="headerlink" title="5.JSP集成"></a>5.JSP集成</h3><p>引入依赖 tomcat-embed-jasper ，解析jsp</p><p>java同级的webapp文件夹 </p><p>原来springmvc有视图解析器，现在是设置配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">view:</span><br>      <span class="hljs-attr">prefix:</span> <span class="hljs-string">/</span><br>      <span class="hljs-attr">suffix:</span> <span class="hljs-string">.jsp</span><br></code></pre></td></tr></table></figure><p>通过插件启动，以防idea找不到jsp</p><h3 id="6-整合Mybatis"><a href="#6-整合Mybatis" class="headerlink" title="6.整合Mybatis"></a>6.整合Mybatis</h3><p>0.引入依赖 </p><ul><li>spring-boot-starter-web</li><li>mysql驱动  druid数据源</li><li>mybatis-spring-boot-starter</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.配置数据源</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>  <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>  <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/challenge2?serverTimezon=UTC&amp;userUnicode=true&amp;characterEncoding=utf-8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <br><span class="hljs-string">等价</span><br><span class="hljs-string">&lt;!--使用spring数据源--&gt;</span><br><span class="hljs-string">&lt;bean</span> <span class="hljs-string">id=&quot;dataSource&quot;</span> <span class="hljs-string">class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;driverClassName&quot;</span> <span class="hljs-string">value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;url&quot;</span> <span class="hljs-string">value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;username&quot;</span> <span class="hljs-string">value=&quot;root&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;password&quot;</span> <span class="hljs-string">value=&quot;123456&quot;&gt;&lt;/property&gt;</span><br><span class="hljs-string">&lt;/bean&gt;</span><br></code></pre></td></tr></table></figure><p>2.创建Factory,指定mapper文件的位置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.dhu.yarn.entity</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:com.dhu.yarn/mapper/*.xml</span><br>  <span class="hljs-comment"># 下滑线转大写 </span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">等价</span><br><span class="hljs-string">&lt;bean</span> <span class="hljs-string">id=&quot;sqlSessionFactory&quot;</span> <span class="hljs-string">class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br>    <span class="hljs-string">&lt;!--数据源--&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;dataSource&quot;</span> <span class="hljs-string">ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;!--mapper--&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;mapperLocations&quot;</span> <span class="hljs-string">value=&quot;classpath:com/kuang/mapper/*.xml&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;!--绑定mybatis配置文件--&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;configLocation&quot;</span> <span class="hljs-string">value=&quot;classpath:mybatis-config.xml&quot;/&gt;</span> <span class="hljs-string">(可以不要)</span><br><span class="hljs-string">&lt;/bean&gt;</span><br></code></pre></td></tr></table></figure><p>3.@MapperScan(“com.xun.dao”)  扫描Dao接口所在的包，同时创建bean 。可能爆红但不影响</p><p>or  @Mapper一个一个创建添加，让mybatis找到，表示他是用来访问数据库的 ，对应Mapper接口。同时可以创建bean</p><p>​@Repository只可以创建普通bean，所以只起标识作用。单独使用bean of type BookMapper that could not be found.</p><p>等价</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.mybatis.spring.sample.mapper&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不用配置开启事务，直接在serviceImpl上@Transactional</p><h3 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot2ApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test 用在Spring Boot <span class="hljs-number">2.2</span>.X以后   JUnit <span class="hljs-number">5</span><br><span class="hljs-keyword">import</span> org.junit.Test用在<span class="hljs-number">2.2</span>.x之前     添加 <span class="hljs-meta">@RunWith(SpringRunner.class)</span> 否则注释将被忽略 <br></code></pre></td></tr></table></figure><p>@Autowired service 层 ，调试单个service函数很快</p><h3 id="8-热部署"><a href="#8-热部署" class="headerlink" title="8.热部署"></a>8.热部署</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--热部署--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--是否不能传递--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>2. 勾选Build project automatically     修改了就编译生成.class文件<br>3. ctrl+alt+s，进入设置，然后选择高级设置，在Compiler下勾选 Allow auto-make to restart even if developed application is currently running    自动加载新的class到jvm<br><br>ctrl s保存后，等待日志<br></code></pre></td></tr></table></figure><h3 id="9-日志"><a href="#9-日志" class="headerlink" title="9.日志"></a>9.日志</h3><p>默认集成logback，和log4j作用一样</p><p>日志级别：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050661.png" alt="image-20221219112645808" style="zoom: 80%;" /><p>rootLogger默认</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050662.png" alt="image-20221219113216242" style="zoom:80%;" /><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">info</span>  <span class="hljs-comment">#如果修改为debug， 信息变多了</span><br>    <span class="hljs-attr">com.baizhi.mapper:</span> <span class="hljs-string">debug</span> <span class="hljs-comment"># 把mapper层设置为debug，可以显示sql日志</span><br>  <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次都要生成</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(当前类.class);<br>logger.info(<span class="hljs-string">&quot;12312&quot;</span>) # 代替sout<br>logger.error(<span class="hljs-string">&quot;端口冲突,异常信息：&#123;&#125; &#123;&#125;&quot;</span>, <span class="hljs-string">&quot;第一个参数&quot;</span>, <span class="hljs-string">&quot;第二个参数&quot;</span>);<br><br>注解实现<br><span class="hljs-meta">@Slf4j</span><br>log.info(<span class="hljs-string">&quot;测试log-------------------------&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="10-小项目"><a href="#10-小项目" class="headerlink" title="10.小项目"></a>10.小项目</h3><p>密码要md5（不可逆）加密保存，登录时将将密码转换后进行对比。传统项目成功后存入session中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newpassword</span> <span class="hljs-operator">=</span> DigestUtils.md5DigestAsHex(password.getBytes(StandardCharsets.UTF_8))<br></code></pre></td></tr></table></figure><p>出现业务错误时，抛出异常</p><p>controller除了返回到页面，还包含跳转到别的controlle，注意使用forward还是redirect。</p><p>​如添加完成员工接口后redirect到查询接口，查询完成后forward到显示界面</p><h3 id="11-AOP"><a href="#11-AOP" class="headerlink" title="11.AOP"></a>11.AOP</h3><p><strong>spring</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">附加操作 继承接口<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>              System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">配置bean；配置切入点，组装切面<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aop.Log&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--   切入点   execution:执行的位置     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserserviceImpl.*(..))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:pointcut</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>springboot</strong></p><p>  无xml文件</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--aop日志--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写切面类</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">// spring配置类  spring.xml</span><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 这个类是切面类 aop:config</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspectConfig</span> &#123;<br>    <br>    <span class="hljs-comment">// 切入点</span><br>    <span class="hljs-meta">@within(&quot;execution(com.xun.springboot2.controller.*)&quot;)</span> <span class="hljs-comment">//类级别</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.xun.springboot2.controller.*.*(..))&quot;)</span> <span class="hljs-comment">//方法级别</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">controllerLog</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 切面 = 通知（Advice）+ 切入点（pointcut）</span><br>    <span class="hljs-meta">@Before(&quot;controllerLog()&quot;)</span>  <span class="hljs-meta">@After</span>    还可以针对注解生效<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Around(&quot;controllerLog()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;around start&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> proceedingJoinPoint.proceed(); <span class="hljs-comment">// 需要返回方法中的数据</span><br>        System.out.println(<span class="hljs-string">&quot;around end&quot;</span>);<br>        <span class="hljs-keyword">return</span> proceed;<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><h3 id="12-拦截器"><a href="#12-拦截器" class="headerlink" title="12.拦截器"></a>12.拦截器</h3><p><strong>spring</strong>：编写类，return true放行。然后注入bean并且配置拦截哪些请求</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--拦截器注入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--可以写多个拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.JWTInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  或者分开 <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span> = <span class="hljs-string">&quot;beanname&quot;</span>&gt;</span><br>    &lt;/mvc:interceptor &gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>springboot</strong></p><ol><li>编写类，return true放行。&#x2F;&#x2F; 多个拦截器是栈结构，pre1  pre2  do  post2  post1</li><li>编写配置类，implements WebMvcConfigurer    (原来写在springmvc.xml里，现在实现WebMvcConfigurer，WebMvcConfigurer里面包含很多mvc的配置方法，如addResourceHandlers)<ul><li>使用哪个拦截器</li><li>拦截哪些</li><li>排除哪些</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span>&#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JWTInterceptor</span>())<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/user/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/image/**&quot;</span>)<br>            .order(<span class="hljs-number">1</span>) <span class="hljs-comment">// 先执行</span><br>        ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-文件上传下载"><a href="#13-文件上传下载" class="headerlink" title="13.文件上传下载"></a>13.文件上传下载</h3><p>上传到服务器本地、阿里云oss  </p><p>打包成jar时，不能上传到项目内部的某个文件夹，因此直接上传到机器一个固定目录（配置文件注入）</p><p>本地和生产不同，使用多个配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">发送</span> <span class="hljs-string">multipart/form-data</span><br><span class="hljs-string">接受</span> <span class="hljs-string">MultipartFile</span> <span class="hljs-string">f</span><br><br><br><span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">multipart:</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">300MB</span> <span class="hljs-comment"># 单个文件大小</span><br>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">500MB</span> <span class="hljs-comment"># 设置总上传的数据大小</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#开启</span><br></code></pre></td></tr></table></figure><p><strong>下载</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050663.png" alt="image-20221225202709373"></p><h3 id="14-异常处理"><a href="#14-异常处理" class="headerlink" title="14.异常处理"></a>14.异常处理</h3><p>传统的：继承HandlerExceptionResolver，不同异常不同if处理</p><p><strong>springboot:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span>        <span class="hljs-comment">// 默认监控全部controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalException</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler(BusinessException.class)</span> <span class="hljs-comment">// 处理哪个异常</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">handleBusinessException</span><span class="hljs-params">(HttpServletRequest request, BusinessException ex)</span> &#123;<br>        log.error(<span class="hljs-built_in">this</span>.getClass()+<span class="hljs-string">&quot;业务异常：&quot;</span>+ex.getMessage()+<span class="hljs-string">&quot; 代码:&quot;</span>+ex.getCode());<br>        <span class="hljs-keyword">return</span> Result.error(ex.getCode(), ex.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-CORS"><a href="#15-CORS" class="headerlink" title="15.CORS"></a>15.CORS</h3><p> 跨域资源共享</p><p>源：协议 域名 端口。默认情况下，不同源不能互相访问。ajax  </p><p>controller类上@CrossOrigin 允许跨域访问</p><p>全局配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> CorsConfiguration <span class="hljs-title function_">buildConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>        <span class="hljs-comment">// 1允许服务端访问</span><br>        corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 2允许任何头</span><br>        corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 3允许任何方法（post、get等）</span><br>        corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        corsConfiguration.setMaxAge(<span class="hljs-number">600L</span>);<br>        <span class="hljs-comment">// 4 允许withCredentials报文头</span><br>        corsConfiguration.setAllowCredentials(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> corsConfiguration;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, buildConfig());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16-加密"><a href="#16-加密" class="headerlink" title="16.加密"></a>16.加密</h3><p>jasypt对密码进行加密。提供一个类进行加密和解密，需要配置密钥，没有密钥解密会失败。在运行时传参输入密钥</p><p>使用：ENC(加密后字符串)</p><h3 id="17-传参"><a href="#17-传参" class="headerlink" title="17.传参"></a>17.传参</h3><p> 参考sping里springmvc传参</p><h3 id="18-restful"><a href="#18-restful" class="headerlink" title="18.restful"></a>18.restful</h3><p>用访问方法指明操作，put要id和User，先查再改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserRepository userRepository;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getAllUsers</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;User&gt; <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long userId)</span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">createUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;User&gt; <span class="hljs-title function_">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long userId,</span><br><span class="hljs-params">                                                   <span class="hljs-meta">@RequestBody</span> User userDetails)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Boolean&gt; <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long userId)</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring笔记</title>
    <link href="/2022/12/20/spring/"/>
    <url>/2022/12/20/spring/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>1.IOC and DI</p><p>​将new的权力交给spring，由工厂提供对象，同时通过DI维护对象与对象之间的关系</p><p>2.AOP</p><p>​底层原理：动态代理的封装</p><p>​通过产生动态代理来实现附加操作，来减少代码冗余</p><p>​切面 &#x3D; 通知(额外功能) + 切入点(加在哪里，哪些service类的哪些方法)</p><p>​通知和切入点可以随意组合成切面</p><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>项目管理框架，不是替换别的框架，而是将框架进行<strong>整合</strong>管理</p><ul><li><p>众多设计模式：工程 代理 策略 单例…</p></li><li><p>开源</p></li><li><p>轻量级</p></li><li><p>SSH：Struct2 + Spring +Hibernate</p></li><li><p>SSM: SpringMvc + Spring + Mybatis</p></li></ul><p>对组件（controller service Dao ）进行对象管理（创建 使用 销毁），entity通常不交给spring</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">原来： <span class="hljs-keyword">new</span> 去创建，然后调用<br>userDao = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>userDao.save()<br>现在：xml配置bean，然后直接取出来<br></code></pre></td></tr></table></figure><ol><li><p>导入依赖   org.springframework下的spring-webmvc</p></li><li><p>配置applicationContext.xml</p><p>bean来管理对象的创建，class指定类UserDaoImpl，id唯一<strong>标识</strong>在spring容器中取出来（最好首字母小写）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;init.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>启动工程，绑定xml文件,取出bean</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;init/applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">UserDao</span> <span class="hljs-variable">usertest</span> <span class="hljs-operator">=</span> (UserDao)context.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);<br>        usertest.save(<span class="hljs-string">&quot;小明&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. 核心思想</h3><ol><li><p><strong>IOC</strong>（Inversion of Control）控制反转        </p><p>由手动new变为配置文件配置，交给spring工厂。在tomcat中，也是该思想帮助我们创建了response对象</p><p>原理Class.forName(“UserDaoImpl”).newInstance()   反射调用构造方法</p></li><li><p><strong>AOP</strong>面向切面</p></li></ol><p><strong>DI</strong>：dependency Injection    IOC的补充</p><p>​存在嵌套service调用dao，也就是serviceImpl中需要拿到daoImpl。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(String name)</span> &#123;<br>        userDao.save(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​都要先声明一个成员对象，然后 </p><p>​<strong>原来</strong>：new UserDaoImpl()；</p><p>​<strong>现在</strong>：需要set方法，在配置中完成赋值操作（注入）      set注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">ref：工程里的标识 bean的id，name：注入哪个属性<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;userServiceImpl&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>IOC <strong>创建对象</strong>，DI <strong>维护对象与对象之间的关系</strong></p><h3 id="3-注入"><a href="#3-注入" class="headerlink" title="3. 注入"></a>3. 注入</h3><p>除了一个对象的注入，其他的用的很少</p><ol><li>set 注入    property标签</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml">1. 对象注入 ref<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span> /&gt;</span>        <br>2. String、日期、八种基本类型 value注入<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>   <br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2012/12/12 23:54:57&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  日期需要/ :格式<br>3. array list set<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbys&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span> 这里不同<br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>听歌<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  字符串用value<br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  类用ref<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>map<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key-ref</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">key-ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span> 类<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>properties  无序键值对集合<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;driver&quot;</span>&gt;</span>com.mysqljdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;姓名&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>构造注入       constructor-arg 标签</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">使用公开的有参构造方法  index代表参数的位置<br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明&quot;</span>/&gt;</span><br><br>如果想单独赋值某些元素，就要对应的构造方法，很麻烦！！<br></code></pre></td></tr></table></figure><ol start="3"><li>自动注入      autowire &#x3D; ”byType“  “byName”</li></ol><p>底层是set  需要在组件标签上开启</p><p><code>Autowired</code> 属于 Spring 内置的注解，<strong>默认</strong>的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （<strong>接口的实现类</strong>）。</p><p><strong>问题：</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了</p><p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。</p><p><code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><span class="hljs-comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-comment">// smsServiceImpl1 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><h3 id="4-工厂特征"><a href="#4-工厂特征" class="headerlink" title="4.  工厂特征"></a>4.  工厂特征</h3><p>默认单例，多次getBean还是同一个。 struct2用成员对象存储信息，所以这时要多例   bean中scope &#x3D; “prototype”</p><p>原理： <strong>反射</strong> + 构造方法</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>单例：工厂启动时创建，正常关闭工程时销毁 context.close()</p><p>多例：getBean时创建，创建完成后脱离spring的管理，jvm去销毁</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">自己写的方法<br>init-<span class="hljs-keyword">method</span>=&quot;&quot; <span class="hljs-title function_">destroy</span>-<span class="hljs-title function_">method</span>=&quot;&quot;<br></code></pre></td></tr></table></figure><p>好处：</p><ol><li>解耦合，更换类只需要修改配置文件</li><li>减少内存占用</li><li>建立对象与对象之间的关系   打开配置文件就可看到</li></ol><h3 id="5-代理"><a href="#5-代理" class="headerlink" title="5. 代理"></a>5. 代理</h3><p>代理对象：完成传化，也可以附加操作，同时也可以中断</p><p>​好处：原始业务逻辑不变，同时可以附加</p><ol><li>代理对象和原始逻辑对象实现相同的接口</li><li>代理对象 依赖 原始业务逻辑对象</li></ol><p>原始逻辑中，除了<strong>具体事务</strong>，还有开启事务、提交事务、回滚事务的方法。后面这部分是重复的</p><p>在代理中，负责处理这些额外的方法，同时需要调用原始对象。总体的处理逻辑不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>sout(<span class="hljs-string">&quot;开启事务&quot;</span>)<br>userService.save(name)<br>out(<span class="hljs-string">&quot;结束事务&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>每一个业务对象都开发一个代理对象，上面的逻辑</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在程序运行中自动生成</p><p>getSqlSession().getMapper(UserMapper.class).getUser(); 这一步也是通过代理实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader(); 类加载器<br><span class="hljs-number">2.</span> Class[] classes = &#123;UserService.class&#125; 目标对象的接口数组 <br><span class="hljs-number">3.</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandleer</span>() 附加操作 额外功能<br>proxy = (UserServic)Proxy.newProxyInstance(classLoader, classes, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandleer</span>()&#123;<br><span class="hljs-comment">// 代理过程 处理代理的实例  这里执行附加操作</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 附加 开启事务，打印信息等操作</span><br>        log(method.getName());<br>        <span class="hljs-comment">// 反射, 执行具体事务  哪个目标类的method </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>(), args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+msg);<br>    &#125;<br>&#125;);   生成动态对象<br>    <br>porxy.save();  直接调用<br></code></pre></td></tr></table></figure><p>封装成通用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-comment">// 被代理的接口， 一个动态代理 可以代理 多个类，只要是同一接口</span><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTarget</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回代理类</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 类加载器  被代理类接口  InvocationHandler</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-built_in">this</span>.getClass().getClassLoader(),<br>                target.getClass().getInterfaces(),<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 代理过程 处理代理的实例  这里执行附加操作</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//附加</span><br>        log(method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+msg);<br>    &#125;<br>&#125;<br><br>---------<br><span class="hljs-comment">// 真实角色</span><br><span class="hljs-type">ServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceImpl</span>();<br><br><span class="hljs-type">ProxyInvocationHandler</span> <span class="hljs-variable">phi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyInvocationHandler</span>();<br><span class="hljs-comment">// 设置要代理的对象</span><br>phi.setTarget(service);<br><span class="hljs-comment">// 得到代理对象 是一个接口</span><br><span class="hljs-type">Service</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Service) phi.getProxy();<br><br>proxy.add();<br></code></pre></td></tr></table></figure><h3 id="6-AOP"><a href="#6-AOP" class="headerlink" title="6.   AOP"></a>6.   AOP</h3><p>Aspect Oriented Programing    <strong>核心就是动态代理</strong></p><p>附加操作：如日志打印，每个controller都加的话<strong>代码冗余</strong></p><p>通过<strong>动态代理</strong>完成<strong>附加操作</strong>(通知、Advice)。开发通知类，配置切入点</p><p>通知（Advice）：前置通知、后置通知、环绕通知、异常通知</p><p>切入点（pointcut）：指定通知应用在哪里。一般用于业务层</p><p><strong>切面</strong>（Aspect）：<strong>通知</strong>（Advice）+ <strong>切入点</strong>（pointcut）</p><ol><li><p>导入依赖</p></li><li><p>开发通知   继承接口 MethodIntercept MethodBeforeAdvice  ..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置切面 .xml</p><ul><li><p>注册通知类bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aop.Log&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>组装切面，aop输入时会导入一些依赖。先定义切入点，切哪个类的哪个方法；再把通知类和切入点组装</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--   切入点   execution:执行的位置     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserserviceImpl.*(..))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:pointcut</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>被切的类都会创建代理对象，之后.getBean(“UserserviceImpl”)返回的是proxy，和5中动态代理一样，但每个被切的类不用单独创建</p></li></ol><h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><p>MethodInterceptor</p><p>计算运行时间 、处理异常</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046861.png" alt="image-20221206190215566"></p><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046862.png" alt="image-20221206190819126"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046863.png" alt="image-20221206190916792"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046864.png" alt="image-20221206191123649" style="zoom:67%;" /><h3 id="7-复杂对象"><a href="#7-复杂对象" class="headerlink" title="7.  复杂对象"></a>7.  复杂对象</h3><ul><li>简单对象：可以直接new的对象，因此可以直接通过&lt; bean &gt;交给spring</li><li>复杂对象：不能直接new，接口Connction、抽象类Calendar</li></ul><p>Implements FactoryBean&lt;类名&gt;</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046865.png" alt="image-20221207202622749"></p><h3 id="8-整合mybatis"><a href="#8-整合mybatis" class="headerlink" title="8.整合mybatis"></a>8.整合mybatis</h3><p>spring：项目管理</p><p>mybatis：持久层CRUD。把mybatis中的对象创建交给spring</p><p><strong>mybatis写法：</strong>  .xml包含 <strong>数据源</strong> 以及 <strong>mapper注册</strong> 。 sqlSessionFactory &#x3D;》sqlSession &#x3D;》 usermapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>配置文件mybatis.xml 包含数据源信息(数据库账号密码等)<br><span class="hljs-number">2.</span>从配置文件.xml得到SqlSessionFactory，再openSession生成SqlSession执行sql语句 (封装成工具类)<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// get factory</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// get SqlSession</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br><br><span class="hljs-number">3.</span>编写Dao接口，接口实现类（.xml）<br>    <br><span class="hljs-number">4.</span>注册Mapper.xml<br>    &lt;mappers&gt;<br>        &lt;mapper resource=<span class="hljs-string">&quot;com/kuang/dao/userMapper.xml&quot;</span>/&gt;<br>    &lt;/mappers&gt;<br>    <br><span class="hljs-number">5.</span>测试，调用工具类得到SqlSession，再调用getMapper，该mapper执行函数完成查询<br><span class="hljs-comment">// 获得对象</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><span class="hljs-comment">// getMapper</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>List&lt;User&gt; userList = mapper.getUserList();<br></code></pre></td></tr></table></figure><h4 id="8-1拿到sqlSessionFactory"><a href="#8-1拿到sqlSessionFactory" class="headerlink" title="8.1拿到sqlSessionFactory"></a>8.1拿到sqlSessionFactory</h4><p>SqlSessionFactoryBuilder 读配置文件，构建Factory</p><p>sqlSessionFactory <strong>核心对象</strong>, 因此整合的核心就是接管这个！！！</p><p>sqlSession</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml">sqlSessionFactory 是接口，因此利用第七节的方法完成配置，并把xml文件位置通过依赖注入到bean中<br><br>spring将这个类封装了，叫做SqlSessionFactoryBean<br>注入.xml，细粒度化，把dataSource分开了，同时配置mapperLocations；mybatis.xml中配置日志等其他对象(可以不要)<br><span class="hljs-comment">&lt;!--使用spring数据源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mapper--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/kuang/mapper/*.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--绑定mybatis配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span> (可以不要)<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>到这一步拿出sqlSessionFactory，就可以取出sqlSession.getmapper操作数据库<br>但我们的核心是在Dao部分，所以不想每次拿Dao时都先拿出sqlSessionFactory，想直接拿出Dao<br></code></pre></td></tr></table></figure><h4 id="8-2整和Dao"><a href="#8-2整和Dao" class="headerlink" title="8.2整和Dao"></a>8.2整和Dao</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">factory中指向mapper文件<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/kuang/mapper/*.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>进一步封装，就可以直接getBean(UserDao)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">sqlSessionFactory和userDao绑定，就可以直接getMapper，等价 @Mapper，每一个都要写。@Repository没有用<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperInterface&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.kuang.mapper.UserDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>这里每一个Dao都要配置，直接只写一个mapperscan可以解决  等价 @MapperScan<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.mybatis.spring.sample.mapper&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者将sqlsession作为一个成员放到UserDaoImpl中，间接调用，狂神的课程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserMapper</span>&#123;<br>    <span class="hljs-keyword">private</span> SqlSessionTemplate sqlSession;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSqlSession</span><span class="hljs-params">(SqlSessionTemplate sqlSession)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sqlSession = sqlSession;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-keyword">return</span> mapper.getUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sqlSession--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--实现类--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.mapper.UserMapperImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSession&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="9-Service事务"><a href="#9-Service事务" class="headerlink" title="9.Service事务"></a>9.Service事务</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">用DataSourceTransactionManager实现事务，自己写<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>  -&gt;  写环绕通知  -&gt;  用spring的环绕通知（细粒度）<br></code></pre></td></tr></table></figure><p>service直接注入Dao即可，但需要<strong>处理事务</strong></p><h4 id="9-1-编程式"><a href="#9-1-编程式" class="headerlink" title="9.1.编程式"></a>9.1.编程式</h4><p>每个impl中注入事务管理对象实现</p><p>JDBC中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">connection.setAutoCommit(<span class="hljs-literal">false</span>);<br>connection.commit();<br>connection.rollback();<br></code></pre></td></tr></table></figure><p>datasouce中可以取出connection,但是service中的connection和dao中的<strong>可能不是同一个</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046866.png" alt="image-20221208142531461" style="zoom:67%;" /><p><strong>DataSourceTransactionManager</strong>：全局事务管理，使得service和Dao连接对象相同，控制数据源的线程安全问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>serviceImpl中，添加transactionManager， .commit()   .rollback()。每一个serviceImpl都要写，<strong>用AOP解决冗余</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046867.png" alt="image-20221208143608607"></p><h4 id="9-2-声明式事务"><a href="#9-2-声明式事务" class="headerlink" title="9.2 声明式事务"></a>9.2 声明式事务</h4><p>aop实现事务处理</p><p>自己写：环绕通知，大家都一样的，所以spring封装了</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046868.png" alt="image-20221208145557943"></p><p>封装后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置事务通知，等价于自己写的环绕通知 tx:advice为特殊标签 对通知做细粒度管控--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--在什么情况下添加事务， 细粒度--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update*&quot;</span>/&gt;</span> 方法名需要对应上<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--配置切入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tranPointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.mapper.*.*(..))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:pointcut</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;tranPointCut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="9-3事务传播"><a href="#9-3事务传播" class="headerlink" title="9.3事务传播"></a>9.3事务传播</h4><p>业务层中调用别的业务，可以把事务传播过去。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">OrderService.save()&#123;<br>userService.update();<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> /&gt;</span> <br>  propagation=&quot;&quot;<br>    REQUIRED：外层没有则开启，有则融入             增删改  默认<br>    SUPPORTS：外层没有不开，有则融入；实现事务传播  查询<br>    REQUIRE_NEW: 自己开一个新的 隔开              银行日志，总是要个新的<br>    NOT_SUPPORTED: 不用事务<br>  isolation=&quot;&quot;<br>  read-only<br>  time-out: 事务超时 -1永不超时 秒<br></code></pre></td></tr></table></figure><p>行锁为一条数据，在同一事务中多次查询，不会受到别人update印象</p><p>表锁为表的数据，多一条少一条不受印象</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046869.png" alt="image-20221208161551569"></p><h3 id="10-日志"><a href="#10-日志" class="headerlink" title="10.日志"></a>10.日志</h3><p>log4j</p><p>ERROR WARN INFO DEBUG</p><p>配置文件在resource根目录下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">log4j<span class="hljs-selector-class">.logger</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-class">.baizhi</span>.dao=DEBUG 展示sql<br></code></pre></td></tr></table></figure><h3 id="11-注解"><a href="#11-注解" class="headerlink" title="11.注解"></a>11.注解</h3><h4 id="装配"><a href="#装配" class="headerlink" title="装配"></a>装配</h4><p>service太多了，每次都要添加</p><p><strong>前置条件：开启注解扫描</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定注解生效的包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>@component</strong>(value &#x3D; “指定id”)，装配到Spring中，等价与&lt; bean&gt;, 唯一标识为类名小写</p><ul><li>Dao  **@Repository (只是告诉spring要加这个bean，和mybatis无关)   ** @Mapper 和 @MapperScan结合使用为了结合spring和mybatis。如果不加@Repository可能爆红 但能正常运行</li><li>Service     <strong>@Service</strong></li><li>controller  <strong>@ Controller</strong></li></ul><p><strong>@Scope</strong>(value&#x3D;”singleton\prototype”)  单例多例</p><h4 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h4><p><strong>对象注入</strong> 属性或者set方法上。在属性上用时可以不用添加set方法，底层会自动提供set方法</p><p>​@<strong>Autowired</strong>  默认类型</p><p>​ @<strong>Qualifier</strong>(value &#x3D; “cat1”)  指定名称</p><p>JavaEE</p><p>​@<strong>Resource</strong>  默认名字，找不到再类型</p><p><strong>基本类型注入</strong></p><p>​@Value(“XX”)         @Value(“${spring.datasource.username}”)</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>@<strong>transactional</strong>(propagation &#x3D; , )  添加事务，加载类或者单个方法    <strong>serviceimpl</strong>上加</p><p>不需要事务通知对象以及添加切面，但还是添加开启注解事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span>&lt;/tx:annotation-driven &gt; <br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046870.png" alt="image-20221208170805881" style="zoom:67%;" /><p>Dao还是扫描进行装配的</p><p>P21整合SM</p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>MVC中的C层，控制器框架。代替struts2</p><h3 id="0-Struct2"><a href="#0-Struct2" class="headerlink" title="0.Struct2"></a>0.Struct2</h3><p>1.C层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ActionSupport</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Product&gt; productList; <span class="hljs-comment">// 成员变量传递结果 相当于model.add</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 处理获取商品列表的逻辑，这里直接模拟</span><br>        productList = ProductService.getProductList();<br>        <span class="hljs-keyword">return</span> SUCCESS;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Product&gt; <span class="hljs-title function_">getProductList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> productList;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.路由：封装servlet，Struts2的前端控制器DispatcherServlet接收并分发到对应的Action处理。</p><p>定义名为<code>productList</code>的Action，并将其关联到<code>ProductAction</code>类中的<code>list()</code>方法。当请求到达<code>/productList</code>时，Struts2会调用<code>list()</code>方法并将结果返回到<code>productList.jsp</code>页面中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">struts</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;product&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;struts-default&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;productList&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.ProductAction&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span>/WEB-INF/views/productList.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">struts</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.V层：配置Struts2的视图</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Product List<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>ID<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Description<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">s:iterator</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;productList&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;price&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;description&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">s:iterator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1.基本思想"></a>1.基本思想</h3><p>在servlet基本思想中，编写一个控制器，就要去web.xml中去注册，<strong>在SpringMVC中，使用dispatchservlet拦截所有</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>loginout<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.xiao.servlet.user.LogoutServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>loginout<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/jsp/logout.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置web.xml（拦截全部的请求）   配置springmvc.xml      编写controller(component-scan)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046871.png" alt="image-20221212145632004"></p><ol><li><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--1.注册DispatcherServlet--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span><br><span class="hljs-comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>springmvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--处理器映射器 定位到方法--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--处理器适配器  解析参数--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注解驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span>  包含映射器、适配器  实验发现是必须要<br></code></pre></td></tr></table></figure></li><li><p>编写controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">手动配置，这里的id就是访问的路径<br>&lt;bean id=<span class="hljs-string">&quot;/helloserv&quot;</span> class=<span class="hljs-string">&quot;com.kuang.controller.Helloservlet&quot;</span>&gt;&lt;/bean&gt;<br><br>或者 不可以同时配置<br><br>&lt;!-- 注解扫描 --&gt;<br>&lt;context:component-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.kuang.controller&quot;</span>/&gt;<br><br><span class="hljs-meta">@Controller</span> <span class="hljs-comment">// 注入bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/helloserv&quot;)</span> <span class="hljs-comment">// 访问路径</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(Model model)</span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello annotation&quot;</span>);   <span class="hljs-comment">//model</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//view</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>在 Controller 中，根据业务逻辑查询出需要显示的动态数据，并将其封装成一个 Model 对象。</li><li>将 Model 对象作为参数传递给模板引擎（根据返回值定位页面），通过 Thymeleaf 的表达式语言 ${} 将动态数据注入到 HTML 模板中。</li><li>Thymeleaf 模板引擎会根据 HTML 模板中定义的逻辑和数据，生成渲染后的 HTML 页面，并将其返回给客户端浏览器。</li><li>客户端浏览器接收到 HTML 页面后，根据 HTML 标签和 CSS 样式渲染页面，并显示给用户。</li></ul><p>想访问一个商品列表页面：</p><ol><li>controller定义toList接口，</li><li>加载数据到model里，return “toList”跳转到toList.html，thymeleaf会自动渲染数据进入页面对应的${}</li></ol><h3 id="2-跳转"><a href="#2-跳转" class="headerlink" title="2.跳转"></a>2.跳转</h3><p>servlet</p><ul><li>forward 请求转发 地址栏不变，获得商品列表后转发到商品界面</li><li>redirect 重定向</li></ul><p>controller -&gt; 页面       </p><ul><li>默认返回就是forward</li><li>重定向return “redirect:&#x2F;index.jsp”  不经过视图解析器</li></ul><p>controller -&gt; controller </p><ul><li>return “forward:&#x2F;path”</li><li>return “redirect:&#x2F;path”</li></ul><h3 id="3-参数接受"><a href="#3-参数接受" class="headerlink" title="3.参数接受"></a>3.参数接受</h3><p>vo：专门用来传值的对象</p><p>struts2：成员变量接收参数 多例</p><p>springmvc：</p><p>@RequestBody 反序列化 @ResponseBody 序列化成json </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">局部变量，无线程安全问题，单例<br><br><span class="hljs-comment">// restful风格</span><br><span class="hljs-meta">@RequestMapping(&quot;/test2/&#123;pageNo&#125;“)</span><br><span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> pageNo 将URL中的占位符参数绑定到控制器处理方法的入参<br>    <br><span class="hljs-meta">@RequestParam</span> String name  Url Form表<br>User user  url中自动对应<br><br><span class="hljs-meta">@RequestBody</span> User user  Body中raw格式下的json参数 <br></code></pre></td></tr></table></figure><p>前端可以混用，一个在params，一个在data</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@<span class="hljs-title class_">RequestParam</span> <span class="hljs-title class_">String</span> resourceId,<br>@<span class="hljs-title class_">RequestParam</span> <span class="hljs-title class_">String</span> examId,<br>@<span class="hljs-title class_">RequestBody</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">UpdateExamAnswer</span>&gt; examAnswerList,<br>@<span class="hljs-title class_">RequestParam</span>(value = <span class="hljs-string">&quot;writeType&quot;</span>, defaultValue = <span class="hljs-string">&quot;0&quot;</span>) int writeType<br><br><span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-variable constant_">BASE_URL</span> + <span class="hljs-string">&#x27;/submit_all_save&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      resourceId,   <span class="hljs-comment">// 普通字符 拼接到url      @RequestParam</span><br>      examId,<br>      writeType<br>    &#125;,<br>    <span class="hljs-attr">data</span>: questionRes <span class="hljs-comment">// json格式    @RequestBody</span><br>  &#125;)<br></code></pre></td></tr></table></figure><p>此外，以上默认post为<code>application/json</code>格式发送接受数据</p><ol start="2"><li><code>application/x-www-form-urlencoded</code> 前端URLSearchParams或Qs.Stringify(data)      后端@RequestParam或不加</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>数据格式：loginName=lst&amp;password=<span class="hljs-number">1</span><br><br>百分号编码：<br>丁 十六进制下是<span class="hljs-number">0</span>xE4B881占<span class="hljs-number">3</span>字节<br>转成字符串‘E4B881’，占六字节<br>每两个字节前加上百分号前缀，得到字符串“%E4%B8%<span class="hljs-number">81</span>”，占九个字节（十六进制下是<span class="hljs-number">0</span>x244534254238253831）<br>把这九个字节拼接到数据包里，这样就可以传输“非ascii字符的  utf8编码的 十六进制表示的 字符串的 百分号形式”<br></code></pre></td></tr></table></figure><p>3.<code>multipart/form-data</code>  前端FormData格式，后端@RequestParam或不加</p><h3 id="4-返回参数："><a href="#4-返回参数：" class="headerlink" title="4.返回参数："></a>4.返回参数：</h3><p>request（单次请求）  session(浏览器) application(全体用户共享)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">forward跳转<br>    Model model 对request的封装，作用一样<br>         model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello annotation&quot;</span>);   <br>取出：$&#123;requestScope.msg&#125;<br>redirect<br>    <span class="hljs-number">1.</span>地址栏拼接 <br>    <span class="hljs-number">2.</span>session  req.getSession.setAttribute<br></code></pre></td></tr></table></figure><h3 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5.拦截器"></a>5.拦截器</h3><p>javaweb：filter过滤器，可以拦截一切资源。springmvc只能拦截controller</p><p>编写拦截器类，再注册：注入bean，定义拦截的地方。（或者定义和拦截写在一起）</p><p>这里继承<strong>HandlerInterceptor</strong>，有<strong>处理前</strong>，（controller）处理后，清理后</p><p>AOP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 放行OPTIONS请求</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OPTIONS&quot;</span>.equals(request.getMethod())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(token == <span class="hljs-literal">null</span>)&#123;<br>            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;未携带token&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                JWTUtils.verity(token);<br>                <span class="hljs-comment">// 未出错 放行</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">catch</span> (SignatureVerificationException e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;无效签名&quot;</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (TokenExpiredException e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;token过期&quot;</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (AlgorithmMismatchException e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;token算法不一致&quot;</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;token无效&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        map.put(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-number">500</span>);<br>        map.put(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(map);<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>        response.getWriter().println(json);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--拦截器注入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--可以写多个拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.JWTInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  或者分开 <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span> = <span class="hljs-string">&quot;beanname&quot;</span>&gt;</span><br>    &lt;/mvc:interceptor &gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h3><p>编写异常处理类，<strong>注册bean</strong>就行。可以根据不同的异常if判断处理不同逻辑 </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046872.png" alt="image-20221216183658625"></p><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><p>这里7.a scan可以只扫描service下的，因为mapper和controller都扫描了；mapper可以不使用注解（mapperscanconfig是和spring整合的；等价在springboot中使用了@Mapper或@MapperScan）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046873.png" alt="image-20221215092403942"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046874.png" alt="image-20221216205759155"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--扫描service下的包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.service&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    这里使用注解实现--&gt;</span><br>    <span class="hljs-comment">&lt;!--将service层装入--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;bean id=&quot;bookServiceImpl&quot; class=&quot;com.kuang.service.BookServiceImpl&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;/bean&gt;--&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--开启注解事务生效--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 配置整合mybatis --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.关联数据库文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span></span><br><span class="hljs-tag">            <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:database.properties&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 2.数据库连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置连接池属性 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 关闭连接后不自动commit --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoCommitOnClose&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 获取连接超时时间 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireRetryAttempts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注入数据库连接池 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br>    <span class="hljs-comment">&lt;!--解释 ： https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注入sqlSessionFactory --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.kuang.dao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.ab 让mvc在服务器启动时创建工厂(提供service Dao)。</p><p>实际项目中，可以把所有的文件整合到一起applicationContext，在servlet中配置</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046875.png" alt="image-20221215093143429"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046876.png" alt="image-20221216210140557"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046877.png" alt="image-20221216210029653"></p><p>C:\Users\13000\Desktop\study\vue-spring\2.vue-spring\7.springmvc\0代码———————————-\ssmbuild</p><p>spring.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置整合mybatis --&gt;</span><br><span class="hljs-comment">&lt;!-- 1.关联数据库文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span></span><br><span class="hljs-tag">                              <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:database.properties&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="hljs-comment">&lt;!--数据库连接池</span><br><span class="hljs-comment">    dbcp 半自动化操作 不能自动连接</span><br><span class="hljs-comment">    c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置连接池属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 关闭连接后不自动commit --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoCommitOnClose&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 获取连接超时时间 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireRetryAttempts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入数据库连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br><span class="hljs-comment">&lt;!--解释 ： https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入sqlSessionFactory --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.kuang.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--service相关--&gt;</span><br><span class="hljs-comment">&lt;!--配置声明式事务，开启注解事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span>&lt;/tx:annotation-driven &gt; <br><br><span class="hljs-comment">&lt;!--扫描service下的包, 也可以手动写入bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.service&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--将service层装入--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;bean id=&quot;bookServiceImpl&quot; class=&quot;com.kuang.service.BookServiceImpl&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;/bean&gt;--&gt;</span><br></code></pre></td></tr></table></figure><p>springmvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注解扫描 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.controller&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><span class="hljs-comment">&lt;!--注解驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><br>web.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatchservlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatchservlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213652.png" alt="image-20210808133147935" style="zoom:67%;" /><p>MAC首部 + IP首部 + TCP首部 + TCP数据</p><p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213424.png" alt="image-20230408150044809"></p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>多台机器如何传输： 数据要有标识来源MAC地址(from to)</p><ul><li>HUB集线器：直接转发给全部机器，不能同时发送，需要CSMA&#x2F;CD，半双工</li><li>交换机：有一张MAC地址和端口的表（自学习），定向转发。通过网线可以实现全双工</li></ul><h4 id="CSMA-x2F-CD"><a href="#CSMA-x2F-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h4><p>​多址接入、载波监听、碰撞检测</p><p>​往返时间为2t，每个数据包要大于2t发送时间（最短有效帧长）。所有小于等于2t的都丢弃。</p><p>​1KM往返10us；10Mbit&#x2F;s ，512bit(64B)最短帧长，总线不能超过5120m。考虑衰减：2500m</p><p>​64<em>8&#x2F;10^7^  &gt;&#x3D;   5120 * 2 &#x2F; 2</em>10^8^</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">以太网的最小帧长是通过争用期计算出来的。一个站点开始发送数据后，最多经过时间 <span class="hljs-number">2</span>τ<span class="hljs-comment">(两倍的端-端时延)</span>就可知道是否发生了碰撞 即一端发送一个帧，在无限接近另一端的位置发生了碰撞，然后碰撞信息再从碰撞位置传递回来，刚好就是一个往返以太网的端到端往返时延<span class="hljs-number">2</span>τ称为争用期，或碰撞窗口 ，如果经过争用期还没有检测到碰撞，就可以肯定这次发送不会发生碰撞为什么最短帧的大小取决于争用期时长？因为如果最短帧的传输时间小于争用期（比如<span class="hljs-number">30</span>μs），那么就会导致发送完这个帧之后，在不知道帧有没有传送成功的情况下（至少需要<span class="hljs-number">51.2</span>μs来确定）又发送了下一个帧。反之，如果最短帧的传输时间大于争用期，由于碰撞信息一定可以在帧发送完之前传到，就可以保证只有在上一个帧没有发生碰撞，正确传输的情况下才会发送下一个帧。对于最大长度为<span class="hljs-number">2500</span>米的<span class="hljs-number">10</span>Mbps 网络和四个中继器（来自<span class="hljs-number">802.3</span>规范），在最坏的情况下，往返时间（包括通过四个中继器的传播时间）被确定为接近<span class="hljs-number">50</span>微秒。因此，允许的最短帧必须至少花费这么长的时间来传输。在<span class="hljs-number">10</span>Mbps时，一个比特需要<span class="hljs-number">100</span>纳秒，所以<span class="hljs-number">500</span>比特是保证工作的最小帧。为了增加一些安全边际，这个数字被四舍五入到<span class="hljs-number">512</span>比特即<span class="hljs-number">64</span>字节，相应的，以太网的争用期长度也被确定为<span class="hljs-number">51.2</span> μs  据此规定以太网帧长≥ <span class="hljs-number">64</span> 字节，长度小于<span class="hljs-number">64</span>字节的帧为无效帧<br></code></pre></td></tr></table></figure><p><strong>ARP</strong> ： IP-》MAC</p><p><strong>差错检验：</strong> CRC</p><p><strong>可靠传输：</strong>ARQ停止等待、回退N帧（可以发多个）、选择重传（可以不按序接收）</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>设备太多了交换机的表记录不下来。通过路由器构建多个网络间的连接，一个路由器有多个接口(ip)对应多个子网</p><p><strong>通信方式</strong></p><ul><li>子网间通信：发给默认网关。由某路由器根据路由表转发</li><li>同一子网通信：直接通过交换机</li></ul><p><strong>路由表：</strong>目的网络地址、子网掩码、下一跳(下一个路由表ip地址)、接口</p><p>​我想访问IP通过子网掩码后，如果于路由表的目的网络地址对应上了，则转发到下一跳</p><p><strong>路由表如何构建：</strong> 单个目标网络可能有多个路径，如何选取最优</p><ul><li><strong>RIP</strong>(小型网络)。额外维护一个<strong>距离信息</strong>。每30s邻居向自己发送（可达地址+距离），如果距离更短则更新下一条和距离。坏消息传得慢</li><li><strong>OSPF</strong>。每个路由搜集全部路由联络信息LSA，构建LSDB(Link State DataBase)掌握全网的拓扑结构，然后构建权重有向图，再计算最短路径</li></ul><p><strong>传输过程中，IP地址(4*8 )不变，但MAC地址一直在变</strong></p><p><strong>NAT</strong>：内网访问外网，分配临时IP</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>​<strong>应用间通信</strong></p><p>​端口区分应用：FTP 21、TELNET 23、 SMTP 25、 DNS 53、 HTTP 80、 HTTPS 443 </p><p>TCP<strong>可靠传输</strong>：发送需要确认 （滑动窗口）、超时重传</p><ol><li>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</li><li>对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失</li></ol><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p><strong>三次握手</strong>：防止假如a发了两次请求，第一次以为失败了，而b接受了两次请求，第二次一直在等a浪费时间。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213425.png" alt="image-20230419102228437"></p><p><strong>四次挥手</strong>：1 a发出关闭请求，2 b发出响应确认，并半关闭状态不断发送信息， 3 最后发送关闭请求。a确认关闭请求</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213426.png" alt="image-20230419102236858"></p><h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>可靠传输通过<strong>发送需要确认</strong>(确认序号)和<strong>超时重传</strong>来实现，为提高效率使用滑动窗口</p><ul><li><strong>滑动窗口</strong>：以发送但未确认的最大字节数。接收方接受窗口如果接受到无序的数据先缓存</li><li><strong>超时重传：</strong> 指数加权移动RTT，不考虑超时重传的报文</li></ul><h4 id="流量拥塞控制"><a href="#流量拥塞控制" class="headerlink" title="流量拥塞控制"></a>流量拥塞控制</h4><p><strong>流量控制:</strong> 不断回发<strong>接收方</strong>的窗口大小</p><p><strong>拥塞控制</strong>（拥塞窗口大小）：<strong>慢启动（指数）、拥塞避免（线性）、快重传 （3个ack后立即重发）、快恢复（对于快重传情况，拥塞后直接从新门限开始）</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213427.png" alt="image-20210808142023374" style="zoom: 80%;" /><p>发送窗口 &#x3D; min(接收窗口，拥塞窗口)</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>应用  应用层运输层</strong></p><p>电子邮箱SMTPTCP</p><p>远程访问 TELNETTCP</p><p>万维网HTTPTCP</p><p>文件传输FTPTCP</p><p>域名解析DNSUDP</p><p>IP电话专用协议UDP</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="ARP协议-Address-Resolution-Protocol"><a href="#ARP协议-Address-Resolution-Protocol" class="headerlink" title="ARP协议 (Address Resolution Protocol)"></a>ARP协议 (Address Resolution Protocol)</h3><p>封装成帧时，通过ARP将IP-&gt;MAC地址。ARP 高速缓存中有就拿，没有就广播询问</p><h3 id="RIP-Routing-Information-Protocol-距离矢量路由协议"><a href="#RIP-Routing-Information-Protocol-距离矢量路由协议" class="headerlink" title="RIP (Routing Information Protocol, 距离矢量路由协议)"></a>RIP (Routing Information Protocol, 距离矢量路由协议)</h3><p>维护路由器一张表：目的网络 、距离、下一跳     坏消息传得慢</p><h3 id="NAT-Network-Address-Translation-网络地址转换"><a href="#NAT-Network-Address-Translation-网络地址转换" class="headerlink" title="NAT (Network Address Translation, 网络地址转换)"></a>NAT (Network Address Translation, 网络地址转换)</h3><p>将内网IP地址转化为临时外网IP地址，保持到NAT转换表中。</p><h3 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h3><ol><li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li><li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li><li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li></ol><ul><li>服务器发公钥给浏览器，浏览器随机数（传输密钥）加密后传给浏览器，浏览器再私钥解密得到 传输密钥（<code>非对称+对称加密</code>  、如果只非对称加密，浏览器的数据会被窃取）</li><li>问题：如果中间人用窃取公钥并拦截，并生成自己的公钥发给浏览器，作为中间商，就会出问题</li><li>如何确定浏览器收到的公钥是服务器给的：（域名、第三方机构、服务器公钥）给CA，CA添加数字签名（内容-&gt;hash-&gt;私钥加密）后给浏览器。浏览器解密（CA的公钥，浏览器信任的CA机构）看是否和明文hash一致</li></ul><h3 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h3><p>Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案</p><p>保存Sessionid的方式可以采用Cookie，请求时携带。如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。</p><h3 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h3><ol><li>浏览器查询 DNS，获取IP</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>TCP&#x2F;IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ol><h3 id="HTTP请求有哪些常见状态码？"><a href="#HTTP请求有哪些常见状态码？" class="headerlink" title="HTTP请求有哪些常见状态码？"></a>HTTP请求有哪些常见状态码？</h3><ol><li>2xx状态码：操作成功。200 OK</li><li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li><li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li><li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2021/09/08/%E6%9C%BA%E7%BB%84/"/>
    <url>/2021/09/08/%E6%9C%BA%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304061952053.png" alt="image-20210531150601852"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062002396.png" alt="image-20210531111032467" style="zoom: 67%;" /><p>软件</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012811.png" alt="image-20210531111208860" style="zoom:67%;" /><p>硬件</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012813.png" alt="image-20210531112655239"></p><h3 id="1-冯诺依曼"><a href="#1-冯诺依曼" class="headerlink" title="1.冯诺依曼"></a>1.冯诺依曼</h3><p>ENIAC手动接线代表指令。冯诺依曼将指令存储起来</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012814.png" alt="image-20210531113110649" style="zoom: 80%;" /><p><strong>运算器</strong>为中心，数据要经过运算器。</p><p>现代的将<strong>存储器</strong>为中心</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012815.png" alt="image-20210531113528807"></p><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><p>取存数据的程，现代这两个寄存器继承到了cpu里面</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012816.png" alt="image-20210531113844906" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012817.png" alt="image-20210531113937808" style="zoom:50%;" /></p><p>通过<strong>译码器</strong>将地址转为one hot，1的那个为接通</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012818.png" alt="image-20210531153111051"></p><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012819.png" alt="image-20210531114435559"></p><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012820.png" alt="image-20210531114630517"></p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>a * b + c 的执行过程，高级语言转为指令存放到内存中。这里的指令是单地址指令</p><p>根据pc从内存取指令(初始0)   <strong>-&gt;</strong>   分析指令（操作码）    <strong>-&gt;</strong>   执行指令内容      <strong>指令和数据都是来自存储体</strong>   </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012821.png" alt="image-20210531115304027"></p><p>将机器指令转换为多条微指令</p><p>高级语言  -&gt;（编译）  汇编语言    -&gt;  操作系统  -&gt;（汇编） 机器语言 01   -&gt;    微指令</p><p>或者直接将高级语言转为机器语言（python）逐句翻译</p><h4 id="主频"><a href="#主频" class="headerlink" title="主频"></a>主频</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012822.png" alt="image-20210531151536611"></p><h4 id="波特率比特率"><a href="#波特率比特率" class="headerlink" title="波特率比特率"></a>波特率比特率</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012823.png" alt="image-20210607222453605"></p><h3 id="2-基础"><a href="#2-基础" class="headerlink" title="2.基础"></a>2.基础</h3><h4 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1.进制转换"></a>1.进制转换</h4><p>十进制转其他</p><p>​整数除基取余</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012824.png" alt="image-20210601113732024"></p><p>​小数乘基取整</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012825.png" alt="image-20210601113850208"></p><p>二进制转其他（4、8、16）：多位一组，分组转换</p><h4 id="2-BCD码"><a href="#2-BCD码" class="headerlink" title="2.BCD码"></a>2.BCD码</h4><p>用二进制表达十进制数，当超过10时需要加6修正</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012826.png" alt="image-20210601114659976"></p><h4 id="3-ASCII"><a href="#3-ASCII" class="headerlink" title="3.ASCII"></a>3.ASCII</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012827.png" alt="image-20210601114946178" style="zoom: 50%;" /><p>汉字7445个，需要2B</p><h4 id="4-校验"><a href="#4-校验" class="headerlink" title="4.校验"></a>4.校验</h4><p><strong>奇校验</strong>：加完校验1的个数为<strong>奇数个</strong>，一般放前面</p><p><strong>海明校验</strong>：p的位置为2^n，标记出出错位置</p><p>d为数据，p为校验码<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012828.png" alt="image-20210601120945066"></p><p>pi为d为1的下标上第i为异或得到，共需要大约log2位用来校验<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012829.png" alt="image-20210601121114649"></p><p><strong>循环冗余校验CRC ：</strong></p><p>有一个给出的生成多项式，最高为x次<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012830.png" alt="image-20210601121801336">，转为二进制被除数1101有x+1位，将数据左移x位后除以该数（模二除），得到的余数就是校验位。发送   移位后的数  加上  余数。</p><p>校验：数据模二除多项式，余数为零</p><h4 id="5-数据表示"><a href="#5-数据表示" class="headerlink" title="5.数据表示"></a>5.数据表示</h4><p>无符号数： 0 ~ 2^n-1</p><p>有符号数：一位表示符号</p><p>定点小数：纯小数。0. x，再加一位表示符号<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012831.png" alt="image-20210601122710917" style="zoom:67%;" /></p><p>原码：有符号数<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012832.png" alt="image-20210601123056307">，加减计算需要讨论符号</p><p>反码：负数按位取反</p><p><strong>补码</strong>：负数按位取反，末尾加一（原理上是用溢出值减绝对值）。计算直接加</p><p>移码：加上128后，转为无符号机器数。比较大小</p><p><strong>移位：</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012833.png" alt="image-20210601131324554" style="zoom: 67%;" /><p><strong>溢出判断</strong></p><p>​1.通过符号判断</p><p>​2.进位判断法：V&#x3D; S异或C 其中S为符号位产生的进位,C为最高有效位产生的进位。 </p><p>​3.双符号位： V&#x3D;Sf1 Sf2 + 其中,Sf1和Sf2分别为最高符号位及第二符号位。</p><h4 id="求补电路："><a href="#求补电路：" class="headerlink" title="求补电路："></a>求补电路：</h4><p>将补码表示的<strong>带符号数</strong>转换成 <strong>无符号绝对值</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012834.png" alt="image-20210601171422268"></p><h4 id="绝对值乘法"><a href="#绝对值乘法" class="headerlink" title="绝对值乘法"></a>绝对值乘法</h4><p>acc中保存当前进位，MQ高位保存结果以及低位未计算的乘数，当乘数都移出去后，结果就是ACC MQ</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012835.png" alt="image-20210601154034355"></p><h4 id="绝对值除法"><a href="#绝对值除法" class="headerlink" title="绝对值除法"></a>绝对值除法</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012836.png" alt="image-20210601160052898"></p><p>ACC中放当前值，MQ中放结果</p><h4 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012837.png" alt="image-20210601161602994" style="zoom: 80%;" /><p>规格化，M左移使得最高位有效</p><p>溢出时，将M右移</p><p><strong>IEEE 754</strong>       <img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012838.png" alt="image-20210601163257381"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012839.png" alt="image-20210601165117606">)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012840.png" alt="image-20210601163002198"></p><p>浮点数运算：小阶向大阶看齐</p><h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4><p>Arithmetic and logic unit  算数、逻辑、移位</p><p>与非：<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012841.png" alt="image-20210601165845453">现实容易实现</p><p>异或：<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012842.png" alt="image-20210601165936688">和加法的逻辑类似</p><p>全加器：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012843.png" alt="image-20210601170821403" style="zoom:50%;" /><p>多位串行：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012844.png" alt="image-20210601171144274" style="zoom:80%;" /><p>并行</p><p>组内并行，组间串行</p><h3 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3.存储器"></a>3.存储器</h3><p>读取过程：地址线先传送地址数据到MAR，略微等待后<strong>片选线</strong>和<strong>读写控制线</strong>给出信号，将数据读入MDR中</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012845.png" alt="image-20210602131615023"></p><p>实际上，地址是有<strong>行选和列选</strong>（需要的线少一倍），刷新时是以行为单位。</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012846.png" alt="image-20210602133806204" style="zoom:50%;" /><p>地址线连接MAR（行列分别传入），数据线连接MDR</p><p><strong>寻址方式：</strong>按字、字节、半字、双字寻址</p><p><strong>存储方法：</strong></p><p>​小段方式：先放低位字节，低位在左</p><p>​大段方式：先放高位，高位在左</p><h4 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h4><p>辅存不和cpu直接通信，主存RAM+ROM</p><h5 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h5><p>Random Access Memory</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012847.png" alt="image-20210602133519525"></p><p>刷新时间：2ms要都刷新过一次。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012848.png" alt="image-20210602134144186"></p><h5 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h5><p>Read only Memory</p><p>保存必要信息，非易失。保存os在辅存中的位置，开机必要信息</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012849.png" alt="image-20210603102734100" style="zoom: 67%;" /><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="位扩展："><a href="#位扩展：" class="headerlink" title="位扩展："></a><strong>位扩展</strong>：</h5><p>​进行位数的扩充（加大字长） 一个存储器对应byte中的一位</p><p>​例:使用16K<em>1的存储器芯片组成16K</em>8位的存储器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012851.png" alt="image-20210603104237304"></p><h5 id="字扩展法"><a href="#字扩展法" class="headerlink" title="字扩展法:"></a><strong>字扩展法</strong>:</h5><p>​进行字向扩充(位数不变)  需要先选择取哪个存储器</p><p>​例如：用16K*8位的芯片组成64K *8位的存储器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012852.png" alt="image-20210603104254082"> </p><p>​A0~A13为地址选择 A14 A15为芯片选择（2:4译码器）</p><h5 id="字位同时扩展法"><a href="#字位同时扩展法" class="headerlink" title="字位同时扩展法:"></a>字位同时扩展法:</h5><p>​一个存储器的容量为M<em>N位,若使用 l</em>k位的芯片(l&lt;M,K&lt;N),需要在字向和位向同时进行扩展. 此时共需(M&#x2F;l)*(N&#x2F;k)个存储器芯片</p><h4 id="多体并行存储体"><a href="#多体并行存储体" class="headerlink" title="多体并行存储体"></a>多体并行存储体</h4><p>低位交叉编址</p><p>（右图）将相邻的单元放到不同的存储体中，这样<strong>不需要等待恢复时间</strong>再去读取下一个（流水线）</p><p>需要满足当再一次读取到M0时，M0已经恢复</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012853.png" alt="image-20210603112354973" style="zoom: 67%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012854.png" alt="image-20210603111717030"></p><p>宏观上扩展了4倍</p><h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>空间局部性原理（访问的都是相近的元素）</p><p>cache和主存可以<strong>以块为单位</strong>交流</p><p>标记项：cache是从主存中<strong>哪里来的</strong>、cache<strong>是否有效</strong></p><h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>​随便放，查找时遍历查看</p><h5 id="直接映射："><a href="#直接映射：" class="headerlink" title="直接映射："></a><strong>直接映射：</strong></h5><p>​主存第j块和Cache第i块有如下函数关系:</p><p>​i&#x3D; j mod m (m为Cache中总块数)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012855.png" alt="image-20210604111316459"></p><p>​访问过程：依据cache块号直接去查找，看表中对应保存的<strong>组号</strong>与主存中组号是否一样。</p><p>​空间利用率低,命中率也低，硬件实现简单,成本低.</p><h5 id="组相联映射："><a href="#组相联映射：" class="headerlink" title="组相联映射："></a><strong>组相联映射：</strong></h5><p>​将cache分组，主存必须放入对应组中，但组内可以随意放置</p><h5 id="替换与修改"><a href="#替换与修改" class="headerlink" title="替换与修改"></a>替换与修改</h5><p>RAND FIFO  LRU（最近最少使用）  LFU(历史次数)</p><p>写回法：脏位决定是否需要写回</p><p>全写法：有一个缓冲同时修改</p><h4 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h4><p>将访问外存（逻辑地址）映射到主存（物理地址）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012856.png" alt="image-20210604115521773"></p><h3 id="4-指令"><a href="#4-指令" class="headerlink" title="4.指令"></a>4.指令</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012857.png" alt="image-20210604165949832" style="zoom:67%;" /><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012858.png" alt="image-20210604152403058"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012859.png" alt="image-20210604153414463" style="zoom: 80%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012860.png" alt="image-20210604153350576" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012861.png" alt="image-20210604160201175"></p><h4 id="指令的址方式"><a href="#指令的址方式" class="headerlink" title="指令的址方式"></a>指令的址方式</h4><p>1.顺序寻址方式 2.跳跃寻址方式</p><h4 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式"></a>数据寻址方式</h4><p>用寻址特征表明现在的寻址方式</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012862.png" alt="image-20210604161158449" style="zoom:67%;" /><p>立即寻址</p><p>寄存器寻址 </p><p>直接寻址</p><p>寄存器间接寻址</p><p>基址寻址（BR）面向操作系统，内容操作系统确定，有利于<strong>多道程序数据块</strong></p><p>变址寻址（IX）用于循环程序，<strong>数组</strong>的偏移</p><p>相对寻址（PC）  （PC）+A  <strong>跳转指令</strong></p><p>寄存器寻址：（SP）保存栈顶指针</p><p>间接寻址</p><h4 id="CISC、RISC"><a href="#CISC、RISC" class="headerlink" title="CISC、RISC"></a>CISC、RISC</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012863.png" alt="image-20210604165458037"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012864.png" alt="image-20210604165743389"></p><h3 id="5-CPU"><a href="#5-CPU" class="headerlink" title="5.CPU"></a>5.CPU</h3><p>ALU+CU+寄存器+中断系统</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012865.png" alt="image-20210605121433796" style="zoom:67%;" /><h4 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h4><p>cpu<strong>内部总线</strong>完成内部数据传输；MAR，MDR要和<strong>内外总线</strong>都要连接</p><p>还有一种结构为：寄存器之间通过<strong>专用线</strong>连接</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012866.png" alt="image-20210605122928712"></p><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>一个机器周期（CPU周期）是一次存取周期</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012867.png" alt="image-20210605123401431" style="zoom: 67%;" /><h4 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h4><p>取指、取数</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012868.png" alt="image-20210605132815242" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012869.png" alt="image-20210605132849850" style="zoom: 67%;" /></p><h4 id="控制器-1"><a href="#控制器-1" class="headerlink" title="控制器"></a>控制器</h4><p><strong>cpu控制方式：</strong></p><p>​同步控制方式、异步控制方式、联合控制方式</p><p>同步：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012867.png" alt="image-20210605123401431" style="zoom: 67%;" /><h5 id="硬布线：RISC"><a href="#硬布线：RISC" class="headerlink" title="硬布线：RISC"></a><strong>硬布线：</strong>RISC</h5><p><strong>节拍发生器</strong>：将时钟转为节拍</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012870.png" alt="image-20210605141903363" style="zoom:50%;" /><p><strong>安排微操作的时钟节拍</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012871.png" alt="image-20210605135938501"></p><p><strong>设计电路</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012872.png" alt="image-20210605141448990"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012873.png" alt="image-20210605141717000"></p><h5 id="微程序：CISC"><a href="#微程序：CISC" class="headerlink" title="微程序：CISC"></a>微程序：CISC</h5><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012874.png" alt="image-20210605154140727" style="zoom:50%;" /><p>​将微指令保存到控制存储器CM中（CPU内部，ROM实现，一条条已经写好的），类似于指令的保存执行</p><p>​水平型：可以同时执行。垂直型：类似机器指令</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012875.png" alt="image-20210605151805913"></p><p>​<strong>操作控制字段</strong>：标记一个个微操作，</p><p>​<strong>直接表示法</strong>：为1就执行 需要很长   <strong>快</strong></p><p>​<strong>编码表示法</strong></p><p>​<strong>混合</strong><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012876.png" alt="image-20210605152026694" style="zoom:50%;" />组内互斥</p><p>​<strong>顺序控制字段</strong>：下一条微指令是 跳转 还是 顺序 </p><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>将这几个过程重叠起来，并行运行</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012877.png" alt="image-20210605160344293" style="zoom: 67%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012878.png" alt="image-20210605160349615"></p><p><strong>问题：</strong></p><p>​时间不一样：全部统一为最长的时间</p><p><strong>冲突：</strong></p><p>​硬件：</p><p>​       结构相关（资源冲突）：硬件资源满足不了  <strong>同时需要访问内存</strong></p><p>​编程：</p><p>​   数据相关（数据冲突）：一条指令依赖前一条指令的执行结果(数据)却无法得到 c&#x3D;a+b； c++;</p><p>​ <strong>硬件直接暂停   添加空指令</strong>  <strong>数据旁路</strong>  <strong>编译优化</strong></p><p>​控制相关（控制冲突）：流水线遇到分支(if) 指令或其他改变PC值的指令</p><p>​（acm算法运行为非流水执行过程。）</p><h3 id="6-总线"><a href="#6-总线" class="headerlink" title="6.总线"></a>6.总线</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012879.png" alt="image-20210607212721351" style="zoom:67%;" /><p>​<strong>分时  共享</strong></p><p>​机械特性、电器特性、功能特性、时间特性</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>​串行、并行（宽度高、频率低） </p><p>​(内部总线、系统总线（数据、地址、控制）、I&#x2F;O总线) <strong>轮询</strong></p><p>​单总线双总线（速度不同，进行分离）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012880.png" alt="image-20210607213949316" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012881.png" alt="image-20210607213918796" style="zoom:50%;" /></p><p>​三总线（提高io速度）       <strong>DMA控制器</strong>控制高速传输（不用CPU），别的<strong>中断</strong>（鼠标键盘）实现</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012882.png" alt="image-20210607214207930" style="zoom: 67%;" /><p>4总线</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012883.png" alt="image-20210607225218682"></p><p>​地址总线(AB)—其宽度可表明地址空间范围  32位寻址范围2^32 4G</p><p>​数据总线(DB)—其宽度可表明一次读写的二进制位数  32位4B</p><p>​控制总线(CB)— 包括各种控制命令(如存储器读 写、I&#x2F;O读写)、请求信号与仲裁信号、中断请求与应答 等。</p><p>​<strong>复用AB和DB</strong></p><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>​时钟周期T：机器的时钟周期     时钟频率：1&#x2F;T</p><p>​传输周期：N个时钟周期：申请、寻址、传输、结束工作频率：1&#x2F;N</p><p>​总线宽度：DB宽度</p><p>​总线带宽：每秒传输的B ，工作频率 * 总线带宽 &#x2F; 8</p><h4 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h4><h5 id="集中总裁"><a href="#集中总裁" class="headerlink" title="集中总裁"></a>集中总裁</h5><p>​<strong>链式查询</strong>：BR BG BS ，  <strong>BG按顺序查询，距离近的优先级高</strong></p><p>​<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012884.png" alt="image-20210607220159388" style="zoom: 67%;" /></p><p>​<strong>计算器定时查询</strong>：独立的BG线，计数器每次加1代表访问下一个IO ， log n</p><p>​<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012885.png" alt="image-20210607220536152" style="zoom:67%;" /></p><p>​<strong>独立请求</strong>：需要排队、速度快。独立的BG线</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012886.png" alt="image-20210607220713828" style="zoom:67%;" /><h5 id="分布式仲裁："><a href="#分布式仲裁：" class="headerlink" title="分布式仲裁："></a><strong>分布式仲裁</strong>：</h5><p>​不需要中央仲裁器，每个潜在的主 方功能模块都有自己的仲裁号和仲裁器</p><p>​将总裁号发到总裁总线上去比较</p><h4 id="总线操作"><a href="#总线操作" class="headerlink" title="总线操作"></a>总线操作</h4><p>​申请分配（请求、仲裁）、寻址阶段、传输阶段、结束阶段</p><p>​<strong>同步定时方式</strong>：根据时钟的<strong>上升沿</strong>控制节奏</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012887.png" alt="image-20210607222304595" style="zoom:50%;" /><p>​<strong>异步定时方式</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012888.png" alt="image-20210607222129667" style="zoom: 50%;" /><p>​<strong>半同步通信</strong>：加控制信号，当数据没传到位时等待</p><p>​<strong>分离式通信：</strong>将准备数据时，总线控制权交出来</p><h4 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012889.png" alt="image-20210607224104543"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012890.png" alt="image-20210607224633259"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012891.png" alt="image-20210607224925037"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012892.png" alt="image-20210607225022641"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012893.png" alt="image-20210607225726363"></p><h3 id="7-IO"><a href="#7-IO" class="headerlink" title="7.IO"></a>7.IO</h3><p>CPU<strong>管理外围设备</strong>有几种方式：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012894.png" alt="image-20210626104910735" style="zoom:67%;" /><p>IO指令由CPU产生，用来控制IO；通道指令为通道产生，具体执行</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012895.png" alt="image-20210626103906731" style="zoom:67%;" /><h4 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h4><p>​输入： 鼠标键盘    输出 ：显示器打印机</p><p>​外存</p><p><strong>磁表面存储</strong> </p><p>​串行读取</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012896.png" alt="image-20210626110114399" style="zoom:67%;" /><p>​</p><p><strong>磁盘</strong></p><p>​按照扇区读取，寻道-&gt;旋转-&gt;传输时间。利用便宜可以实现加速或者冗余</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012897.png" alt="image-20210626110421321"></p><p><strong>光盘</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012898.png" alt="image-20210626111615777" style="zoom:50%;" /><p><strong>固态硬盘</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012899.png" alt="image-20210626111746131" style="zoom:67%;" /><h4 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h4><p>控制、读取io其实就是访问响应寄存器</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012900.png" alt="image-20210626112849731" style="zoom:67%;" /><p>如何定位编址？统一编址、独立编址（主存的编址和IO的编址是否在一起）</p><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>​比如每秒查询鼠标30次，询问鼠标有没有数据。查到了还需要等待鼠标传输数据</p><h4 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012902.png" alt="image-20210626114555456" style="zoom: 67%;" /><p>在指令完成后，查看中断源寄存器是否有1，有1就进入中断</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012903.png" alt="image-20210626182320701" style="zoom:67%;" /><p>实现<strong>优先级</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012904.png" alt="image-20210626184052004" style="zoom:67%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012905.png" alt="image-20210626184644527"></p><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>​接收IO请求，向CPU发出占用总线的请求</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手学深度学习CV</title>
    <link href="/2021/08/20/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0CV/"/>
    <url>/2021/08/20/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0CV/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html">https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html</a></p><p><a href="https://course.d2l.ai/zh-v2/">课程安排 - 动手学深度学习课程 (d2l.ai)</a></p><h1 id="动手学深度学习"><a href="#动手学深度学习" class="headerlink" title="动手学深度学习"></a>动手学深度学习</h1><p>AI map</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151329785.png" alt="image-20230515132921268" style="zoom:67%;" /><h3 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.arange(<span class="hljs-number">12</span>, dtype=torch.float32).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>torch.cat((X, Y), dim=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 合并</span><br>a.T <span class="hljs-comment"># 转置</span><br>a.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) a.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>) <br>a.mean() a.numel()<br><br>torch.dot(x,y) <span class="hljs-comment"># 向量点积</span><br>torch.mv(A,x)  <span class="hljs-comment"># 矩阵*向量</span><br>torch.mm(A,A)  <span class="hljs-comment"># 矩阵乘</span><br>torch.norm(A)  <span class="hljs-comment"># 二范数</span><br><br><span class="hljs-comment"># 广播机制自动扩展</span><br>a = torch.arange(<span class="hljs-number">3</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">1</span>))<br>b = torch.arange(<span class="hljs-number">2</span>).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>a+b<br><br><span class="hljs-comment"># 内存机制</span><br>X = Y<span class="hljs-comment"># id相同</span><br>Y += X     <span class="hljs-comment"># id(Y)不变</span><br><br>X = Y.clone() <span class="hljs-comment">#id 变了</span><br>Y = Y + X  <span class="hljs-comment"># id(Y)变了</span><br><br><span class="hljs-comment"># numpy 相互转换</span><br>A = torch.tensor(A)<br>A = A.numpy()<br></code></pre></td></tr></table></figure><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建数据csv文件</span><br>os.makedirs(os.path.join(<span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>), exist_ok=<span class="hljs-literal">True</span>)<br>data_file = os.path.join(<span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;house_tiny.csv&#x27;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_file, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="hljs-comment"># 列名</span><br>    f.write(<span class="hljs-string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="hljs-comment"># 每行表示一个数据样本</span><br>    f.write(<span class="hljs-string">&#x27;2,NA,106000\n&#x27;</span>)<br><br><span class="hljs-comment"># 读取csv</span><br>data = pd.read_csv(data_file)<br>data = data.fillna(data.mean())  <span class="hljs-comment"># 处理数值中的NA</span><br><span class="hljs-built_in">print</span>(data)<br>data = pd.get_dummies(data, dummy_na=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将数据转为0 1，添加新的列</span><br>torch.tensor(data.values)<br></code></pre></td></tr></table></figure><h4 id="向量求导"><a href="#向量求导" class="headerlink" title="向量求导"></a>向量求导</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151334475.png" alt="image-20210729204049868" style="zoom:50%;" /><h4 id="正向累积与反向求导"><a href="#正向累积与反向求导" class="headerlink" title="正向累积与反向求导"></a>正向累积与反向求导</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335071.png" alt="image-20210715122123643"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335072.png" alt="image-20210715122132742" style="zoom:50%;" /><h4 id="自动求导"><a href="#自动求导" class="headerlink" title="自动求导"></a>自动求导</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">x =  torch.arange(<span class="hljs-number">4.0</span>)<br>x.requires_grad_(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 等价于 `x = torch.arange(4.0, requires_grad=True)`</span><br>y = <span class="hljs-number">2</span> * torch.dot(x, x) <span class="hljs-comment"># loss一般为标量</span><br>y.backward() <span class="hljs-comment"># 反向传播</span><br>x.grad<br>tensor([ <span class="hljs-number">0.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">8.</span>, <span class="hljs-number">12.</span>])<br><br><span class="hljs-comment"># 梯度分离计算</span><br>x.grad.zero_()<br>y = x * x<br>u = y.detach()      <span class="hljs-comment"># u不计算梯度,相当于常数，从计算图剥离</span><br>z = u * x<br>z.<span class="hljs-built_in">sum</span>().backward()  <span class="hljs-comment">#非标量求sum，使得标量</span><br>x.grad == u<br></code></pre></td></tr></table></figure><p>sinx 和 sinx的求导</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x=torch.arange(<span class="hljs-number">0.</span>,<span class="hljs-number">10.</span>,<span class="hljs-number">0.1</span>)x.requires_grad_(<span class="hljs-literal">True</span>)y=torch.sin(x)y.<span class="hljs-built_in">sum</span>().backward()plt.plot(x.detach(), y.detach())plt.plot(x.detach(), x.grad)<br></code></pre></td></tr></table></figure><p>帮助文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">help</span>(torch.ones)<br></code></pre></td></tr></table></figure><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>模型：y &#x3D; &lt;x,w&gt; + b</p><p>损失：（y-y)^2^ </p><p>关于w求导，有显示解</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335073.png" alt="image-20210729210215127" style="zoom:50%;" /><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335074.png" alt="image-20210729210517365" style="zoom: 50%;" /><h5 id="BGD"><a href="#BGD" class="headerlink" title="BGD"></a><strong>BGD</strong></h5><p>(Batch Gradient Descent)</p><p>​使用全部数据集</p><h5 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a><strong>SGD</strong></h5><p>（stochastic gradient descent）</p><p>​使用1个数据</p><h5 id="MBGD"><a href="#MBGD" class="headerlink" title="MBGD"></a>MBGD</h5><p>（mini-batch Gradient Descent）</p><p>​使用batchsize</p><h5 id="动量法："><a href="#动量法：" class="headerlink" title="动量法："></a><strong>动量法：</strong></h5><p>梯度更新 &#x3D; 当前的梯度方向*0.1  +  之前的累加 (v) *0.9  (u) ，还可以逃出局部最优解   <strong>0.9</strong></p><h5 id="自适应梯度法"><a href="#自适应梯度法" class="headerlink" title="自适应梯度法"></a><strong>自适应梯度法</strong></h5><p><strong>RMSProp：</strong>调整学习率  <strong>0.999</strong></p><p>​对震荡方向减小变化，非震荡方向增大变化，变化值保存到r中,用梯度的平方表示震荡</p><h5 id="adam："><a href="#adam：" class="headerlink" title="adam："></a><strong>adam</strong>：</h5><p>​动量法+自适应+修正解决冷启动</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335075.png" alt="image-20210801153746463" style="zoom: 80%;" /><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>1.生成数据</p><p>2.生成batchsize迭代器</p><p>3.参数与模型定义 net &#x3D; nn.Sequential(nn.Linear(2, 1))</p><p>4.损失函数与优化 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 损失函数默认是batch中 平均</span><br>nn.MSELoss() <br>torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<br><span class="hljs-keyword">or</span> <br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>param -= lr * param.grad / batch_size<br></code></pre></td></tr></table></figure><ul><li>初始化参数</li><li>重复，直到完成<ul><li>计算损失                                           <strong>l&#x3D;loss(net(X), y)</strong></li><li>计算梯度 g←∂(w,b)1|B|∑i∈Bl(x(i),y(i),w,b)g←∂(w,b)1|B|∑i∈Bl(x(i),y(i),w,b)   <strong>l.backward()</strong></li><li>更新参数 (w,b)←(w,b)−ηg               <strong>trainer.step()</strong></li></ul></li></ul><h4 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h4><p>softmax转为概率，交叉熵来衡量概率区别</p><h4 id="图片分类"><a href="#图片分类" class="headerlink" title="图片分类"></a>图片分类</h4><p>784输入 ， 10输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mnist_train = torchvision.datasets.FashionMNIST(root=<span class="hljs-string">&quot;../data&quot;</span>, train=<span class="hljs-literal">True</span>,                                                transform=trans,                                                download=<span class="hljs-literal">True</span>)train_iter = data.DataLoader(mnist_train, batch_size, shuffle=<span class="hljs-literal">True</span>,                             num_workers=get_dataloader_workers())<br></code></pre></td></tr></table></figure><p>自定义croos_entropy需要先softmax，后面还需要sum；torch的都不用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">X</span>):    <br>    X_exp = torch.exp(X)    <br>    partition = X_exp.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)    <br>    <span class="hljs-keyword">return</span> X_exp / partition  <br><span class="hljs-comment"># 这里应用了广播机制</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">net</span>(<span class="hljs-params">X</span>):    <br>    <span class="hljs-keyword">return</span> softmax(np.dot(X.reshape((-<span class="hljs-number">1</span>, W.shape[<span class="hljs-number">0</span>])), W) + b)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy</span>(<span class="hljs-params">y_hat, y</span>):    <br>    <span class="hljs-keyword">return</span> -np.log(y_hat[<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_hat)), y])<br>y_hat[<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_hat)), y] <span class="hljs-comment"># 取出每个实际标签的得分</span><br></code></pre></td></tr></table></figure><p>net</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">net = nn.Sequential(nn.Flatten(), nn.Linear(<span class="hljs-number">784</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p>一次epoch训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_epoch_ch3</span>(<span class="hljs-params">net, train_iter, loss, updater</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;训练模型一个迭代周期（定义见第3章）。&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 将模型设置为训练模式</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(net, torch.nn.Module):<br>        net.train()<br>    <span class="hljs-comment"># 训练损失总和、训练准确度总和、样本数</span><br>    metric = Accumulator(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> train_iter:<br>        <span class="hljs-comment"># 计算梯度并更新参数</span><br>        y_hat = net(X)<br>        l = loss(y_hat, y)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(updater, torch.optim.Optimizer):<br>            <span class="hljs-comment"># 使用PyTorch内置的优化器和损失函数</span><br>            updater.zero_grad()<br>            l.backward()<br>            updater.step()<br>            metric.add(<br>                <span class="hljs-built_in">float</span>(l) * <span class="hljs-built_in">len</span>(y), accuracy(y_hat, y),<br>                y.size().numel())<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 使用定制的优化器和损失函数</span><br>            l.<span class="hljs-built_in">sum</span>().backward()<br>            updater(X.shape[<span class="hljs-number">0</span>])<br>            metric.add(<span class="hljs-built_in">float</span>(l.<span class="hljs-built_in">sum</span>()), accuracy(y_hat, y), y.numel())<br>    <span class="hljs-comment"># 返回训练损失和训练准确率</span><br>    <span class="hljs-keyword">return</span> metric[<span class="hljs-number">0</span>] / metric[<span class="hljs-number">2</span>], metric[<span class="hljs-number">1</span>] / metric[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>多次epoch，传入网络，训练数据，测试数据，loss，迭代次数，优化器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_ch3</span>(<span class="hljs-params">net, train_iter, test_iter, loss, num_epochs, updater</span>):<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):        train_metrics = train_epoch_ch3(net, train_iter, loss, updater)        <span class="hljs-comment"># 每次epoch后进行一次评估        test_acc = evaluate_accuracy(net, test_iter)</span><br></code></pre></td></tr></table></figure><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><p>Multilayer Perceptro</p><p>线性分类器只能产生线性分类器，XOR函数不能拟合</p><p>多层线性＋激活函数 sigmoid tanh relu</p><p>SVM多超参数不敏感，用起来更简单</p><p>深层比浅层更好训练</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335076.png" alt="image-20210802172049923" style="zoom:50%;" /><h4 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h4><p>训练误差，泛化误差</p><p>训练集 、验证集、 测试集</p><p>训练集训练参数，验证集来选择模型超参数</p><h5 id="k折交叉验证"><a href="#k折交叉验证" class="headerlink" title="k折交叉验证"></a>k折交叉验证</h5><p>​小数据集：K次模型训练和验证，每次在K−1个子集上进行训练，并在剩余的一个子集验证，K次实验的结果取平均来估计训练和验证误差。k&#x3D;5、10</p><h5 id="过拟合欠拟合"><a href="#过拟合欠拟合" class="headerlink" title="过拟合欠拟合"></a>过拟合欠拟合</h5><p>过拟合：模型相比于数据过于复杂</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335077.png" alt="image-20210803135322068"></p><p>模型输入为x^0  x^1  x^2 ….</p><p>当模型给到了x^20次方时，会过拟合</p><h4 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h4><p><strong>手动实现</strong>：loss中加上一个损失，lambd&#x3D;8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">l = loss(net(X), y) + lambd *  torch.<span class="hljs-built_in">sum</span>(w.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>)) / <span class="hljs-number">2</span><br>l.<span class="hljs-built_in">sum</span>().backward()<br>d2l.sgd([w, b], lr, batch_size)<br></code></pre></td></tr></table></figure><p><strong>迭代器</strong>：weight_decay &#x3D; 0.001</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 都有衰减</span><br>trainer = torch.optim.SGD(net.parameters(),weight_decay = wd, lr=lr)<br><span class="hljs-comment"># 偏置参数没有衰减。</span><br>trainer = torch.optim.SGD([&#123;<br>    <span class="hljs-string">&quot;params&quot;</span>: net[<span class="hljs-number">0</span>].weight,<span class="hljs-string">&#x27;weight_decay&#x27;</span>: wd&#125;, &#123;<br>    <span class="hljs-string">&quot;params&quot;</span>: net[<span class="hljs-number">0</span>].bias&#125;], <br>    lr=lr)<br><br>trainer.zero_grad()<br>l = loss(net(X), y)<br>l.backward()<br>    trainer.step()<br></code></pre></td></tr></table></figure><p>L1: torch.sum( torch.abs(w) )</p><h4 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h4><p>全连接上，比L2好一点</p><p>随机中间层变成0，p概率。总体期望不能变，需要除以(1-p) ;       p&#x3D;0.5  0.1  0.9</p><p><strong>自己实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dropout_layer</span>(<span class="hljs-params">X, dropout</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> &lt;= dropout &lt;= <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 在本情况中，所有元素都被丢弃。</span><br>    <span class="hljs-keyword">if</span> dropout == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> torch.zeros_like(X)<br>    <span class="hljs-comment"># 在本情况中，所有元素都被保留。</span><br>    <span class="hljs-keyword">if</span> dropout == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> X<br>    mask = (torch.Tensor(X.shape).uniform_(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &gt; dropout).<span class="hljs-built_in">float</span>()<br>    <span class="hljs-keyword">return</span> mask * X / (<span class="hljs-number">1.0</span> - dropout)<br><br>H1 = self.relu(self.lin1(X.reshape((-<span class="hljs-number">1</span>, self.num_inputs))))<br><span class="hljs-comment"># 只有在训练模型时才使用dropout，测试时直接跳过</span><br><span class="hljs-keyword">if</span> self.training == <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 在第一个全连接层之后添加一个dropout层</span><br>    H1 = dropout_layer(H1, dropout1)<br></code></pre></td></tr></table></figure><p><strong>torch</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nn.Dropout(p=<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><h4 id="数据稳定性"><a href="#数据稳定性" class="headerlink" title="数据稳定性"></a>数据稳定性</h4><p>梯度消失和梯度爆炸：sigmoid导数 ： y(1-y)      当多个相乘后就可能很小；</p><p>乘法变加法：ResNet LSTM</p><p>权重初始化、激活函数选择</p><h4 id="房价预测"><a href="#房价预测" class="headerlink" title="房价预测"></a>房价预测</h4><p>数据量较少，k折交叉验证</p><p>1.数据列标准化，并填空值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">numeric_features = all_features.dtypes[all_features.dtypes != <span class="hljs-string">&#x27;object&#x27;</span>].index<br>all_features[numeric_features] = all_features[numeric_features].apply(    <span class="hljs-keyword">lambda</span> x: (x - x.mean()) / (x.std()))<br><span class="hljs-comment"># 在标准化数据之后，所有数据都意味着消失，因此我们可以将缺失值设置为0</span><br>all_features[numeric_features] = all_features[numeric_features].fillna(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>2.非数据onehot，NAN也算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">all_features = pd.get_dummies(all_features, dummy_na=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>3.损失函数mse、评价指标如下、迭代器adam(学习率不敏感)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335078.png" alt="image-20210809134630261"></p><p>对于少量数据k验证，使用多层感知机后发现过拟合了</p><h3 id="房价预测-1"><a href="#房价预测-1" class="headerlink" title="房价预测"></a>房价预测</h3><p>数组大：对大数值log</p><p>文本特征：onehot是不行的，需要将文本求特征</p><p>训练数据前6月，公榜后3个月，私榜再后3个月</p><p>只取数字-&gt;取文本unique较少的部分</p><p>3层线性加L2，lr0.02，损失函数越来越多<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335079.png" alt="image-20210809191439398" style="zoom:50%;" /></p><p>4层线性，lr&#x3D;0.05,测试集误差在0.3左右<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335080.png" alt="image-20210809191904988" style="zoom:50%;" /></p><p>lr&#x3D;0.02 L2&#x3D;0.001<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335081.png" alt="image-20210809192441435" style="zoom:50%;" />L2&#x3D;0<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335082.png" alt="image-20210809192626754" style="zoom:50%;" /></p><p>5层 lr&#x3D;0.02<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335083.png" alt="image-20210809192835180" style="zoom: 33%;" />batchsize128<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335084.png" alt="image-20210809193317967" style="zoom:50%;" /></p><p>4层 0.05, 0, 128<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335085.png" alt="image-20210809193927803" style="zoom:50%;" /></p><h3 id="卷积网络"><a href="#卷积网络" class="headerlink" title="卷积网络"></a>卷积网络</h3><h4 id="卷积核"><a href="#卷积核" class="headerlink" title="卷积核"></a>卷积核</h4><p>二维全连接加限制</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335086.png" alt="image-20210810114817749" style="zoom:67%;" /><p>平移不变性：卷积核不依赖于位置<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335087.png" alt="image-20210810111608989" style="zoom:50%;" /></p><p>局部性：只由周围一定范围影响，限制ab范围</p><p><strong>二维互相关运算：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">corr2d</span>(<span class="hljs-params">X, K</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;计算二维互相关运算。&quot;&quot;&quot;</span><br>    h, w = K.shape<br>    Y = torch.zeros((X.shape[<span class="hljs-number">0</span>] - h + <span class="hljs-number">1</span>, X.shape[<span class="hljs-number">1</span>] - w + <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Y.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Y.shape[<span class="hljs-number">1</span>]):<br>            Y[i, j] = (X[i:i + h, j:j + w] * K).<span class="hljs-built_in">sum</span>()<br>    <span class="hljs-keyword">return</span> Y<br></code></pre></td></tr></table></figure><p><strong>卷积层</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Conv2D</span>(nn.Module):    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, kernel_size,bias=<span class="hljs-literal">False</span></span>):        <br>        <span class="hljs-built_in">super</span>().__init__()        <br>        self.weight = nn.Parameter(torch.rand(kernel_size))        <br>        self.bias = nn.Parameter(torch.zeros(<span class="hljs-number">1</span>))        <br>        self.is_bias = bias    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):        <br>        <span class="hljs-keyword">if</span> self.is_bias:            <br>            <span class="hljs-keyword">return</span> corr2d(x, self.weight) + self.bias        <br>        <span class="hljs-keyword">else</span>:            <br>            <span class="hljs-keyword">return</span> corr2d(x, self.weight)<br></code></pre></td></tr></table></figure><p><strong>实验：</strong>训练一个边缘卷积核，包括使用自己的卷积层</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335088.png" alt="image-20210810131342542"></p><p>一般2p &#x3D; k - 1，在这种情况下且原来大小w能被s整除，w &#x3D; w&#x2F;s ,  s影响计算量</p><p><strong>多输入通道</strong>：ci每一个输入通道一个核，求和后得到一个输出  ( ci * h * w) * ( ci * h * w)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">corr2d_multi_in</span>(<span class="hljs-params">X, K</span>):<br>    <span class="hljs-comment"># 先遍历 “X” 和 “K” 的第0个维度（通道维度），再把它们加在一起</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(d2l.corr2d(x, k) <span class="hljs-keyword">for</span> x, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(X, K))<br></code></pre></td></tr></table></figure><p><strong>多输出通道</strong>：c0每个输出多次求多输入通道     ( ci * h * w)    *  ( c0 * ci * h * w)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">corr2d_multi_in_out</span>(<span class="hljs-params">X, K</span>):<br>    <span class="hljs-comment"># 迭代“K”的第0个维度，每次都对输入“X”执行互相关运算。</span><br>    <span class="hljs-comment"># 最后将所有结果都叠加在一起</span><br>    <span class="hljs-keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> K], <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335089.png" alt="image-20210810134504645"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335090.png" alt="image-20210810134730194" style="zoom:50%;" /><p>参数量：C * C * H * W</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>使用经典网络还是自己设计：使用经典，微调         resnet</p><p>3 * 3可以提取空间信息； 1 * 1可以做通道融合   ，二者结合当卷积可以节约计算量</p><p>1d卷积可以处理文本</p><p>3d卷积处理视频或深度图片</p><h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><p>对于每一个输出通道进行，最大、平均。通常步长等于核大小</p><p><strong>减小运算量、增大感受野、非极大抑制</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="hljs-built_in">max</span>()<br></code></pre></td></tr></table></figure><p>池化现在用的越来越少，卷积中可以加stride。数据加了增强，不需要池化来消除便宜</p><p>缩小两倍，尺寸不变：nn.MaxPool2d(kernel_size&#x3D;2,stride&#x3D;2)   vgg</p><p>​nn.MaxPool2d(kernel_size&#x3D;3, stride&#x3D;2, padding&#x3D;1)         googlenet</p><h3 id="经典网络"><a href="#经典网络" class="headerlink" title="经典网络"></a>经典网络</h3><p>机器学习：<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335091.png" alt="image-20210810155949246" style="zoom:50%;" /></p><p>关键是特征提取，然后SVM等</p><h4 id="0-LeNet"><a href="#0-LeNet" class="headerlink" title="0.LeNet"></a>0.LeNet</h4><p>和MLP比起来，模型量小了，overfitting小了</p><p>​conv -&gt; subsampling-&gt;conv-&gt;subsampling-&gt;FC-&gt;FC-&gt;FC     2conv+3FC</p><p>lr 0.9-&gt;0.5  sigmoid-&gt;ReLU     acc上升0.876</p><h4 id="1-AlexNet"><a href="#1-AlexNet" class="headerlink" title="1.AlexNet"></a>1.AlexNet</h4><p><strong>dropout   ReLU  MaxPooling   数据增强</strong></p><p>10倍参数，250倍计算量LeNet</p><p>​5个conv + 3个FCN（Dropout）</p><p>acc 0.883</p><h4 id="2-VGG"><a href="#2-VGG" class="headerlink" title="2.VGG"></a>2.VGG</h4><p>vgg块：多个3*3卷积 + 池化            每次宽高减半，通道加倍</p><p>最后同样3个FCN（Dropout）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">conv_arch11 = ((<span class="hljs-number">1</span>, <span class="hljs-number">64</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">512</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">512</span>))<br>conv_arch16 = ((<span class="hljs-number">2</span>, <span class="hljs-number">64</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">512</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">512</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">vgg_block</span>(<span class="hljs-params">num_convs, in_channels, out_channels</span>):<br>    layers = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_convs):<br>        layers.append(nn.Conv2d(in_channels, out_channels,<br>                                kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>))<br>        layers.append(nn.ReLU())<br>        in_channels = out_channels<br>    layers.append(nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br></code></pre></td></tr></table></figure><p>这里降低vgg11通道数进行训练，batchsize&#x3D;16，训练了1h，过拟合明显</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">train</span> acc <span class="hljs-number">0</span>.<span class="hljs-number">964</span>, test acc <span class="hljs-number">0</span>.<span class="hljs-number">928</span><br></code></pre></td></tr></table></figure><h4 id="3-NIN"><a href="#3-NIN" class="headerlink" title="3.NIN"></a>3.NIN</h4><p>第一个FC的参数量太大了，很容易<strong>过拟合</strong>。NIN完全<strong>放弃全连接</strong></p><p>NIN块：卷积+2个1*1卷积，然后加maxpool。</p><p>最后留10通道<strong>每个通道</strong>全局最大池化<strong>nn.AdaptiveAvgPool2d(1)</strong>, 全局池化也可以用来中间降低复杂度，但收敛更慢</p><h4 id="4-GoogleNet"><a href="#4-GoogleNet" class="headerlink" title="4.GoogleNet"></a>4.GoogleNet</h4><p>inception输入输出大小不变,步长都是1。block：多个Inception后加一个maxpool</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335092.png" alt="image-20210810200812388" style="zoom: 50%;" /><p>大量使用1 * 1 ，最后1024通道GlobalAvgPool后传入FC。并行通道提升网络复杂度</p><p>前两大段卷积提取，降低8倍大小。</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335093.png" alt="image-20210810202558830" style="zoom:50%;" /><p>v2使用batch normalization</p><p>v3修改inception，使用3*3级联代替5 *5，和使用1 * 3、3 * 1卷积</p><p>v4使用残差</p><h4 id="5-归一化"><a href="#5-归一化" class="headerlink" title="5.归一化"></a>5.归一化</h4><p>通过一个batch中的均值和方差来提高<strong>数值稳定性</strong>。固定小批量中的均值和方差，加速收敛速度但不改变准确率。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335094.png" alt="image-20210811130833324"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335095.png" alt="image-20210811135140140" style="zoom:67%;" /><p>全连接对batch求     mean &#x3D; X.mean(dim&#x3D;0)         预测时就只有一个，所以用全局的</p><p>卷积层对某一通道所有元素所有batch求   mean &#x3D; X.mean(dim&#x3D;(0, 2, 3), keepdim&#x3D;True)</p><p>u σ在<strong>推理</strong>时使用<strong>全局</strong>的，在训练中不断动量更新。<strong>训练</strong>时为当前数据的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 训练模式下，用当前的均值和方差做标准化</span><br><span class="hljs-attr">X_hat</span> = (X - mean) / torch.sqrt(var + eps)<br><span class="hljs-comment"># 更新移动平均的均值和方差</span><br><span class="hljs-attr">moving_mean</span> = momentum * moving_mean + (<span class="hljs-number">1.0</span> - momentum) * mean<br><span class="hljs-attr">moving_var</span> = momentum * moving_var + (<span class="hljs-number">1.0</span> - momentum) * var<br></code></pre></td></tr></table></figure><p>γ β是归一化层参数，不断训练</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">Y = <span class="hljs-built_in">gamma</span> * X_hat + <span class="hljs-built_in">beta</span>  <span class="hljs-meta"># 缩放和移位</span><br><span class="hljs-keyword">return</span> Y<br></code></pre></td></tr></table></figure><p>参数：输入维度、全连接还是卷积</p><p>原论文：<strong>梯度爆炸和梯度消失在引入bn层之后基本解决</strong></p><p>用在LeNet上 原来50epoch现在只需要10epoch来达到0.875</p><h4 id="6-RestNet"><a href="#6-RestNet" class="headerlink" title="6.RestNet"></a>6.RestNet</h4><p><strong>函数角度：</strong>不断加大模型的复杂度，并且包括原来的内容</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335096.png" alt="image-20210811140847581" style="zoom: 67%;" /><p><strong>梯度角度：</strong>前面的w还是能更新，处了乘法边还有一条边。</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335097.png" alt="image-20210811152206875" style="zoom: 50%;" /><p>Residual块：主干2个卷积；如果加通道，分支1*1卷积改变通道和大小。有原大小 和 大小减半通道加倍两种</p><p>​卷积 归一  激活 卷积 归一  +x   激活</p><p>resnet_block：多个Residual（2个），第一个进行通道加倍大小减半，别的为普通的</p><p><strong>res18</strong>：单次卷积 + 4个block（第一个不改通道） + AdaptiveAvgPool2d FC</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335098.png" alt="image-20210811150840115"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">res18：<br>train acc <span class="hljs-number">0.996</span>, test acc <span class="hljs-number">0.918</span> 明显过拟合，但精度特别高<br><span class="hljs-number">658.9</span> examples/sec<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">res34</span>:<br><span class="hljs-attribute">train</span> acc <span class="hljs-number">0</span>.<span class="hljs-number">983</span>, test acc <span class="hljs-number">0</span>.<span class="hljs-number">903</span><br><span class="hljs-attribute">369</span>.<span class="hljs-number">8</span> examples/sec<br></code></pre></td></tr></table></figure><p> 改良版：“批量归一化、激活和卷积”结构</p><p><strong>Res50</strong>：Bottleneck：先卷积缩小通道，再用3*3卷积（stride在这一层），最后再扩大通道</p><p>in_places：输入通道数</p><p>places：中转小通道数，输出通道为expansion  * places</p><p>stride&#x3D;1：是否缩小</p><p>downsampling&#x3D;False：级联Bottleneck的第一个需要，表示通道是否变化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_layer</span>(<span class="hljs-params">self, in_places, places, block, stride</span>):<br>        layers = []<br>        <span class="hljs-comment"># 进去in_places，出来places * expansion。所以downsampling</span><br>        <span class="hljs-comment"># stride第一个layer时=1 </span><br>        layers.append(Bottleneck(in_places, places,stride, downsampling =<span class="hljs-literal">True</span>))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, block):<br>            layers.append(Bottleneck(places*self.expansion, places))<br><br>        <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br>    <br>ResNet50([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>])  ResNet101([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">23</span>, <span class="hljs-number">3</span>])  ResNet512([<span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">36</span>, <span class="hljs-number">3</span>])<br>self.layer1 = self.make_layer(in_places = <span class="hljs-number">64</span>, places= <span class="hljs-number">64</span>, block=blocks[<span class="hljs-number">0</span>], stride=<span class="hljs-number">1</span>)<br>self.layer2 = self.make_layer(in_places = <span class="hljs-number">256</span>,places=<span class="hljs-number">128</span>, block=blocks[<span class="hljs-number">1</span>], stride=<span class="hljs-number">2</span>)<br>self.layer3 = self.make_layer(in_places=<span class="hljs-number">512</span>,places=<span class="hljs-number">256</span>, block=blocks[<span class="hljs-number">2</span>], stride=<span class="hljs-number">2</span>)<br>self.layer4 = self.make_layer(in_places=<span class="hljs-number">1024</span>,places=<span class="hljs-number">512</span>, block=blocks[<span class="hljs-number">3</span>], stride=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="7-DenseNet"><a href="#7-DenseNet" class="headerlink" title="7.DenseNet"></a>7.DenseNet</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335099.png" alt="image-20210811154128250" style="zoom:67%;" /><p>DenseBlock：卷积后和卷积前进行堆叠 ，num_convs(堆叠次数), input_channels, growth_rate(每次成长通道数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_convs):<br>        layer.append(conv_block(<br>            num_channels * i + input_channels, num_channels))<br>    self.net = nn.Sequential(*layer)<br><span class="hljs-keyword">for</span> blk <span class="hljs-keyword">in</span> self.net:<br>    Y = blk(X)<br>    <span class="hljs-comment"># 连接通道维度上每个块的输入和输出</span><br>    X = torch.cat((X, Y), dim=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="kaggle"><a href="#kaggle" class="headerlink" title="kaggle"></a>kaggle</h4><p><a href="https://www.kaggle.com/competitions/classify-leaves">https://www.kaggle.com/competitions/classify-leaves</a></p><p><a href="https://www.kaggle.com/sheepwang/leaf-classification-eda-model">https://www.kaggle.com/sheepwang/leaf-classification-eda-model</a></p><p>类型处理：转为集合再转列表再排序，最后放入字典中class2idx</p><p>timm模型库</p><p><strong>模型融合：</strong>softmax融合或者3模型投票</p><p><strong>tta</strong>：自动将测试图片进行变换</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335100.png" alt="image-20210822223718937"></p><p><a href="https://blog.csdn.net/weixin_38208912/article/details/104976458">图像分类竞赛——Test Time Augmentation（TTA）_再困也得吃的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install ttach <span class="hljs-comment">#Test Time Augmentation</span><br>tta_model = tta.ClassificationTTAWrapper(model, tta.aliases.five_crop_transform(),  merge_mode=<span class="hljs-string">&#x27;mean&#x27;</span>)<br>y_hat = tta_model(x)<br></code></pre></td></tr></table></figure><p>lr &#x3D; 0.1 波动很大，lr太大了</p><p>resnet34预训练   lr &#x3D; 0.01  SGD<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335101.png" alt="image-20210811205844447" style="zoom: 80%;" /></p><p>resnet34无预训练  lr &#x3D; 0.01<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335102.png" alt="image-20210811212948245" style="zoom:50%;" /></p><p>自己的resnet34 lr &#x3D; 0.01<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335103.png" alt="image-20210811215448723" style="zoom:50%;" /></p><p>自己的resnet50  lr &#x3D; 0.01<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335104.png" alt="image-20210811221815881" style="zoom: 50%;" /></p><p>网络：efficientnet_pytorch , seresnext50_32x4d,  resnet50,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">!pip install timm<br>model_1 = timm.create_model(<span class="hljs-string">&#x27;seresnext50_32x4d&#x27;</span>, pretrained=<span class="hljs-literal">True</span>)<br>model_1.fc = nn.Linear(model_1.fc.in_features, <span class="hljs-number">176</span>)<br></code></pre></td></tr></table></figure><p>renet34       1e-4     64</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335105.png" alt="image-20210812015137028" style="zoom:67%;" /><h5 id="resnet50"><a href="#resnet50" class="headerlink" title="resnet50"></a>resnet50</h5><p>​b&#x3D;128（最大）  3.5mins       b&#x3D;16 6mins               b&#x3D;16 7mins 本地</p><p>​本地的5轮达到最佳0.884，云端大约0.94</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">k折 train:<span class="hljs-number">0.9831</span>  test：<span class="hljs-number">0.9082</span> 最好的有<span class="hljs-number">0.93</span>        score:<span class="hljs-number">0.92204</span><br></code></pre></td></tr></table></figure><h5 id="efficientb5"><a href="#efficientb5" class="headerlink" title="efficientb5"></a>efficientb5</h5><p>​             b&#x3D;32          epo&#x3D;5:     </p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335106.png" alt="image-20210812112126130" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">k折  train:<span class="hljs-number">0.9727</span>  test:<span class="hljs-number">0.9418</span>   Score: <span class="hljs-number">0.93613</span><br></code></pre></td></tr></table></figure><p>数据增广+ 标准化  + cos （主要效果）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train acc:<span class="hljs-number">0.9988</span>, test acc:<span class="hljs-number">0.9548</span>            score：<span class="hljs-number">0.96386</span><br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335107.png" alt="image-20210813231542618" style="zoom: 67%;" /><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">工业实际与打比赛的要求确实不一样，工业更多专注数据质量（数据每天都在变化），打比赛是调模型（因为是死数据），工业是<span class="hljs-number">85</span><span class="hljs-meta">%</span>精度可以部署测试，然后不断增强数据质量，不断喂大量数据，基本<span class="hljs-number">3</span>个月-半年后，模型基本可以达到<span class="hljs-number">95</span><span class="hljs-meta">%</span>以上是没问题的，然后部署生产环境，闭环落地！<br>工业界<span class="hljs-number">80</span><span class="hljs-meta">%</span>时间在和数据打交道<br></code></pre></td></tr></table></figure><h4 id="多GPU"><a href="#多GPU" class="headerlink" title="多GPU"></a>多GPU</h4><p>GPU batchsize越大，越能发挥性能。但需要的epoch更多</p><p>数据并行性：batchsize分到不同gpu上，最后梯度一起求和求平均</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335108.png" alt="image-20210813133655919" style="zoom: 67%;" /><p>模型并行性：一个模型太大了放不下</p><h5 id="all-reduce"><a href="#all-reduce" class="headerlink" title="all_reduce"></a>all_reduce</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将梯度信息累加起来</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">allreduce</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):<br>        data[<span class="hljs-number">0</span>][:] += data[i].to(data[<span class="hljs-number">0</span>].device)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):<br>        data[i] = data[<span class="hljs-number">0</span>].to(data[i].device)<br></code></pre></td></tr></table></figure><p>训练：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_batch</span>(<span class="hljs-params">X, y, device_params, devices, lr</span>):<br>    X_shards, y_shards = split_batch(X, y, devices)<br>    <span class="hljs-comment"># 在每个GPU上分别计算损失</span><br>    ls = [loss(lenet(X_shard, device_W), y_shard).<span class="hljs-built_in">sum</span>()<br>          <span class="hljs-keyword">for</span> X_shard, y_shard, device_W <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>              X_shards, y_shards, device_params)]<br>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> ls:  <span class="hljs-comment"># 反向传播在每个GPU上分别执行</span><br>        l.backward()<br>    <span class="hljs-comment"># 将每个GPU的所有梯度相加，并将其广播到所有GPU</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(device_params[<span class="hljs-number">0</span>])):<br>            allreduce([device_params[c][i].grad <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(devices))])<br>    <span class="hljs-comment"># 在每个GPU上分别更新模型参数</span><br>    <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> device_params:<br>        d2l.sgd(param, lr, X.shape[<span class="hljs-number">0</span>]) <span class="hljs-comment"># 在这里，我们使用全尺寸的小批量</span><br></code></pre></td></tr></table></figure><p>简洁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net = nn.DataParallel(net, device_ids=devices)<br>X, y = X.to(devices[<span class="hljs-number">0</span>]), y.to(devices[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h4 id="分布式训练"><a href="#分布式训练" class="headerlink" title="分布式训练"></a>分布式训练</h4><p>需要网络通信：先本地all_reduce，网络通信再all_reduce</p><p>t  &#x3D;  max( 计算时间， 通信时间 )。但增加batchsize需要更多epoch</p><p>读取速度也可能慢：多进程</p><h3 id="视觉"><a href="#视觉" class="headerlink" title="视觉"></a>视觉</h3><h4 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">需要PIL.Image.<span class="hljs-built_in">open</span>()读入RGB图像<br><br>transform = transforms.Compose([<br>    <span class="hljs-comment">#transforms.Resize(256),      短边到256，长边跟着变</span><br>    <span class="hljs-comment">#transforms.CenterCrop(224),  取出正方形</span><br>    transforms.Resize(<span class="hljs-number">224</span>),<br>    transforms.CenterCrop(<span class="hljs-number">224</span>),  <span class="hljs-comment"># 取出正方形</span><br>    transforms.RandomHorizontalFlip(p=<span class="hljs-number">0.5</span>),   <span class="hljs-comment">#随机水平翻转</span><br>    transforms.RandomVerticalFlip(p=<span class="hljs-number">0.5</span>),     <span class="hljs-comment">#除了水平竖直反转之外其他的处理方法貌似都会降低acc</span><br>    <span class="hljs-comment">#transforms.RandomResizedCrop((224, 224), scale=(0.7, 1),ratio(0.75,1.25)),  随机裁剪为不同的大小scale和宽高比ratio，然后缩放所裁剪得到的图像为制定的大小</span><br>    <span class="hljs-comment">#transforms.RandomCrop((60, 120)), # 随机剪裁</span><br>    <span class="hljs-comment"># transforms.ColorJitter(0.3, 0.3, 0.2), # 修改亮度、对比度和饱和度</span><br>    <span class="hljs-comment">#transforms.RandomRotation(180), # 依degrees 随机旋转一定角度   10</span><br>    transforms.ToTensor(),<br>    transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>])<br><br>test_augs = torchvision.transforms.Compose([<br>    torchvision.transforms.Resize(<span class="hljs-number">256</span>),<br>    torchvision.transforms.CenterCrop(<span class="hljs-number">224</span>),<br>    torchvision.transforms.ToTensor(),<br>    transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>])<br></code></pre></td></tr></table></figure><h4 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h4><p>神经网络前面卷积网络是<strong>特征提取</strong>，利用已经训练好的网络来训练我们的数据。</p><p>底层的信息为更好的特征，可以固定住</p><p>微调前面的参数，重点fc参数  ，learning_rate &#x3D; 5e-5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_trainer</span>(<span class="hljs-params">net, learning_rate, param_group = <span class="hljs-literal">True</span></span>)<br><span class="hljs-keyword">if</span> param_group:<br>        params_1x = [param <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> net.named_parameters()<br>             <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;fc.weight&quot;</span>, <span class="hljs-string">&quot;fc.bias&quot;</span>]]<br>        <br>        trainer = torch.optim.SGD([&#123;<span class="hljs-string">&#x27;params&#x27;</span>: params_1x&#125;,<br>                                   &#123;<span class="hljs-string">&#x27;params&#x27;</span>: net.fc.parameters(),<br>                                    <span class="hljs-string">&#x27;lr&#x27;</span>: learning_rate * <span class="hljs-number">10</span>&#125;],<br>                                lr=learning_rate, weight_decay=<span class="hljs-number">0.001</span>)<br>    <span class="hljs-keyword">else</span>:<br>        trainer = torch.optim.SGD(net.parameters(), lr=learning_rate,<br>                                  weight_decay=<span class="hljs-number">0.001</span>)<br>    <span class="hljs-keyword">return</span> trainer<br></code></pre></td></tr></table></figure><h4 id="detect"><a href="#detect" class="headerlink" title="detect"></a>detect</h4><p>COCO数据集：80类，330k张，1.5M个物体</p><p><strong>画框</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment">#@save</span><br>dog_bbox = [<span class="hljs-number">60.0</span>, <span class="hljs-number">45.0</span>, <span class="hljs-number">90.0</span>, <span class="hljs-number">100.0</span>]<br><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment">#@save  # 将边界框 (左上x, 左上y, 右下x, 右下y) 格式转换成 matplotlib 格式：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bbox_to_rect</span>(<span class="hljs-params">bbox, color</span>):<br>    <span class="hljs-comment"># ((左上x, 左上y), 宽, 高)</span><br>    <span class="hljs-keyword">return</span> plt.Rectangle(<br>        xy=(bbox[<span class="hljs-number">0</span>], bbox[<span class="hljs-number">1</span>]), width=bbox[<span class="hljs-number">2</span>]-bbox[<span class="hljs-number">0</span>], height=bbox[<span class="hljs-number">3</span>]-bbox[<span class="hljs-number">1</span>],<br>        fill=<span class="hljs-literal">False</span>, edgecolor=color, linewidth=<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 显示一个边框</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_bbox</span>(<span class="hljs-params">ax, img, box</span>):<br>    ax.imshow(img)<span class="hljs-comment"># 图片</span><br>    ax.axes.add_patch(bbox_to_rect(box, <span class="hljs-string">&#x27;blue&#x27;</span>))<span class="hljs-comment"># 框</span><br><br>img = plt.imread(<span class="hljs-string">&#x27;../img/catdog.jpg&#x27;</span>)<br>fig = plt.figure() <span class="hljs-comment"># 画布</span><br>ax1 = fig.add_subplot(<span class="hljs-number">111</span>) <span class="hljs-comment"># 画1行1列个图形的第1个</span><br>show_bbox(ax1, img, dog_bbox)<br></code></pre></td></tr></table></figure><p>香蕉：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">    最多物体数量   标号，框<br>(torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[32, 3, 256, 256]</span>), torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[32, 1,           5]</span>))<br></code></pre></td></tr></table></figure><p>13 * 13 * 3*（20+1+4）<br>    3个框 20个种类  1是否有物体  4调整框</p><p>IoU：交集比上并集</p><p>锚框和边缘框对应</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335109.png" alt="image-20210814193726246" style="zoom:50%;" /><p>生成锚框</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># (1, 3, h, w) [0.75, 0.5, 0.25], [1, 2, 0.5]      s√r  和 s /√r  每像素点</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multibox_prior</span>(<span class="hljs-params">data, sizes, ratios</span>):<br>    <span class="hljs-keyword">return</span> [x,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(x,<span class="hljs-number">4</span>)  (y,<span class="hljs-number">4</span>)   返回(x, y) IoU 矩阵<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">box_iou</span>(<span class="hljs-params">boxes1, boxes2</span>):<br></code></pre></td></tr></table></figure><p>将anchors根据iou分配到真实框上，小于阈值分配-1。注意分配顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save 一个数组a[i]=j 对于每个锚框i，分配的真实边界框j,分配阈值iou_threshold</span><br>(x,<span class="hljs-number">4</span>)  (y,<span class="hljs-number">4</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">assign_anchor_to_bbox</span>(<span class="hljs-params">ground_truth, anchors, device, iou_threshold=<span class="hljs-number">0.5</span></span>):<br></code></pre></td></tr></table></figure><p>两组对应框之间的偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save  (x,4)  (x,4)   -&gt;  (x, 4)  中心、wh的偏移</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">offset_boxes</span>(<span class="hljs-params">anchors, assigned_bb, eps=<span class="hljs-number">1e-6</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;对锚框偏移量的转换。&quot;&quot;&quot;</span><br>    c_anc = box_corner_to_center(anchors)<br>    c_assigned_bb = box_corner_to_center(assigned_bb)<br>    offset_xy = <span class="hljs-number">10</span> * (c_assigned_bb[:, :<span class="hljs-number">2</span>] - c_anc[:, :<span class="hljs-number">2</span>]) / c_anc[:, <span class="hljs-number">2</span>:]<br>    offset_wh = <span class="hljs-number">5</span> * torch.log(eps + c_assigned_bb[:, <span class="hljs-number">2</span>:] / c_anc[:, <span class="hljs-number">2</span>:])<br>    offset = torch.cat([offset_xy, offset_wh], axis=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> offset<br></code></pre></td></tr></table></figure><p>将网络中锚框与真实框对应，求出偏移值、mask和 真实类别+1（0为背景，iou小于阈值）</p><p>​一个真实框可以有多个anchor</p><p>​未分配的则是assign_anchor_to_bbox阈值不达标的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-comment"># (b, num_anchors, 4)        (b, num_labels, 5)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multibox_target</span>(<span class="hljs-params">anchors, labels</span>):<br>    <span class="hljs-keyword">return</span> 偏移，mask，类别<br>(b,num_anchors*<span class="hljs-number">4</span>)   (b,num_anchors*<span class="hljs-number">4</span>)    (n,num_anchors)<br>其中负类（小于阈值的anchor）的偏移被mask消除了<br></code></pre></td></tr></table></figure><p>nms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-comment"># 传入(nums,4) (nums) 返回留下的预测框下标数组  [x]</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">nms</span>(<span class="hljs-params">boxes, scores, iou_threshold</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;对预测边界框的置信度进行排序。&quot;&quot;&quot;</span><br>    B = torch.argsort(scores, dim=-<span class="hljs-number">1</span>, descending=<span class="hljs-literal">True</span>)<br>    keep = []  <span class="hljs-comment"># 保留预测边界框的指标</span><br>    <span class="hljs-keyword">while</span> B.numel() &gt; <span class="hljs-number">0</span>:<br>        i = B[<span class="hljs-number">0</span>]<br>        keep.append(i)<br>        <span class="hljs-keyword">if</span> B.numel() == <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span><br>        iou = box_iou(boxes[i, :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>),<br>                      boxes[B[<span class="hljs-number">1</span>:], :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)).reshape(-<span class="hljs-number">1</span>)<br>        inds = torch.nonzero(iou &lt;= iou_threshold).reshape(-<span class="hljs-number">1</span>)<br>        B = B[inds + <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> torch.tensor(keep, device=boxes.device)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#                     (b,classes+1,n)  (b,n*4)   (b,n,4)     (NMS阈值)    (背景阈值)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multibox_detection</span>(<span class="hljs-params">cls_probs, offset_preds, anchors, nms_threshold=<span class="hljs-number">0.5</span>,</span><br><span class="hljs-params">                       pos_threshold=<span class="hljs-number">0.009999999</span></span>):<br>    这里将背景的conf设为<span class="hljs-number">1</span>-conf，类别设为-<span class="hljs-number">1</span><br>    返回 (b, outn, classes+conf+4pos)<br></code></pre></td></tr></table></figure><h4 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h4><p>RCNN&#x2F;  FastR-CNN&#x2F;  FasterR-CNN   精度高速度慢。</p><p>SSD</p><p>YOLO</p><p>CenterNet</p><p>高精度图片中小物体的分类。卫星图片。需要特殊处理，有一套成熟方法</p><h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><p>per &#x3D; len(sizes) + len(ratios) - 1  每个像素点的anchor个数</p><p>每一次blk后，生成num_an (h * w * per)个锚框，同时输入到卷积网络每个像素点输出per*(classes+1)个类别预测和per * 4位置预测。所以每个blk有1个主网络blk，2个分支pred。低层框比较小 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">blk_forward</span>(<span class="hljs-params">X, blk, size, ratio, cls_predictor, bbox_predictor</span>):<br>    Y = blk(X)<br>    anchors = d2l.multibox_prior(Y, sizes=size, ratios=ratio) <span class="hljs-comment"># 生成anchors框 不同层不一样</span><br>    cls_preds = cls_predictor(Y)   <span class="hljs-comment"># 框的类别预测</span><br>    bbox_preds = bbox_predictor(Y) <span class="hljs-comment"># 框的位置偏移</span><br>    <span class="hljs-keyword">return</span> (Y, anchors, cls_preds, bbox_preds)<br></code></pre></td></tr></table></figure><p>(Y,   anchors,                 cls_preds,                                        bbox_preds) </p><p>Y，[1, num_anchors,  4],   [b,  per* (classes+1),  h,  w],    [b,  per * 4,  h,  w]</p><p><strong>总体网络</strong>：由于不同维度h，w不一样，所以将后面的打平堆叠，打平前permute(0, 2, 3, 1)  将c放到最后一维度。将blk返回值堆叠；类别还需要reshape出c+1用来预测；anchors 直接在dim&#x3D;1cat，返回</p><p><strong>anchors</strong>  [1, num_an, 4],   <strong>cls_preds</strong>  [b, num_an, classes+1],    <strong>bbox_preds</strong>  [b, num_an*4]</p><p>(32^2^+16^2^+8^2^4^2^+1^2^)×4&#x3D;5444   ，4是per，底数是特征图宽</p><p>得到全部anchors后与预测Y对应 **multibox_target(anchors, Y)**，返回 bbox_offset, bbox_mask, class_labels。代表着真实的标签</p><p>（这里anchors每张图<strong>都一样</strong>，但留下来算loss的需要满足和label大于阈值） Y：[b, 5]</p><p>bbox_offset与bbox_preds  计算L1损失函数     需要mask去除背景的偏移损失</p><p>class_labels与cls_preds       计算分类损失</p><h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><p>类别损失：交叉熵 由于有多个框，直接reshape到batch维度上。最后dim&#x3D;1取mean求出每张图平均损失值 [b]</p><p>偏移损失：L1loss。乘上mask后传入，最后取mean</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">cls_loss = nn.CrossEntropyLoss(reduction=<span class="hljs-string">&#x27;none&#x27;</span>)<br>bbox_loss = nn.L1Loss(reduction=<span class="hljs-string">&#x27;none&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_loss</span>(<span class="hljs-params">cls_preds, cls_labels, bbox_preds, bbox_labels, bbox_masks</span>):<br>    batch_size, num_classes = cls_preds.shape[<span class="hljs-number">0</span>], cls_preds.shape[<span class="hljs-number">2</span>]<br>    cls = cls_loss(cls_preds.reshape(-<span class="hljs-number">1</span>, num_classes),<br>                   cls_labels.reshape(-<span class="hljs-number">1</span>)).reshape(batch_size, -<span class="hljs-number">1</span>).mean(dim=<span class="hljs-number">1</span>)<br>    bbox = bbox_loss(bbox_preds * bbox_masks,<br>                     bbox_labels * bbox_masks).mean(dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> cls + bbox<br></code></pre></td></tr></table></figure><h5 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">X</span>):<br>    net.<span class="hljs-built_in">eval</span>()<br>    anchors, cls_preds, bbox_preds = net(X.to(device))<br>    cls_probs = F.softmax(cls_preds, dim=<span class="hljs-number">2</span>).permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)        <span class="hljs-comment"># 计算出概率 移到dim=1</span><br>    <span class="hljs-comment"># 把框加上偏移，非极大抑制，背景抑制后返回[b,x,classes+conf+4pos]</span><br>    output = d2l.multibox_detection(cls_probs, bbox_preds, anchors)<br>    <span class="hljs-comment"># 只留下框</span><br>    idx = [i <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(output[<span class="hljs-number">0</span>]) <span class="hljs-keyword">if</span> row[<span class="hljs-number">0</span>] != -<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> output[<span class="hljs-number">0</span>, idx]<br><span class="hljs-number">5444</span>  -nms&gt;   <span class="hljs-number">449</span>  -背景抑制&gt;  <span class="hljs-number">51</span>   -输出再次抑制&gt;    <span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure><h5 id="改进："><a href="#改进：" class="headerlink" title="改进："></a><strong>改进：</strong></h5><p>平滑l1：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335110.png" alt="image-20210816153354419"></p><p>focal 损失函数：重点在正样本但预测概率小的损失</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335111.png" alt="image-20210816153128924"></p><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>​特别长的物体：设置<strong>ratio</strong></p><p>​怕L2loss特别大，超出范围</p><p>​多个<strong>loss</strong>相加，需要<strong>加权重</strong>使得loss数量级差不多</p><p>​NMS的计算量特别大，需要特殊技巧</p><p>​backbone还是预训练的图片分类模型</p><p>​树莓派上跑detect用yolo</p><p>​没有固定现状的物体检测（土壤）：语义分割</p><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><p>数据集VOC2012        自动驾驶车辆和医疗图像诊断</p><p>color2label数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">voc_colormap2label</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;构建从RGB到VOC类别索引的映射。&quot;&quot;&quot;</span><br>    colormap2label = torch.zeros(<span class="hljs-number">256</span> ** <span class="hljs-number">3</span>, dtype=torch.long)<br>    <span class="hljs-keyword">for</span> i, colormap <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(VOC_COLORMAP):<br>        colormap2label[<br>            (colormap[<span class="hljs-number">0</span>] * <span class="hljs-number">256</span> + colormap[<span class="hljs-number">1</span>]) * <span class="hljs-number">256</span> + colormap[<span class="hljs-number">2</span>]] = i<br>    <span class="hljs-keyword">return</span> colormap2label<br><br><span class="hljs-comment">#@save  传入的是tensor 0~255 (c, h, w)   传出id</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">voc_label_indices</span>(<span class="hljs-params">colormap, colormap2label</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;将VOC标签中的RGB值映射到它们的类别索引。&quot;&quot;&quot;</span><br>    colormap = colormap.permute(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>).numpy().astype(<span class="hljs-string">&#x27;int32&#x27;</span>)<br>    idx = ((colormap[:, :, <span class="hljs-number">0</span>] * <span class="hljs-number">256</span> + colormap[:, :, <span class="hljs-number">1</span>]) * <span class="hljs-number">256</span><br>           + colormap[:, :, <span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> colormap2label[idx]<br></code></pre></td></tr></table></figure><p>随机剪裁： feature和label放到一起进行，(c,h,w)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">voc_rand_crop</span>(<span class="hljs-params">feature, label, height, width</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;随机裁剪特征和标签图像。&quot;&quot;&quot;</span><br>    rect = torchvision.transforms.RandomCrop.get_params(<br>        feature, (height, width))<br>    feature = torchvision.transforms.functional.crop(feature, *rect)<br>    label = torchvision.transforms.functional.crop(label, *rect)<br>    <span class="hljs-keyword">return</span> feature, label<br></code></pre></td></tr></table></figure><p>过滤：滤去小于剪裁大小的图片，在dataset init时就需要去除样本id数组</p><p>人的语义分割比较容易，但是光线影响很大。应该比较成熟了 </p><p>在3d语义分割的情况下，存在深度图，理论上分割更容易</p><p>自动驾驶：距离       速度、加速度      十几二十个摄像头 模型融合。特斯拉纯视觉， google、国内激光雷达</p><h4 id="FCN"><a href="#FCN" class="headerlink" title="FCN"></a>FCN</h4><p>转置卷积实现尺寸变大，也有最近邻插值，双线性插值（初始化核）</p><p><strong>卷积</strong>：一群值转化为一个值的关系</p><p><a href="https://blog.csdn.net/lanadeus/article/details/82534425">轻松理解转置卷积(transposed convolution)或反卷积(deconvolution)_lanadeus-CSDN博客_转置卷积</a></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335112.png" alt="image-20210816214009010"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335113.png" alt="image-20210816213950481" style="zoom:67%;" /><p><strong>转置卷积：</strong>原来一个值转化为一群值的对应关系，值上与原来无关（<strong>从信息论的角度看,卷积是不可逆的.所以这里说的并不是从output矩阵和kernel矩阵计算出原始的input矩阵.而是计算出一个保持了位置性关系的矩阵.</strong>)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335114.png" alt="image-20210816215400555"></p><p>超参数相同时，形状为逆变换</p><p>理解：填充k-p-1后， stride为将原矩阵在行列之间插s-1零行，再做传统卷积</p><p>转置卷积的等价乘法矩阵 &#x3D; 卷积核的乘法矩阵.T</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">d2l.corr2d(X, K) == torch.matmul(W, X.reshape(-<span class="hljs-number">1</span>)).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>trans_conv(Y, K) == torch.matmul(W.T, Y.reshape(-<span class="hljs-number">1</span>)).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>计算方法：1.相乘相加  2.倒转 扩充 正常卷积</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335116.png" alt="image-20210817141016427" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335117.png" alt="image-20210817140913096" style="zoom: 50%;" /></p><p>FCN转置卷积： k-2p-s&#x3D;0  双线性插值初始化</p><p>损失函数：直接cross_entropy ,分类维度在x的第二维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.rand((<span class="hljs-number">32</span>, <span class="hljs-number">21</span>, <span class="hljs-number">320</span>,<span class="hljs-number">480</span>))<br>y = torch.ones((<span class="hljs-number">32</span>, <span class="hljs-number">320</span>, <span class="hljs-number">480</span>)).long()<br>F.cross_entropy(x, y)  <span class="hljs-comment"># nn.CrossEntropyLoss()(x, y)</span><br></code></pre></td></tr></table></figure><p>训练时，由于loss在一个batch上取平均值，比d2l小，所以要调大lr，否者会陷入<strong>局部最优</strong>，输出全黑</p><h4 id="样式迁移"><a href="#样式迁移" class="headerlink" title="样式迁移"></a>样式迁移</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335118.png" alt="image-20210817141542897" style="zoom: 80%;" /><p>网络提取特征后，某些层上的<strong>特征相似</strong>：gram矩阵       内容相似：直接对应位置MSE</p><p>内容特征深层次越好（忽略细节） [25]   风格特征多层结合[0, 5, 10, 19, 28]</p><p><strong>风格矩阵：</strong></p><p>​对角线元素提供了不同特征图（a1，a2 … ，an）各自的信息，其余元素提供了不同特征图之间的相关信息。</p><p>contents_Y,  styles_Y是提前准备好的。X为输入也是调整的对象，初始化为内容图img.weight.data.copy_(X.data)</p><p><strong>迭代：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将X输入到网络中提取特征</span><br>contents_Y_hat, styles_Y_hat = extract_features(X, content_layers, style_layers)<br><span class="hljs-comment"># 根据特征与提前准备好的特征相比较，计算出损失</span><br>contents_l, styles_l, tv_l, l = compute_loss(<br>    X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram)<br></code></pre></td></tr></table></figure><p><strong>loss：</strong>分为3部分, 内容（均方差）、风格（风格矩阵W *W.T的均方差)、平滑度损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">content_weight, style_weight, tv_weight = <span class="hljs-number">1</span>, <span class="hljs-number">1e3</span>, <span class="hljs-number">10</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_loss</span>(<span class="hljs-params">X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram</span>):<br>    <span class="hljs-comment"># 分别计算内容损失、样式损失和总变差损失</span><br>    contents_l = [content_loss(Y_hat, Y) * content_weight <span class="hljs-keyword">for</span> Y_hat, Y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>        contents_Y_hat, contents_Y)]<br>    styles_l = [style_loss(Y_hat, Y) * style_weight <span class="hljs-keyword">for</span> Y_hat, Y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>        styles_Y_hat, styles_Y_gram)]<br>    tv_l = tv_loss(X) * tv_weight<br>    <span class="hljs-comment"># 对所有损失求和</span><br>    l = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span> * styles_l + contents_l + [tv_l]) <span class="hljs-comment"># 一个长列表</span><br>    <span class="hljs-keyword">return</span> contents_l, styles_l, tv_l, l<br></code></pre></td></tr></table></figure><p>大图片迁移：用小图迁移后，放大然后作为起始</p><h3 id="牛仔行头检测"><a href="#牛仔行头检测" class="headerlink" title="牛仔行头检测"></a>牛仔行头检测</h3><p>样本不平衡</p>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
      <category>动手学深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>控制硬件软件资源</li><li>合理组织调度资源</li><li>为软件提供接口和环境</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218610.png" alt="image-20230407133023066"></p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>并发：宏观上同时运行</li><li>共享：并发进程共同享用资源 </li><li>虚拟：一个物理实体对应多个逻辑</li><li>异步：进程走走停停</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218611.png" alt="image-20230407132853257"></p><h4 id="os不同时期发展"><a href="#os不同时期发展" class="headerlink" title="os不同时期发展"></a><strong>os不同时期发展</strong></h4><p>​人工、单道、多道、分时（时间片多用户）、实时</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218612.png" alt="image-20230407132654765"></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>​用户接口；联机（cmd）、脱机（程序）、图形化</p><p>​程序接口：系统调用组成。程序调用相应功能系统调用</p><p>​大内核（模块集中）、微内核</p><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218614.png" alt="image-20230407133249113"></p><h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h2><p>作业比程序更广泛，包含程序、数据和作业说明书</p><p><strong>程序</strong>是个静态的概念，<strong>进程</strong>是程序的一次执行</p><p><strong>进程</strong>：对并发执行的程序的控制和描述，资源分配调度的基本单位，动态性、并发性、独立性、异步</p><p><strong>拥有资源</strong>（代码段 数据段  IO），<strong>唯一</strong>PCB</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218615.png" alt="image-20230407133644813"></p><p><strong>状态</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218616.png" alt="image-20210807140817329"></p><p><strong>编译</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218617.png" alt="image-20210807141320862"></p><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218618.png" alt="image-20230407133959202"></p><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218619.png" alt="image-20230407134144875"></p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>​进程：处理机资源最小单位        创建、撤销和切换代价大</p><p>​线程：处理机调度单位         轻量级进程    TCB          QQ中与不同好友聊天</p><p>​临界资源与临界区</p><h4 id="调度层次分类"><a href="#调度层次分类" class="headerlink" title="调度层次分类"></a>调度层次分类</h4><ul><li>​高级调度（作业调度）：外存到内存 并分配资源   根据JCB  (CPU、磁盘、内存等资源)</li><li>​中级调度（内存调度）：阻塞程序调入外存，提高利用率和吞吐量     </li><li>​低级调度（进程调度）：分配<strong>cpu</strong>          （抢占、非抢占）</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218620.png" alt="image-20230407134438270"></p><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218621.png" alt="image-20230407134721361"></p><h5 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h5><ul><li>​先来先服务FCFS</li><li>​短作业优先SJF</li><li>​高响应比HRRN    (等待+服务时间)&#x2F;服务时间</li><li>​优先级调度PSA</li></ul><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><ul><li>​轮转RR</li><li>​优先级（抢占、非抢占）</li><li>​多级反馈队列：高优先级时间片短，未完成则降级</li></ul><h5 id="实时"><a href="#实时" class="headerlink" title="实时"></a>实时</h5><ul><li>​最早截止EDF（抢占、非抢占）</li><li>​最低松弛度优先LLF（不得不开始时抢占）</li><li>​优先倒置（1.不让抢占临界区  2.优先度继承）</li></ul><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>只允许一个进程使用的资源，硬件实现方法</p><p>​1.关中断</p><p>​2.bool变量标识，while等待 ；    swap对换 原理一样         <strong>忙碌等待</strong></p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>​<strong>PV操作</strong></p><p>​S表示资源数目，当多个资源时，AND机制</p><p>​wait：  s–     if s &lt; 0，线程加入等待队列  </p><p>​signal：s++  if  s&lt;&#x3D;0, 唤醒等待队列</p><p>​    <strong>常见问题</strong>：生产者消费者、进餐、读写     （互斥加紧范围小）</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>​<strong>条件</strong>：互斥、请求和保持、不可抢占、循环等待</p><p>​<strong>处理方法</strong>：</p><ul><li><strong>预防死锁</strong>（一次性分配资源、允许抢占）</li><li><strong>避免死锁</strong>（银行家：在一次分配完后检查是否有安全序列能实现全部运行）</li><li><strong>监测死锁</strong>（资源分配图，分配完有没有环）</li><li><strong>解除死锁</strong>（资源剥夺、回滚进程、终止进程）</li></ul><p><strong>银行家</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218622.png" alt="image-20230407100403822"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218623.png" alt="image-20230407100418486"></p><p><strong>资源分配图</strong></p><p>去掉所有已经出边（申请了的资源），查看某个进程P是否所有的出边（need）都能满足，能满足则该进程运行，释放所有资源。最后是否能都运行。其实就是判断是否存在<strong>安全序列</strong>。否则就会产生环</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218624.png" alt="image-20230407100722191"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218625.png" style="zoom:80%;" /></p><h2 id="3-内存"><a href="#3-内存" class="headerlink" title="3.内存"></a>3.内存</h2><h4 id="内存分配（连续）"><a href="#内存分配（连续）" class="headerlink" title="内存分配（连续）"></a>内存分配（连续）</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218626.png" alt="image-20230407103230820"></p><ul><li><p><strong>单一连续分配</strong>（单程序）</p></li><li><p><strong>固定分区分配</strong>（区域固定但大小不等，一个程序一个区） 分区表维护状态  存在<strong>内部碎片</strong>  不能共享</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218627.png" alt="image-20230407101903055" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218628.png" alt="image-20230407101958427" style="zoom: 67%;" /></p></li><li><p><strong>动态分区分配</strong>（根据进程大小分配，空闲表，空闲区由一个双向指针连接起来），存在<strong>外部碎片</strong>（太小没人用）  回收直接合并前后空闲区</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218629.png" alt="image-20230407102352685"></p><p>紧凑：各个进程挪位，挪出一个连续空闲区域。把蓝色部分合并</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218630.png" alt="image-20230407103058745"></p></li></ul><h5 id="顺序方法"><a href="#顺序方法" class="headerlink" title="顺序方法"></a>顺序方法</h5><p>​首次适应FF：开头开始找到就用   循环首次适应NF：从上一次开始</p><p>​最佳适应BF：分配最小的能用的           最坏适应WF：分配最大的区域</p><h5 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h5><ul><li>​快速适应：多个按大小划分的链表（2kb，5kb..）</li><li>​伙伴系统：多个链表大小为2^i^ ，不存在该大小区域则拆分2^i+1^链表</li></ul><p>​用哈希来寻找表头指针</p><h4 id="分页管理（离散）"><a href="#分页管理（离散）" class="headerlink" title="分页管理（离散）"></a>分页管理（离散）</h4><p><strong>优点：</strong></p><ol><li>解决外部碎片</li><li>非连续分配，且不用的可以先不分配，解决程序大小受限问题</li></ol><p>​内存以页面为单位，地址&#x3D;页号+页内地址   ， 页面大小1kb~8kb</p><p>​所以程序的<strong>逻辑地址</strong>都转为<strong>分页地址</strong>。</p><p>​<strong>页表</strong>：程序中页号（逻辑地址 连续）与内存页号（物理地址 不连续）<strong>对应关系</strong>，存放在内存中。PCB中的PTR保持页表起始地址。 页表在<strong>内存管理单元</strong>（MMU）中，每个进程都有</p><p>​每次访问需要访问两次内存，引入<strong>快表</strong>（高速缓冲寄存器） ；查询时间  <strong>2t + λ - t*a</strong> </p><p>​<strong>多级列表</strong>：将页表空间离散，2^20^  &#x3D;  2^10^  * 2^10^</p><p>​4GB内存空间 每个页4kb，共2^20^条； 每一个条目需要4B 则需要2^20^ * 4 B &#x3D; 4 MB 的页表空间</p><p>​转为二级后：2^10^ * 4B  + 2^10^ * 2^10^ * 4B  &#x3D; 4KB + 4MB。但二级页表是可以不存在，所以<strong>节约</strong>并且<strong>离散化</strong>了空间</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218631.png" alt="image-20230407120032813"></p><p>​</p><h4 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h4><p>​满足编程上要求，主程序、子程序、数据段。需要段表实现虚拟到物理</p><p>​当用户共享一段内存时，只需要一个段表，而分页需要多个</p><p><strong>对比：</strong></p><p>打个比方，比如说你去听课，带了一个纸质笔记本做笔记。笔记本有100张纸，课程有语文、数学、英语三门，对于这个笔记本的使用，为了便于以后复习方便，你可以有两种选择。</p><p>第一种是，你从本子的第一张纸开始用，并且事先在本子上做划分：第2张到第30张纸记语文笔记，第31到60张纸记数学笔记，第61到100张纸记英语笔记，最后在第一张纸做个列表，记录着三门笔记各自的范围。这就是分段管理，第一张纸叫段表。</p><p>第二种是，你从第二张纸开始做笔记，各种课的笔记是连在一起的：第2张纸是数学，第3张是语文，第4张英语……最后呢，你在第一张纸做了一个目录，记录着语文笔记在第3、7、14、15张纸……，数学笔记在第2、6、8、9、11……，英语笔记在第4、5、12……。这就是分页管理，第一张纸叫页表。你要复习哪一门课，就到页表里查寻相关的纸的编号，然后翻到那一页去复习</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>​页表中的标志位标记是否在内存中</p><p>​时间、空间<strong>局部性</strong></p><p>​作业的页面可能不在内存中，需要从外存调入，产生一个缺页中断</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218632.png" alt="image-20230407104638679"></p><p>​分配规则：规定分配局部置换（单程序内换）、可变分配局部置换（一起换）、可变分配局部置换（动态加页）</p><h5 id="置换算法"><a href="#置换算法" class="headerlink" title="置换算法!"></a>置换算法!</h5><ul><li>​最佳置换算法 （理论算法、无法实现）</li><li>​先进先出</li><li>​最久未使用LRU   链表头尾</li><li>​最少使用LFU（页面访问表 +1）   </li><li>​    Clock算法  （第一次置为零不换出，第二次&#x3D;0则 换出）</li></ul><h2 id="4-文件"><a href="#4-文件" class="headerlink" title="4.文件"></a>4.文件</h2><p>文件：一系列记录</p><p>记录：一系列数据，有key</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>​顺序文件：顺序存储记录，读取N&#x2F;2</p><p>​索引文件：按键排序建立索引表，logN复杂度</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>单级目录、多级目录、树形目录</p><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>连续组织方式</p><p>链接组织方式：隐式（只存首地址，下一个盘块在当前盘块中），显式（全存到FCB中）FAT表 </p><h2 id="5-io"><a href="#5-io" class="headerlink" title="5.io"></a>5.io</h2><h4 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218633.png" alt="image-20230407131713071"></p><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218634.png"></p><h4 id="磁盘-1"><a href="#磁盘-1" class="headerlink" title="磁盘"></a>磁盘</h4><p>​盘面 磁道 扇区</p><p>寻道+旋转+传输</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218635.png" alt="image-20230407131437644"></p><h5 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h5><ul><li>先来先服务FCFS</li><li>最短寻道时间SSTF</li><li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li><li>CSCAN：单方向电梯</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218636.png" alt="image-20230407131552116"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>1.什么是操作系统？操作系统的主要功能是什么？</strong></p><p>操作系统位于计算机硬件和应用软件之间，负责协调和管理硬件资源的分配、控制和调度，提供对硬件的抽象和访问接口，以便应用程序能够运行并与硬件交互。</p><p>进程管理、内存管理、文件系统、输入输出</p><p><strong>2.请大致描述操作系统的启动过程。</strong></p><p>操作系统的启动过程包括硬件自检、引导加载程序加载、内核初始化、用户空间初始化、用户应用程序加载和运行等阶段。</p><ol><li>上电自检（Power-On Self-Test, POST）：当计算机电源被打开时，计算机硬件会进行自我检测，包括检测内存、CPU、硬盘、显示器等硬件设备，以确保它们正常工作。</li><li>BIOS&#x2F;UEFI初始化：计算机硬件自检完成后，BIOS（基本输入&#x2F;输出系统）或UEFI（统一可扩展固件接口）会被加载并初始化，它们是计算机的固件，负责初始化硬件设备、设置启动选项等。</li><li>引导加载程序（Boot Loader）：BIOS&#x2F;UEFI会从预定义的引导设备（通常是硬盘、光盘或网络）中加载引导加载程序，例如GRUB、LILO等，它负责加载操作系统的核心模块到内存中。</li><li>操作系统内核加载：引导加载程序会加载操作系统的内核模块到内存中，并将控制权交给操作系统的内核。</li><li>内核初始化：操作系统内核被加载后，会进行初始化，包括初始化设备驱动程序、建立进程管理、内存管理、文件系统等子系统。</li><li>用户空间初始化：操作系统内核初始化完成后，会创建一个或多个用户空间的进程，这些进程负责提供用户界面和用户应用程序的运行环境。</li><li>用户应用程序加载：用户空间的进程会加载用户应用程序到内存中，并开始执行用户应用程序。</li><li>用户应用程序运行：用户应用程序开始在操作系统的运行环境下执行，通过系统调用和内核交互来请求操作系统提供的服务和资源。</li></ol><p><strong>3.什么是系统调用？系统调用的作用是什么？</strong></p><p>系统调用（System Call）是操作系统提供给用户态程序访问内核态功能和资源的<strong>接口</strong>。它允许用户态程序通过调用特定的系统调用函数来请求操作系统的服务和资源，例如文件操作、网络通信、进程管理、内存管理等。</p><p>当需要执行系统调用时，用户通过中断或异常从用户态切换到内核态，从而执行系统调用</p><p><strong>4.多道程序设计、分时操作系统、实时操作系统是什么</strong></p><ul><li>多道程序：通过进程之间的相互切换，同时运行多个进程</li><li>分时操作系统：通过时间片轮转实现<strong>多用户多程序</strong>并发执行，用户之间的隔离和资源的共享。</li><li>实时操作系统：用于处理实时任务，硬实时（航空、医疗工业）、软实时</li></ul><p><strong>5.什么是中断？如何工作？</strong></p><p>中断（Interrupt）是计算机系统中的一种事件，暂停当前指令，转向执行特定的中断程序</p><p>过程：</p><ol><li>中断请求(外部IO、定时器、出现错误) </li><li>暂停当前保留进程现场 </li><li>根据中断向量表定位中断处理程序入口，移交控制权  </li><li>执行中断处理程序，清除中断标志位</li><li>恢复现场，继续执行原来程序</li></ol><p>作用：中断的存在使得程序支持多任务处理、提高响应，控制硬件设备</p><p><strong>6.什么是守护进程（Daemon Process），它在操作系统中的作用是什么？</strong></p><p>守护进程是一种一直在后台运行的特殊类型的进程，用于提供服务和执行系统管理任务。维护系统的正常运行</p><hr><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p><strong>7.什么是进程控制块（PCB）？其主要作用是什么？</strong></p><p>CB保存了进程的基本信息，如进程ID（PID）、进程状态（如就绪、运行、阻塞等）、进程优先级、内存指针、CPU寄存器内容、进程的内存分配信息等，用于对进程进行管理和控制。</p><p><strong>8.操作系统中进程和线程的区别</strong></p><p>进程是指在操作系统中正在运行的一个程序的实例，它包括了程序的代码、数据和运行时的资源。每个进程都有独立的内存空间和系统资源，例如文件句柄、网络连接等。进程之间相互隔离，彼此独立运行，互不干扰。进程之间通过进程间通信（IPC）机制来进行数据交换和通信。</p><p>而线程是进程内的一个独立执行流，也是程序执行的最小单元。同一进程中的多个线程共享进程的内存空间和系统资源，包括文件句柄、网络连接等。线程之间可以通过共享内存来进行通信，因此线程间的通信更加高效。线程的切换开销较小，因此线程可以更快地响应用户请求。</p><p>总结：进程是独立的程序执行实体，拥有独立的内存空间和系统资源；而线程是进程内的执行流，共享进程的内存空间和系统资源，可以更快地进行通信和切换。</p><p>进程：独立、稳定；线程：资源共享(需要手动实现互斥)、响应快</p><p><strong>9.什么是进程通信？进程通信的方式有哪些？</strong></p><table><thead><tr><th align="left">通信方式</th><th align="left">优点</th><th align="left">缺点</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left">管道</td><td align="left">简单易用，无需考虑同步问题。半双工，如果空了或者满了就会阻塞</td><td align="left">只能用于具有亲缘关系的进程间通信</td><td align="left">父子进程间通信</td></tr><tr><td align="left">信号</td><td align="left">传递简单信息，可靠性高，响应速度快。一个进程可以发送一个信号给另一个进程</td><td align="left">只能传递整数值，不能传递复杂数据结构</td><td align="left">进程间异步通信</td></tr><tr><td align="left">信号量</td><td align="left">一个计数器，可以用于同步和互斥，可靠性高</td><td align="left">只能用于具有亲缘关系的进程间通信</td><td align="left">进程间同步和互斥</td></tr><tr><td align="left">消息队列</td><td align="left">可以传递复杂数据结构，可靠性高，支持多对多通信</td><td align="left">性能较差，需要内核支持</td><td align="left">进程间异步通信</td></tr><tr><td align="left">共享内存</td><td align="left">传输速度快，可以直接访问共享内存区域，支持多对多通信</td><td align="left">需要考虑同步和互斥问题，可能会出现死锁等问题</td><td align="left">进程间大量数据交换</td></tr><tr><td align="left">套接字</td><td align="left">网络通信，支持不同主机之间的进程通信，支持多种协议和数据格式</td><td align="left">实现较为复杂，性能较差</td><td align="left">不同主机之间的进程通信</td></tr></tbody></table><p><strong>10.细说信号量：</strong></p><p>信号量可以解决资源间的共享和同步问题</p><p>资源共享：</p><p>​S表示资源数目，当多个资源时，AND机制</p><p>​wait：  s–     if s &lt; 0，线程加入等待队列  </p><p>​signal：s++  if  s&lt;&#x3D;0, 唤醒等待队列</p><p>生产者消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义两个信号量，用于控制缓冲区的空闲空间和数据项数量</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semEmpty</span> <span class="hljs-operator">=</span> n; <span class="hljs-comment">// 初始值为缓冲区的大小，表示空闲空间的数量</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semFull</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始值为 0，表示数据项的数量</span><br><br><span class="hljs-comment">// 生产者进程</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 生成一个数据项</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 等待空闲空间，如果没有空闲空间则阻塞</span><br>    wait(semEmpty);<br>    <span class="hljs-comment">// 将数据项放入缓冲区</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 增加数据项数量</span><br>    signal(semFull);<br>&#125;<br><br><span class="hljs-comment">// 消费者进程</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 等待数据项，如果没有数据项则阻塞</span><br>    wait(semFull);<br>    <span class="hljs-comment">// 从缓冲区取出一个数据项</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 增加空闲空间数量</span><br>    signal(semEmpty);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>11.为什么操作系统需要进行进程调度，有哪些常见的进程调度算法？</strong></p><p>为了充分利用 CPU 资源</p><ul><li><p>先来先服务（First-Come, First-Served, FCFS）：按照进程到达的先后顺序进行调度，即先到达的进程先被执行。</p></li><li><p>最短作业优先（Shortest Job Next, SJN）：选择下一个执行的进程时，选择估计运行时间最短的进程。</p></li><li><p>优先级调度（Priority Scheduling）：为每个进程分配一个优先级，优先级高的进程优先被调度执行。</p></li><li><p>时间片轮转法（Round Robin, RR）：每个进程被分配一个固定的时间片（时间量），当时间片用完时，进程被挂起，下一个进程开始执行，被挂起的进程排队等待下一轮调度。</p></li><li><p>高响应比：1 + 等待时间&#x2F;服务时间  </p></li><li><p>多级反馈队列调度（Multilevel Feedback Queue Scheduling）：多级队列，优先级高的时间短，进程在规定时间未完成则降到下一级</p></li><li><p>实时：</p><ul><li>​最早截止EDF（抢占、非抢占）</li><li>​最低松弛度优先LLF（不得不开始时抢占CPU）</li></ul></li></ul><p><strong>12.什么是死锁？如何避免和检测死锁？</strong></p><p>各个进程或线程因争夺系统资源（如共享资源）而导致相互等待</p><p>互斥条件 请求与保持条件 不可剥夺条件 循环等待条件</p><p>​<strong>处理方法</strong>：</p><ul><li><strong>预防死锁</strong>（一次性分配资源、允许抢占）</li><li><strong>避免死锁</strong>（银行家：在一次分配完后检查是否有安全序列能实现全部运行）</li><li><strong>监测死锁</strong>（资源分配图，分配完有没有环）</li><li><strong>解除死锁</strong>（资源剥夺、回滚进程、终止进程）</li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><strong>13.内存管理的几个阶段？</strong></p><ul><li><strong>单一连续分配</strong>（单程序）</li><li><strong>固定分区分配</strong>（区域固定但大小不等，一个程序一个区） 分区表维护状态  存在<strong>内部碎片</strong>  不能共享</li><li><strong>动态分区分配</strong>（根据进程大小分配，空闲表，空闲区由一个双向指针连接起来），存在<strong>外部碎片</strong>（太小没人用）  回收直接合并前后空闲区</li><li><strong>分页管理</strong>（离散）  1页1~8KB</li><li><strong>分段管理</strong>  逻辑上</li></ul><p><strong>14.二级分页管理中，如何实现逻辑地址到物理地址的映射</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218637.png" alt="image-20230411175730569"></p><p><strong>15.什么是虚拟内存，概念及其实现原理，虚拟内存与物理内存的映射是怎么实现的？</strong></p><p>概念：</p><ul><li>虚拟内存：每个进程拥有自己的虚拟地址空间，包括代码段、数据段和堆栈段等，进程访问的地址都是虚拟地址，由进程的逻辑地址空间组成。</li><li>物理内存：实际的物理内存模块，用于存储正在执行的进程的数据和指令。</li></ul><p>实现原理：</p><ul><li>分页机制：将进程的虚拟地址空间划分为固定大小的页，同时将物理内存划分为对应大小的页框。每个页框可以存放一个页的数据或指令。</li><li>页表映射：每个进程都有自己的页表，用于记录其虚拟地址空间中每个页与物理内存中页框的映射关系。通过页表，操作系统可以实现虚拟地址到物理地址的映射。</li><li>页面置换：当物理内存不足以容纳所有进程所需的页时，操作系统会使用页面置换算法，将一些不活跃的页面置换到磁盘上，从而释放物理内存空间，用于加载其他进程的页面。</li><li>页面调度：当发生缺页时，抛出缺页中断，操作系统根据进程的访问模式和页的访问频率等信息，通过页面置换算法来决定将哪些页面调入物理内存，从而提高系统的性能。</li></ul><p><strong>16.操作系统中的页面置换算法有哪些</strong></p><ul><li>​最佳置换算法 （理论算法、无法实现）</li><li>​先进先出</li><li>​最久未使用LRU   链表头尾</li><li>​最少使用LFU（页面访问表 +1）   </li><li>​    Clock算法  （第一次置为零不换出，第二次&#x3D;0则 换出）</li></ul><h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><p><strong>17.文件系统是什么？请讲解文件系统的常见类型及其特点</strong></p><p>文件系统是操作系统中负责管理和组织文件的一部分，它提供了一种逻辑结构，用于在存储介质（如硬盘、闪存等）上存储和组织文件，以便用户可以方便地创建、读取、写入、删除、移动、复制和管理文件。</p><p><strong>18.什么是磁盘调度算法？常见的磁盘调度算法有哪些？</strong></p><ul><li>先来先服务FCFS</li><li>最短寻道时间SSTF</li><li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li><li>CSCAN：单方向电梯</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218636.png" alt="image-20230407131552116"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>19.请解释什么是死机和蓝屏，并解释它们在操作系统中的原因和处理方法。</strong></p><ul><li>死机：死机是指计算机在运行时突然停止响应，无法继续执行任何操作，屏幕上的图像和界面也无法更新。死机可能是由于<strong>软件或硬件</strong>故障引起的，例如程序错误、设备驱动问题、内存错误等。死机时，屏幕上的内容通常会被冻结在当前状态，无法进行任何操作。</li><li>蓝屏：蓝屏是指在Windows操作系统中出现严重错误时，屏幕会显示蓝色的错误信息界面，通常包含错误代码和错误信息。蓝屏通常由于<strong>操作系统的关键组件</strong>出现故障或冲突引起，例如驱动程序问题、硬件故障、系统文件损坏等。蓝屏时，计算机会自动崩溃并重启，屏幕上会显示蓝屏错误信息。</li></ul><p>死机无提示信息，而蓝屏有；死机会冻结在当且页面，蓝屏会自动崩溃并重启；</p><p><strong>20.介绍下常见的操作系统</strong></p><p>常见的操作系统类型包括Windows、Linux和macOS。</p><ol><li>Windows：Windows是由微软公司开发的操作系统，广泛应用于个人计算机和企业环境。Windows操作系统以图形用户界面（GUI）为特点，提供了丰富的应用程序生态系统和广泛的硬件兼容性。Windows操作系统版本众多，包括Windows 10、Windows 8、Windows 7等，每个版本都有不同的特点和功能。</li><li>Linux：Linux是一种自由和开放源代码的操作系统，基于UNIX的设计原则和哲学。Linux操作系统以稳定、安全和高度可定制性为特点，被广泛用于服务器、嵌入式系统、移动设备和超级计算机等领域。Linux有众多的发行版，如Ubuntu、CentOS、Debian等，每个发行版有其独特的特点和用途。</li><li>macOS：macOS是由苹果公司开发的操作系统，专门设计用于苹果的Mac计算机。macOS以稳定、安全和用户友好的界面为特点，与苹果的硬件和软件紧密集成，提供了独特的用户体验和生产力工具。macOS有多个版本，如macOS Monterey、Big Sur、Catalina等，每个版本都有新的功能和改进。</li></ol><p>这些操作系统之间的主要区别包括：</p><ul><li>用户界面：Windows以图形用户界面（GUI）为主，macOS也是如此，而Linux则可以有多种用户界面选择，例如GNOME、KDE、XFCE等。</li><li>开放性：Linux是自由和开放源代码的操作系统，可以自由定制和修改，而Windows和macOS都是商业操作系统，不开放源代码。</li><li>应用程序生态系统：Windows和macOS拥有丰富的商业软件和应用程序生态系统，而Linux则以开源软件为主，应用程序生态系统相对较小。</li><li>硬件兼容性：Windows通常具有广泛的硬件兼容性，因为它是市场份额最大的操作系统之一，而macOS只能在苹果硬件上运行，Linux的硬件兼容性则因发行版和驱动支持而异。</li><li>安全性：Linux和macOS在安全性方面通常被认为较高，因为它们基于UNIX的安全设计原则，而Windows在过去一直面临着安全威胁和攻击的挑战。</li><li>社区支持：Linux拥有庞大的开源社区和支持系统，而Windows和macOS则主要依赖于厂商的官方支持。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
