<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>B站秒杀项目</title>
    <link href="/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="B站秒杀项目"><a href="#B站秒杀项目" class="headerlink" title="B站秒杀项目"></a>B站秒杀项目</h1><p><a href="https://www.bilibili.com/video/BV1sf4y1L7KE">视频</a></p><ul><li>前后端结合项目，两种处理页面方式，二者对比可以看orderDetail页面</li><li>前端页面在template下，通过controller返回访问，并<code>model.add添加数据</code>。<code>h:text=&quot;$&#123;goods.goodsName&#125;&quot;</code>区数据， 不可直接访问</li><li>在static下的页面可直接访问，并在页面加载时ajax请求返回json数据，<code>$(&quot;#goodsName&quot;).text(goods.goodsName);</code>根据id注入数据。（代码中的方式，相当于静态化了，视频中一开始是上面的方式，后面才做的静态化）</li></ul><p>秒杀的接口有三个，先在goodsdetail中启用doSeckill1</p><ul><li>doSeckill1:  对应到 <strong>P43</strong>，         update排他+唯一索引实现秒杀(没有做order页面静态化)</li><li>doSeckill2：对应到 <strong>P53</strong>，         order界面静态化 +  redis预减库存 + 内存标记 + MQ</li><li>doSeckill ：最终秒杀方案          一些安全上的优化</li></ul><p>对应到发起请求界面static\goodsDetail.html 52~67行</p><h2 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h2><ol><li>项目框架搭建<ol><li>SpringBoot环境搭建</li><li>集成Thymeleaf,RespBean</li><li>MyBatis</li></ol></li><li>分布式会话<ol><li>用户登录<ol><li>设计数据库</li><li>明文密码二次MD5加密</li><li>参数校验+全局异常处理</li></ol></li><li>共享Session<ol><li>SpringSession</li><li>Redis</li></ol></li></ol></li><li>功能开发<ol><li>商品列表</li><li>商品详情</li><li>秒杀</li><li>订单详情</li></ol></li><li>系统压测<ol><li>JMeter</li><li>自定义变量模拟多用户</li><li>JMeter命令行的使用</li><li>正式压测<ol><li>商品列表</li><li>秒杀</li></ol></li></ol></li><li>页面优化<ol><li>页面缓存+URL缓存+对象缓存</li><li>页面静态化，前后端分离</li><li>静态资源优化</li><li>CDN优化</li></ol></li><li>接口优化<ol><li>Redis预减库存减少数据库的访问</li><li>内存标记减少Redis的访问</li><li>RabbitMQ异步下单<ol><li>SpringBoot整合RabbitMQ</li><li>交换机</li></ol></li></ol></li><li>安全优化<ol><li>秒杀接口地址隐藏</li><li>算术验证码</li><li>接口防刷</li></ol></li><li>主流的秒杀方案</li></ol><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><table><thead><tr><th>技术</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>Spring Boot</td><td>2.6.4</td><td></td></tr><tr><td>MySQL</td><td>8</td><td></td></tr><tr><td><a href="https://github.com/baomidou/generator">MyBatis Plus</a></td><td>3.5.1</td><td></td></tr><tr><td>Swagger2</td><td>2.9.2</td><td>Swagger-models2.9.2版本报错，使用的是1.5.22</td></tr><tr><td><a href="https://doc.xiaominfo.com/">Kinfe4j</a></td><td>2.0.9</td><td>感觉比Swagger UI漂亮的一个工具，访问地址是ip:端口&#x2F;doc.html</td></tr><tr><td>Spring Boot Redis</td><td></td><td></td></tr></tbody></table><p>快（高性能） 准（一致性） 稳（高可用）</p><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>spring 模板，并添加相应依赖，再添加mybatisplus</p><p>配置mybatis-plus  datasource  log</p><p>创建controller service mapper 和mapper.xml， @MapperScan Dao层</p><p>新建测试接口测试</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>创建数据库表以及mapper service controller层</p><p>​pass  &#x3D;  MD5(MD5(pass名为+salt) + salt2)，前端传过来的时候也加密一次。这里salt2是存在数据库里的</p><p>创建一个项目作为逆向生成工具项目，勾选spring web，添加mybatis plus，官网代码生成器</p><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>&#x2F;doLogin</p><p>导入登录界面，前端传密码前用md5加密一下</p><p>添加通用返回类以及枚举对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RespBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title function_">success</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RespBean</span>(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RespBeanEnum</span> &#123;<br>    <span class="hljs-comment">//通用</span><br>    SUCCESS(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;SUCCESS&quot;</span>),<br>    ERROR(<span class="hljs-number">500</span>, <span class="hljs-string">&quot;服务端异常&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>校验在service中，还可以导入<code>spring-boot-starter-validation</code>包然后通过注解<code>@NotNull</code>实现校验。</p><ul><li><p>service如果出现异常，抛出并且<code>全局异常处理</code></p></li><li><p>登录成功后存一个uuid到session，并用cookie(直接返回也可以)返回给前端，前端每次都带上这个；或者返回一个token，前端每次携带</p></li><li><p>添加<code>spring-session-data-redis</code>依赖后可以将session自动存入redis中实现分布式session，</p></li><li><p>或者直接存数据到redis, key为uuid，通过cookie传来。之后相当于每次<strong>通过uuid拿到用户信息</strong>。导入<code>redis</code>包，配置 ip port等，配置类实现redis序列化，object序列化为json</p></li><li><p>使用配置MVC，继承 <code>WebMvcConfigurer</code>实现mvc的配置</p><p>​配置自定义参数配置， 每次取出user传入参数（这里只做了取出参数User，没有拦截请求）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903365.png" alt="image-20230315100229300"></p><p>​    还可以配置拦截器，添加拦截器，拦截哪些请求。（也可以拦截器直接实现参数，自己代码）</p></li></ul><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><p><strong>界面</strong>：商品列表 商品详情 订单 </p><p><strong>表</strong>：商品表 订单表 秒杀商品表（秒杀活动很多，添加一个标识字段不合适）  秒杀订单表</p><p><code>秒杀表</code>：商品ID、秒杀库存、开始结束时间</p><h3 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h3><p>名称 图片 价格 秒杀价 秒杀库存</p><p>由于需要显示的数据包含<code>商品表</code>和<code>秒杀商品表</code>，添加vo继承商品表添加额外信息</p><p><code>toList</code>接口返回商品列表，还需要添加<strong>mvc静态资源映射</strong> ：<code>addResourceHandlers</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903366.png" alt="image-20230307190839362"></p><h3 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h3><p>需要知道秒杀是否开始结束，后端通过时间判断返回给前端一个状态（未开始、进行中、已结束）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903367.png" alt="image-20230307193103679"></p><h3 id="秒杀功能"><a href="#秒杀功能" class="headerlink" title="秒杀功能"></a>秒杀功能</h3><p>&#x2F;doSeckill1  传统秒杀</p><p>传入user，goodsId</p><ul><li>判断该goodsId是否还有库存，库存是看秒杀商品表， <code>进一步：redis预减</code></li><li>判断该userId是否购买过goodId（查看秒杀订单表）：&#x3D;&#x3D;优化：查询redis&#x3D;&#x3D;</li><li>都没问题时，减库存，生成订单，生成秒杀订单          <code>进一步：加入队列</code></li></ul><p>代码中，前端页面需要将接口改为doSeckill1</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>建表，需要额外秒杀商品表（价格、库存、开始结束时间）、秒杀订单（商品id、订单id）</li><li>登录，存入信息到redis，key为时间戳，访问通过cookie携带</li><li>全局异常处理处理业务异常，拦截器拦截未登录用户（cookie时间戳不合理），静态资源配置</li><li>商品列表、商品详情页，秒杀功能</li></ul><h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>jmeter</p><ul><li>QPS：每秒请求次数</li><li>TPS：每秒事务（吞吐量）次数</li><li>一个页面一个TPS可能多次QPS</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903368.png" alt="image-20230314094536441"></p><p>但windos和linux相差可能很多</p><p><strong>配置mysql：</strong>为了安全性创建新用户xx，打开阿里云安全组，关闭防火墙</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">CREATE USER &#x27;xx&#x27;@&#x27;%&#x27; IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br>grant <span class="hljs-attribute">all</span> on *.* <span class="hljs-selector-tag">to</span> &#x27;xx&#x27;@&#x27;%&#x27;;<br><br>sudo firewall-cmd <span class="hljs-attr">--list-ports</span><br>sudo firewall-cmd <span class="hljs-attr">--add-port</span>=<span class="hljs-number">3306</span>/tcp <span class="hljs-attr">--permanent</span><br>sudo firewall-cmd <span class="hljs-attr">--reload</span><br></code></pre></td></tr></table></figure><p><strong>配置redis</strong>  (使用docker)，并配置远程访问以及持久化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"># 持久化<br>mkdir -<span class="hljs-selector-tag">p</span> /root/docker/redis/data<br>mkdir -<span class="hljs-selector-tag">p</span> /root/docker/redis/conf<br>vi /root/docker/redis/conf/redis<span class="hljs-selector-class">.conf</span><br>    # bind <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br>    protected-mode no<br>    appendonly yes<br>requirepass <span class="hljs-number">123123</span><br><br>docker run <span class="hljs-attr">--name</span> my_redis -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -v /root/docker/redis/data:/data -v /root/docker/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf <br><br>redis-server /etc/redis/redis.conf：在容器内执行的命令，启动 Redis 服务，并使用 /etc/redis/redis.conf 作为配置文件。<br><br></code></pre></td></tr></table></figure><p>安装jmeter，配置encodin，导入配置，放到bin目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./jmeter.sh -n -t first.jmx -l result.jtl<br>result.jtl 拿到win 聚合报告下查看<br></code></pre></td></tr></table></figure><p>部署java 到docker容器中,但我mysql redis都装在宿主机，需要合并网络不好访问，所以还是部署出来（或者用dockercompose部署）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"># 使用 openjdk 作为基础镜像<br><span class="hljs-selector-tag">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-alpine<br><br># 设置工作目录<br>WORKDIR /app<br><br># 将打包好的jar复制到容器中<br>COPY target/seckill-demo-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar /app/seckill-demo-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar<br><br># 暴露应用程序端口，起提示作用<br>EXPOSE <span class="hljs-number">8080</span><br><br># 启动应用程序<br>CMD [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app/seckill-demo-0.0.1-SNAPSHOT.jar&quot;</span>]<br><br>docker build -t myapp:v1 .<br>docker run -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> myapp:v1<br></code></pre></td></tr></table></figure><p><strong>问题</strong>：postman可以携带cookie请求成功，但浏览器不可以（跨域）</p><p>​现在没有拦截未登录用户，如果未携带cookie会导致User空指针异常</p><p><strong>小结</strong></p><ul><li>本地项目数据库、redis都用云的，并打包一份项目放到云上</li><li>云上部署，本地运行压测程序进行压测（标准应该云上压测，但比较麻烦）</li></ul><h3 id="配置文件导入多用户"><a href="#配置文件导入多用户" class="headerlink" title="配置文件导入多用户"></a>配置文件导入多用户</h3><ul><li><p>再创建一个用户，登录后把uuid保存下来，放到文件里逗号分隔</p></li><li><p>csv数据文件设置 <strong>定义</strong>变量名称<code>userTicket</code>, <code>$&#123;userTicket&#125;</code> 取出</p></li><li><p>测试&#x2F;user&#x2F;info接口，看下是不是 <strong>返回不同用户</strong></p></li><li><p>商品列表：5000 10 ：460</p></li></ul><p>生成100个用户，并且登录返回ticket,这里也可以生成用户用java，请求用python</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/createuser&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;压测创建配置文件&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">CreateUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        List&lt;TUser&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//生成用户</span><br><span class="hljs-comment">//        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="hljs-comment">//            TUser tUser = new TUser();</span><br><span class="hljs-comment">//            tUser.setId(1233L + i);</span><br><span class="hljs-comment">//            tUser.setNickname(&quot;user&quot; + i);</span><br><span class="hljs-comment">//            tUser.setSalt(&quot;1a2b3c&quot;);</span><br><span class="hljs-comment">//            tUser.setPassword(&quot;05314c6fbe1d0cdb5eab4e80f1bda30a&quot;);</span><br><span class="hljs-comment">//            list.add(tUser);</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        tUserService.saveBatch(list);</span><br><span class="hljs-comment">//        System.out.println(&quot;create user&quot;);</span><br><br>        <span class="hljs-comment">//读取用户</span><br>        list = tUserService.list();<br><br>        <span class="hljs-comment">//登录，生成UserTicket</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">urlString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://localhost:8080/login/doLogin&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\13000\\Desktop\\config.txt&quot;</span>);<br>        <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>            file.delete();<br>        &#125;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;rw&quot;</span>);<br>        randomAccessFile.seek(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-type">TUser</span> <span class="hljs-variable">tUser</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(urlString);<br>            <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">httpURLConnection</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();<br>            httpURLConnection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>            httpURLConnection.setDoOutput(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> httpURLConnection.getOutputStream();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mobile=&quot;</span> + tUser.getId() + <span class="hljs-string">&quot;&amp;password=c38dc3dcb8f0b43ac8ea6a70b5ec7648&quot;</span>;<br>            outputStream.write(params.getBytes());<br>            outputStream.flush();<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> httpURLConnection.getInputStream();<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> ((len = inputStream.read(buff)) &gt;= <span class="hljs-number">0</span>) &#123;<br>                byteArrayOutputStream.write(buff, <span class="hljs-number">0</span>, len);<br>            &#125;<br>            inputStream.close();<br>            byteArrayOutputStream.close();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">respone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteArrayOutputStream.toByteArray());<br>            <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>            <span class="hljs-type">RespBean</span> <span class="hljs-variable">respBean</span> <span class="hljs-operator">=</span> mapper.readValue(respone, RespBean.class);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">userTicket</span> <span class="hljs-operator">=</span> (String) respBean.getObject();<br>            System.out.println(<span class="hljs-string">&quot;create userTicket:&quot;</span> + tUser.getId());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> tUser.getId() + <span class="hljs-string">&quot;,&quot;</span> + userTicket;<br>            randomAccessFile.seek(randomAccessFile.length());<br>            randomAccessFile.write(row.getBytes());<br>            randomAccessFile.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;write to file :&quot;</span> + tUser.getId());<br>        &#125;<br>        randomAccessFile.close();<br>        System.out.println();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="测试秒杀接口"><a href="#测试秒杀接口" class="headerlink" title="测试秒杀接口"></a>测试秒杀接口</h3><p>&#x2F;doSeckill2</p><p>存在超卖问题！！</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="1-对象缓存redis"><a href="#1-对象缓存redis" class="headerlink" title="1.对象缓存redis"></a>1.对象缓存redis</h3><p>通过uuid缓存User对象，数据跟新后要删除redis</p><h3 id="2-页面缓存redis"><a href="#2-页面缓存redis" class="headerlink" title="2.页面缓存redis"></a>2.页面缓存redis</h3><p>把整个页面缓存到redis </p><p>​本来是<code>return ”goodsList“</code> 返回页面   - - 》》优化成 <code>渲染出整个页面</code>再返回，并缓存整个页面。<code>toList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/toList&quot;, produces = &quot;text/html;charset=utf-8&quot;, method = RequestMethod.GET)</span><br><span class="hljs-meta">@ResponseBody</span> <span class="hljs-comment">// 之前是返回字符串走mvc，现在是直接返回html文本</span><br><br>    <span class="hljs-comment">// 先看redis有没有</span><br>    <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> (String) valueOperations.get(<span class="hljs-string">&quot;goodsList&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(html)) &#123;<br>        <span class="hljs-keyword">return</span> html;<br>    &#125;<br>    <span class="hljs-comment">// 数据还是先放到model</span><br>    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    model.addAttribute(<span class="hljs-string">&quot;goodsList&quot;</span>, itGoodsService.findGoodsVo());<br>    <span class="hljs-comment">// 手动渲染goodsList这个界面</span><br>    <span class="hljs-type">WebContext</span> <span class="hljs-variable">webContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebContext</span>(request, response, request.getServletContext(), request.getLocale(), model.asMap());<br>    html = thymeleafViewResolver.getTemplateEngine().process(<span class="hljs-string">&quot;goodsList&quot;</span>, webContext);<br><br>    <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(html)) &#123;<br>        valueOperations.set(<span class="hljs-string">&quot;goodsList&quot;</span>, html, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <span class="hljs-keyword">return</span> html;<br></code></pre></td></tr></table></figure><h3 id="3-页面静态化"><a href="#3-页面静态化" class="headerlink" title="3.页面静态化"></a>3.页面静态化</h3><p>前后端分离</p><ul><li>静态页面放到static下，可以直接&#x2F;path.html访问，加载页面时请求返回json数据 <code>goodsDetail2</code> -&gt; <code>detail</code></li><li>之前跳转是<code>/goods/toDetail?goodsId=1</code>访问接口，现在是<code>/Detail.html?goodsId=1</code>直接访问页面，但加载页面时多一步ajax请求数据</li><li>前端加载数据 根据id注入: <code>$(&quot;#goodsName&quot;).text(goodsVo.goodsName); </code>  本来是Thymeleaf <code>th:text= &quot;$&#123;goodsVo.goodname&#125;&quot;</code></li></ul><p>orderDetial页面同理：</p><ul><li>原来发起doseckill1请求，成功加载数据return detaii跳转页面，失败返回到错误页面（代码就是这样）</li><li>现在发起doseckill2请求，成功后弹框问是否跳转到static下的detaii.html，然后再发起ajax请求加载detail</li></ul><h3 id="4-静态资源缓存"><a href="#4-静态资源缓存" class="headerlink" title="4.静态资源缓存"></a>4.静态资源缓存</h3><p>配置后static下的<code>goodsDetail.html</code>将被缓存，</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment">#静态资源处理</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-comment">#启动默认静态资源处理，默认启动</span><br>    <span class="hljs-attr">add-mappings:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">cache:</span><br>      <span class="hljs-attr">cachecontrol:</span><br>        <span class="hljs-comment">#缓存响应时间，单位秒</span><br>        <span class="hljs-attr">max-age:</span> <span class="hljs-number">3600</span><br>    <span class="hljs-attr">chain:</span><br>      <span class="hljs-comment">#资源配链启动缓存，默认启动</span><br>      <span class="hljs-attr">cache:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启动资源链，默认禁用</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启用压缩资源（gzip，brotil）解析，默认禁用</span><br>      <span class="hljs-attr">compressed:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启用h5应用缓存，默认禁用</span><br>      <span class="hljs-attr">html-application-cache:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">static-locations:</span> <span class="hljs-string">classpath:/static/</span><br></code></pre></td></tr></table></figure><h3 id="5-问题解决"><a href="#5-问题解决" class="headerlink" title="5.问题解决"></a>5.问题解决</h3><p>判断是否重复抢购，存入redis中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">TSeckillOrder tSeckillOrder = (TSeckillOrder) redisTemplate.opsForValue().get(&quot;order:&quot; + user.getId() + &quot;:&quot; + goodsId);<br></code></pre></td></tr></table></figure><p>单纯在减库存时判断商品库存是否为负，为负不再继续，解决超卖。<code>update会加行级别排他锁</code> &#x3D;&#x3D;影响并发量&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">seckillGoodsResult</span> <span class="hljs-operator">=</span> itSeckillGoodsService.update(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;TSeckillGoods&gt;()<br>                                                          .setSql(<span class="hljs-string">&quot;stock_count = &quot;</span> + <span class="hljs-string">&quot;stock_count-1&quot;</span>)<br>                                                          .eq(<span class="hljs-string">&quot;goods_id&quot;</span>, goodsVo.getId())<br>                                                          .gt(<span class="hljs-string">&quot;stock_count&quot;</span>, <span class="hljs-number">0</span>)<br>                                                         );<br><span class="hljs-keyword">if</span> (!seckillGoodsResult) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>订单表加唯一索引(user, goodid)防止单一用户多抢，<code>@Transactional</code>。</p><p>至此：单一购买以及超卖问题都解决了</p><h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>doseckill2</p><ul><li><p>redis预减库存（原子）</p></li><li><p>内存标记减少redis访问</p></li><li><p>用队列进行缓冲</p></li><li><p>静态化 + MQ + redis: QPS：<code>637-&gt;571</code>   反而下降了 </p></li><li><p><strong>分析原因</strong>：数据库在本地但redis在云上，导致redis读取过慢，<strong>redis本地</strong>后**<code>1933 -&gt; 3209</code>**，p55</p></li></ul><h3 id="1-预减库存"><a href="#1-预减库存" class="headerlink" title="1.预减库存"></a>1.<strong>预减库存</strong></h3><ul><li>加载时加入库存量 ;redis是&#x3D;&#x3D;原子操作&#x3D;&#x3D;，减库存时不会有并发问题，保证进入MQ的都是有库存的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().decrement(<span class="hljs-string">&quot;seckillGoods:&quot;</span> + goodsId);<br><span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span>)&#123;<br>    EmptyStockMap.put(goodsId, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 内存标记</span><br>    redisTemplate.opsForValue().increment(<span class="hljs-string">&quot;seckillGoods:&quot;</span> + goodsId);<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.EMPTY_STOCK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-内存标记："><a href="#2-内存标记：" class="headerlink" title="2.内存标记："></a>2.<strong>内存标记：</strong></h3><p>在访问redis前，使用一个map标记商品是否还有库存，减少redis访问（分布式会不会有问题？？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//内存标记，减少Redis的访问</span><br><span class="hljs-keyword">if</span> (EmptyStockMap.get(goodsId)) &#123;<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.EMPTY_STOCK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-消息队列："><a href="#3-消息队列：" class="headerlink" title="3.消息队列："></a>3.<strong>消息队列：</strong></h3><p>有库存要加入mq，传入参数中</p><ul><li>配置文件定义队列和交换机</li><li>MQSender文件封装发送方法</li><li>返回给前端排队中状态码</li><li>MQReceiver完成下单，再判断下库存、重复抢购</li></ul><h3 id="4-前端轮询："><a href="#4-前端轮询：" class="headerlink" title="4.前端轮询："></a><strong>4.前端轮询：</strong></h3><p> 下单后等待，添加一个接口查询是否下单成功</p><p><strong>lua脚本：</strong></p><p>&#x2F;&#x2F; 减少和增加不是原子的，但会有问题吗？？：redis库存可能负数，但不会超卖</p><p><code>setIfAbsent</code> ：setnx实现加锁，存在以下问题：</p><ul><li>异常了<strong>锁不会销毁</strong>：增加一个5s超时时间</li><li>如果处理时间超过了5s，会导致<strong>删别人的锁</strong>：value是版本号，保证删的是自己加的版本</li><li>（获取版本号 比较 删除）<strong>不是原子操作</strong>：lua脚本实现redis原子化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLock3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> valueOperations.setIfAbsent(<span class="hljs-string">&quot;k1&quot;</span>, value, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">if</span> (isLock) &#123;<br>        valueOperations.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) valueOperations.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + name);<br>        <span class="hljs-comment">//操作结束，删除锁</span><br>        System.out.println(valueOperations.get(<span class="hljs-string">&quot;k1&quot;</span>));<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Boolean) redisTemplate.execute(redisScript, Collections.singletonList(<span class="hljs-string">&quot;k1&quot;</span>), value);<br>        System.out.println(result);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;有线程在使用，请稍后再试&quot;</span>);<br>    &#125;<br>&#125;<br><br>lua：<br> <span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>])==ARGV[<span class="hljs-number">1</span>] then<br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>end<br></code></pre></td></tr></table></figure><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>验证码，存入redis <code>.set(&quot;captcha:&quot; + tUser.getId() + &quot;:&quot; + goodsId, captcha.text() )</code></li><li>对同一用户和商品生成一个唯一地址，拿地址再下单。获取地址需要验证码，地址同样redis</li><li>限流 （网关）</li></ul><p><strong>单接口简单限流</strong>：直接redis，存在5s最后临界问题  ； 漏桶算法；令牌桶算法（令牌不断生成到桶里）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">制访问次数，<span class="hljs-number">5</span>秒内访问<span class="hljs-number">5</span>次<br><span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>captcha = <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) valueOperations.get(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId());<br><span class="hljs-keyword">if</span> (count == <span class="hljs-literal">null</span>) &#123;<br>    valueOperations.set(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId(), <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">5</span>) &#123;<br>    valueOperations.increment(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.ACCESS_LIMIT_REACHED);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通用：</strong>拦截器+注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">需要限制的接口 <br><span class="hljs-meta">@AccessLimit(second = 5, maxCount = 5, needLogin = true)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span><br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AccessLimit &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">second</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maxCount</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器：去出注解中的参数进行判断。同时把user参数的写入也加进来，存入ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<br>        <span class="hljs-comment">// 参数User</span><br>        <span class="hljs-type">TUser</span> <span class="hljs-variable">tUser</span> <span class="hljs-operator">=</span> getUser(request, response);<br>        UserContext.setUser(tUser);<br>        <br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">hm</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>        <span class="hljs-type">AccessLimit</span> <span class="hljs-variable">accessLimit</span> <span class="hljs-operator">=</span> hm.getMethodAnnotation(AccessLimit.class);<br>        <span class="hljs-keyword">if</span> (accessLimit == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> accessLimit.second();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> accessLimit.maxCount();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needLogin</span> <span class="hljs-operator">=</span> accessLimit.needLogin();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>        <span class="hljs-keyword">if</span> (needLogin) &#123;<br>            <span class="hljs-keyword">if</span> (tUser == <span class="hljs-literal">null</span>) &#123;<br>                render(response, RespBeanEnum.SESSION_ERROR);<br>            &#125;<br>            key += <span class="hljs-string">&quot;:&quot;</span> + tUser.getId();<br>        &#125;<br>        <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) valueOperations.get(key);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-literal">null</span>) &#123;<br>            valueOperations.set(key, <span class="hljs-number">1</span>, second, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; maxCount) &#123;<br>            valueOperations.increment(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            render(response, RespBeanEnum.ACCESS_LIMIT_REACHED);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h2><p>网关过滤</p><p>2s 100w请求，20w商品。令牌桶。没获得令牌的直接失败</p><p>快速生成订单：redis （分片） ，再mq</p><p>超卖：分布式锁redisson。加锁解锁消耗：集群</p><p>nacos动态下发商品数量</p><ul><li>框架搭建<ul><li>Thymeleaf, RespBean</li><li>设计数据库 </li><li>全局异常 、通用返回、通用参数</li></ul></li><li>开发<ul><li>商品列表</li><li>商品详情</li><li>订秒杀</li><li>订单详情</li></ul></li><li>压测<ul><li>配置环境</li><li>多用户</li></ul></li><li>优化 页面、对象</li><li>进一步优化Redis预减、内存标记、MQ</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>框架搭建<ul><li>Thymeleaf, RespBean</li><li>设计数据库 </li><li>全局异常 、通用返回、通用参数</li></ul></li><li>开发<ul><li>商品列表</li><li>商品详情</li><li>订秒杀</li><li>订单详情</li></ul></li><li>压测<ul><li>配置环境</li><li>多用户</li></ul></li><li>优化 页面、对象</li><li>进一步优化Redis预减、内存标记、MQ</li></ul><p>笔记：<a href="https://goinggoinggoing.github.io/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE">https://goinggoinggoing.github.io/2023/03/20/B站秒杀项目</a><br>项目地址：<a href="https://github.com/Goinggoinggoing/seckill-study">https://github.com/Goinggoinggoing/seckill-study</a><br>项目来源：程序员来了666， 添加了一些中间过程接口以及注释<br>总结一下，分为三部分<br>第一个部分为基础的实现P43：到这里为了实现不超卖（减少库存的同时判断库存数量）且单一下单（唯一索引）：</p><p>boolean seckillGoodsResult &#x3D; itSeckillGoodsService.update(new UpdateWrapper<TSeckillGoods>()<br>        .setSql(“stock_count &#x3D; “ + “stock_count-1”)<br>        .eq(“goods_id”, goodsVo.getId())<br>        .gt(“stock_count”, 0)  &#x2F;&#x2F;大于零才下单<br>);<br>&#x2F;&#x2F; 防超卖，直接结束，很关键<br>if (!seckillGoodsResult) {<br>    return null;  &#x2F;&#x2F; 否则下单事务直接结束。update是排他锁，一定不会超卖<br>}<br>同时做了一些优化：页面静态化在前后端分离里默认就做了；下单后存入redis，加快是否重复下单判断。：</p><p>第二部分为进一步优化：1.用redis预减库存（减少数据库访问），redis是原子操作，可以防止超卖；2.满足还有库存后进入MQ队列；  3.我还想减少redis访问次数：引入内存标记。</p><p>第三部分为其他优化，比较清晰自己看即可</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建立博客</title>
    <link href="/2023/03/20/%E5%BB%BA%E7%AB%99/"/>
    <url>/2023/03/20/%E5%BB%BA%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>首先优先选择Hexo是因为Node.js已经安装好了，比较方便</p><p>主题选择：Fluid</p><ul><li><p>主题需要简洁，因为博客定位是笔记记录整理</p></li><li><p>需要有一定的美观（因为这个放弃了next主题）</p></li><li><p>基本的页面：首页 归档 分类(支持多级分类) 、标签、搜索功能</p></li></ul><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><ol><li>安装Nodejs</li><li>安装脚手架<code>npm install -g hexo-cli</code></li></ol><h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init blog   <span class="hljs-comment"># 初始化博客</span><br><span class="hljs-built_in">cd</span> blog<br>npm instal<br><br><br>hexo new fistt <span class="hljs-comment"># 创建第一个页面 填写内容</span><br><br>hexo g <span class="hljs-comment"># 生成文件</span><br>hexo s <span class="hljs-comment"># 启动  localhost:4000可以查看博客</span><br></code></pre></td></tr></table></figure><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><ol><li><p>新建 <code>用户名.github.io</code> 的仓库</p></li><li><p>配置博客推送到对应仓库</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span>  <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Goinggoinggoing/Goinggoinggoing.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li><li><p><code>npm install hexo-deployer-git --save</code>  安装git部署插件</p></li><li><p><code>hexo d</code> 推送到仓库</p></li></ol><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><ol><li><p><code>npm install --save hexo-theme-fluid</code></p></li><li><p>修改_config.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span><br>language: zh-CN  <span class="hljs-comment"># 指定语言</span><br></code></pre></td></tr></table></figure></li><li><p>重新生成并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <br>hexo s <br></code></pre></td></tr></table></figure></li></ol><h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><p>​<a href="https://hexo.fluid-dev.com/docs/guide/">官方文档</a></p><h4 id="文章配置"><a href="#文章配置" class="headerlink" title="文章配置"></a>文章配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">开发</span>, <span class="hljs-string">项目</span>]<br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 但可以通过链接访问</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span> <span class="hljs-comment"># 文章排序顺序 越大越前</span><br><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span> <span class="hljs-comment"># 封面图</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post_banner.jpg</span>  <span class="hljs-comment">#顶部图</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br><br></code></pre></td></tr></table></figure><h3 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h3><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><ul><li>修改博客配置文件，<code>post_asset_folder: true</code>，使得每次生成文章时默认携带一个同名文件夹，用来存放图片</li><li>引用图片： <code>![](test.png)</code>   或  <code>&#123;% asset_img test.png 图片引用方法一 %&#125;</code></li><li>存在的问题：本地typora记笔记是记录到  name.asset&#x2F;test.png，这样从本地到博客需要转换很麻烦</li></ul><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>​搭建github图床，每次本地完成后通过PicGo一键上传到图床，即可访问图片</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230402195401606.png" alt="image-20230402195401606"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_淡淡的说非的博客-CSDN博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062021847.png" alt="image-20210808133147935" style="zoom:67%;" /><p>MAC首部 + IP首部 + TCP首部 + TCP数据</p><p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>​MAC帧   物理地址</p><p>​交换机</p><h4 id="CSMA-x2F-CD"><a href="#CSMA-x2F-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h4><p>​多址接入、载波监听、碰撞检测</p><p>​往返时间为2t，每个数据包要大于2t发送时间（最短有效帧长）。所有小于等于2t的都丢弃。</p><p>​10Mbit&#x2F;s ，64B最短帧长，总线不能超过5120m。考虑衰减：2500m</p><p>​64<em>8&#x2F;10^7^  &gt;&#x3D;   5120 * 2 &#x2F; 2</em>10^8^</p><p><strong>ARP</strong> ： IP-》MAC</p><p><strong>差错检验：</strong> CRC</p><p><strong>可靠传输：</strong>ARQ停止等待、回退N帧（可以发多个）、选择重传（可以不按序接收）</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>​IP数据报  IP地址4*8 </p><p>​子网间通信：发给默认网关。由某路由器上的默认网关转发</p><p>​同一子网通信：直接通过交换机</p><p>​RIP路由选择：下一跳</p><p><strong>NAT</strong>：内网访问外网，分配临时IP</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>​应用间通信</p><p>​端口区分应用：FTP 21、TELNET 23、 SMTP 25、 DNS 53、 HTTP 80、 HTTPS 443 </p><p>TCP<strong>可靠传输</strong>：发送需要确认 （滑动窗口）</p><ol><li>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</li><li>对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失</li></ol><p><strong>三次握手</strong>：防止假如a发了两次请求，第一次以为失败了，而b接受了两次请求，第二次一直在等a浪费时间。</p><p><strong>四次挥手</strong>：1 a发出关闭请求，2 b发出响应确认，并半关闭状态不断发送信息， 3 最后发送关闭请求。a确认关闭请求</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062021849.png" alt="image-20210808142023374" style="zoom: 80%;" /><p><strong>慢启动（指数）、拥塞避免（线性）、快重传 （3个ack后立即重发）、快恢复（拥塞后从新门限开始）</strong></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>应用  应用层运输层</strong></p><p>电子邮箱SMTPTCP</p><p>远程访问 TELNETTCP</p><p>万维网HTTPTCP</p><p>文件传输FTPTCP</p><p>域名解析DNSUDP</p><p>IP电话专用协议UDP</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="ARP协议-Address-Resolution-Protocol"><a href="#ARP协议-Address-Resolution-Protocol" class="headerlink" title="ARP协议 (Address Resolution Protocol)"></a>ARP协议 (Address Resolution Protocol)</h3><p>封装成帧时，通过ARP将IP-&gt;MAC地址。ARP 高速缓存中有就拿，没有就广播询问</p><h3 id="RIP-Routing-Information-Protocol-距离矢量路由协议"><a href="#RIP-Routing-Information-Protocol-距离矢量路由协议" class="headerlink" title="RIP (Routing Information Protocol, 距离矢量路由协议)"></a>RIP (Routing Information Protocol, 距离矢量路由协议)</h3><p>维护路由器一张表：目的网络 、距离、下一跳     坏消息传得慢</p><h3 id="NAT-Network-Address-Translation-网络地址转换"><a href="#NAT-Network-Address-Translation-网络地址转换" class="headerlink" title="NAT (Network Address Translation, 网络地址转换)"></a>NAT (Network Address Translation, 网络地址转换)</h3><p>将内网IP地址转化为临时外网IP地址，保持到NAT转换表中。</p><h3 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h3><ol><li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li><li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li><li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li><li></li></ol><h3 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h3><p>Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案</p><p>保存Sessionid的方式可以采用Cookie，请求时携带。如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。</p><h3 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h3><ol><li>浏览器查询 DNS，获取IP</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>TCP&#x2F;IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ol><h3 id="HTTP请求有哪些常见状态码？"><a href="#HTTP请求有哪些常见状态码？" class="headerlink" title="HTTP请求有哪些常见状态码？"></a>HTTP请求有哪些常见状态码？</h3><ol><li>2xx状态码：操作成功。200 OK</li><li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li><li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li><li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2021/09/08/%E6%9C%BA%E7%BB%84/"/>
    <url>/2021/09/08/%E6%9C%BA%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304061952053.png" alt="image-20210531150601852"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062002396.png" alt="image-20210531111032467" style="zoom: 67%;" /><p>软件</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012811.png" alt="image-20210531111208860" style="zoom:67%;" /><p>硬件</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012813.png" alt="image-20210531112655239"></p><h3 id="1-冯诺依曼"><a href="#1-冯诺依曼" class="headerlink" title="1.冯诺依曼"></a>1.冯诺依曼</h3><p>ENIAC手动接线代表指令。冯诺依曼将指令存储起来</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012814.png" alt="image-20210531113110649" style="zoom: 80%;" /><p><strong>运算器</strong>为中心，数据要经过运算器。</p><p>现代的将<strong>存储器</strong>为中心</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012815.png" alt="image-20210531113528807"></p><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><p>取存数据的程，现代这两个寄存器继承到了cpu里面</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012816.png" alt="image-20210531113844906" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012817.png" alt="image-20210531113937808" style="zoom:50%;" /></p><p>通过<strong>译码器</strong>将地址转为one hot，1的那个为接通</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012818.png" alt="image-20210531153111051"></p><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012819.png" alt="image-20210531114435559"></p><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012820.png" alt="image-20210531114630517"></p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>a * b + c 的执行过程，高级语言转为指令存放到内存中。这里的指令是单地址指令</p><p>根据pc从内存取指令(初始0)   <strong>-&gt;</strong>   分析指令（操作码）    <strong>-&gt;</strong>   执行指令内容      <strong>指令和数据都是来自存储体</strong>   </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012821.png" alt="image-20210531115304027"></p><p>将机器指令转换为多条微指令</p><p>高级语言  -&gt;（编译）  汇编语言    -&gt;  操作系统  -&gt;（汇编） 机器语言 01   -&gt;    微指令</p><p>或者直接将高级语言转为机器语言（python）逐句翻译</p><h4 id="主频"><a href="#主频" class="headerlink" title="主频"></a>主频</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012822.png" alt="image-20210531151536611"></p><h4 id="波特率比特率"><a href="#波特率比特率" class="headerlink" title="波特率比特率"></a>波特率比特率</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012823.png" alt="image-20210607222453605"></p><h3 id="2-基础"><a href="#2-基础" class="headerlink" title="2.基础"></a>2.基础</h3><h4 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1.进制转换"></a>1.进制转换</h4><p>十进制转其他</p><p>​整数除基取余</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012824.png" alt="image-20210601113732024"></p><p>​小数乘基取整</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012825.png" alt="image-20210601113850208"></p><p>二进制转其他（4、8、16）：多位一组，分组转换</p><h4 id="2-BCD码"><a href="#2-BCD码" class="headerlink" title="2.BCD码"></a>2.BCD码</h4><p>用二进制表达十进制数，当超过10时需要加6修正</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012826.png" alt="image-20210601114659976"></p><h4 id="3-ASCII"><a href="#3-ASCII" class="headerlink" title="3.ASCII"></a>3.ASCII</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012827.png" alt="image-20210601114946178" style="zoom: 50%;" /><p>汉字7445个，需要2B</p><h4 id="4-校验"><a href="#4-校验" class="headerlink" title="4.校验"></a>4.校验</h4><p><strong>奇校验</strong>：加完校验1的个数为<strong>奇数个</strong>，一般放前面</p><p><strong>海明校验</strong>：p的位置为2^n，标记出出错位置</p><p>d为数据，p为校验码<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012828.png" alt="image-20210601120945066"></p><p>pi为d为1的下标上第i为异或得到，共需要大约log2位用来校验<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012829.png" alt="image-20210601121114649"></p><p><strong>循环冗余校验CRC ：</strong></p><p>有一个给出的生成多项式，最高为x次<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012830.png" alt="image-20210601121801336">，转为二进制被除数1101有x+1位，将数据左移x位后除以该数（模二除），得到的余数就是校验位。发送   移位后的数  加上  余数。</p><p>校验：数据模二除多项式，余数为零</p><h4 id="5-数据表示"><a href="#5-数据表示" class="headerlink" title="5.数据表示"></a>5.数据表示</h4><p>无符号数： 0 ~ 2^n-1</p><p>有符号数：一位表示符号</p><p>定点小数：纯小数。0. x，再加一位表示符号<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012831.png" alt="image-20210601122710917" style="zoom:67%;" /></p><p>原码：有符号数<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012832.png" alt="image-20210601123056307">，加减计算需要讨论符号</p><p>反码：负数按位取反</p><p><strong>补码</strong>：负数按位取反，末尾加一（原理上是用溢出值减绝对值）。计算直接加</p><p>移码：加上128后，转为无符号机器数。比较大小</p><p><strong>移位：</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012833.png" alt="image-20210601131324554" style="zoom: 67%;" /><p><strong>溢出判断</strong></p><p>​1.通过符号判断</p><p>​2.进位判断法：V&#x3D; S异或C 其中S为符号位产生的进位,C为最高有效位产生的进位。 </p><p>​3.双符号位： V&#x3D;Sf1 Sf2 + 其中,Sf1和Sf2分别为最高符号位及第二符号位。</p><h4 id="求补电路："><a href="#求补电路：" class="headerlink" title="求补电路："></a>求补电路：</h4><p>将补码表示的<strong>带符号数</strong>转换成 <strong>无符号绝对值</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012834.png" alt="image-20210601171422268"></p><h4 id="绝对值乘法"><a href="#绝对值乘法" class="headerlink" title="绝对值乘法"></a>绝对值乘法</h4><p>acc中保存当前进位，MQ高位保存结果以及低位未计算的乘数，当乘数都移出去后，结果就是ACC MQ</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012835.png" alt="image-20210601154034355"></p><h4 id="绝对值除法"><a href="#绝对值除法" class="headerlink" title="绝对值除法"></a>绝对值除法</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012836.png" alt="image-20210601160052898"></p><p>ACC中放当前值，MQ中放结果</p><h4 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012837.png" alt="image-20210601161602994" style="zoom: 80%;" /><p>规格化，M左移使得最高位有效</p><p>溢出时，将M右移</p><p><strong>IEEE 754</strong>       <img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012838.png" alt="image-20210601163257381"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012839.png" alt="image-20210601165117606">)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012840.png" alt="image-20210601163002198"></p><p>浮点数运算：小阶向大阶看齐</p><h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4><p>Arithmetic and logic unit  算数、逻辑、移位</p><p>与非：<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012841.png" alt="image-20210601165845453">现实容易实现</p><p>异或：<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012842.png" alt="image-20210601165936688">和加法的逻辑类似</p><p>全加器：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012843.png" alt="image-20210601170821403" style="zoom:50%;" /><p>多位串行：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012844.png" alt="image-20210601171144274" style="zoom:80%;" /><p>并行</p><p>组内并行，组间串行</p><h3 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3.存储器"></a>3.存储器</h3><p>读取过程：地址线先传送地址数据到MAR，略微等待后<strong>片选线</strong>和<strong>读写控制线</strong>给出信号，将数据读入MDR中</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012845.png" alt="image-20210602131615023"></p><p>实际上，地址是有<strong>行选和列选</strong>（需要的线少一倍），刷新时是以行为单位。</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012846.png" alt="image-20210602133806204" style="zoom:50%;" /><p>地址线连接MAR（行列分别传入），数据线连接MDR</p><p><strong>寻址方式：</strong>按字、字节、半字、双字寻址</p><p><strong>存储方法：</strong></p><p>​小段方式：先放低位字节，低位在左</p><p>​大段方式：先放高位，高位在左</p><h4 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h4><p>辅存不和cpu直接通信，主存RAM+ROM</p><h5 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h5><p>Random Access Memory</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012847.png" alt="image-20210602133519525"></p><p>刷新时间：2ms要都刷新过一次。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012848.png" alt="image-20210602134144186"></p><h5 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h5><p>Read only Memory</p><p>保存必要信息，非易失。保存os在辅存中的位置，开机必要信息</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012849.png" alt="image-20210603102734100" style="zoom: 67%;" /><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="位扩展："><a href="#位扩展：" class="headerlink" title="位扩展："></a><strong>位扩展</strong>：</h5><p>​进行位数的扩充（加大字长） 一个存储器对应byte中的一位</p><p>​例:使用16K<em>1的存储器芯片组成16K</em>8位的存储器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012851.png" alt="image-20210603104237304"></p><h5 id="字扩展法"><a href="#字扩展法" class="headerlink" title="字扩展法:"></a><strong>字扩展法</strong>:</h5><p>​进行字向扩充(位数不变)  需要先选择取哪个存储器</p><p>​例如：用16K*8位的芯片组成64K *8位的存储器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012852.png" alt="image-20210603104254082"> </p><p>​A0~A13为地址选择 A14 A15为芯片选择（2:4译码器）</p><h5 id="字位同时扩展法"><a href="#字位同时扩展法" class="headerlink" title="字位同时扩展法:"></a>字位同时扩展法:</h5><p>​一个存储器的容量为M<em>N位,若使用 l</em>k位的芯片(l&lt;M,K&lt;N),需要在字向和位向同时进行扩展. 此时共需(M&#x2F;l)*(N&#x2F;k)个存储器芯片</p><h4 id="多体并行存储体"><a href="#多体并行存储体" class="headerlink" title="多体并行存储体"></a>多体并行存储体</h4><p>低位交叉编址</p><p>（右图）将相邻的单元放到不同的存储体中，这样<strong>不需要等待恢复时间</strong>再去读取下一个（流水线）</p><p>需要满足当再一次读取到M0时，M0已经恢复</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012853.png" alt="image-20210603112354973" style="zoom: 67%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012854.png" alt="image-20210603111717030"></p><p>宏观上扩展了4倍</p><h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>空间局部性原理（访问的都是相近的元素）</p><p>cache和主存可以<strong>以块为单位</strong>交流</p><p>标记项：cache是从主存中<strong>哪里来的</strong>、cache<strong>是否有效</strong></p><h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>​随便放，查找时遍历查看</p><h5 id="直接映射："><a href="#直接映射：" class="headerlink" title="直接映射："></a><strong>直接映射：</strong></h5><p>​主存第j块和Cache第i块有如下函数关系:</p><p>​i&#x3D; j mod m (m为Cache中总块数)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012855.png" alt="image-20210604111316459"></p><p>​访问过程：依据cache块号直接去查找，看表中对应保存的<strong>组号</strong>与主存中组号是否一样。</p><p>​空间利用率低,命中率也低，硬件实现简单,成本低.</p><h5 id="组相联映射："><a href="#组相联映射：" class="headerlink" title="组相联映射："></a><strong>组相联映射：</strong></h5><p>​将cache分组，主存必须放入对应组中，但组内可以随意放置</p><h5 id="替换与修改"><a href="#替换与修改" class="headerlink" title="替换与修改"></a>替换与修改</h5><p>RAND FIFO  LRU（最近最少使用）  LFU(历史次数)</p><p>写回法：脏位决定是否需要写回</p><p>全写法：有一个缓冲同时修改</p><h4 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h4><p>将访问外存（逻辑地址）映射到主存（物理地址）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012856.png" alt="image-20210604115521773"></p><h3 id="4-指令"><a href="#4-指令" class="headerlink" title="4.指令"></a>4.指令</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012857.png" alt="image-20210604165949832" style="zoom:67%;" /><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012858.png" alt="image-20210604152403058"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012859.png" alt="image-20210604153414463" style="zoom: 80%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012860.png" alt="image-20210604153350576" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012861.png" alt="image-20210604160201175"></p><h4 id="指令的址方式"><a href="#指令的址方式" class="headerlink" title="指令的址方式"></a>指令的址方式</h4><p>1.顺序寻址方式 2.跳跃寻址方式</p><h4 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式"></a>数据寻址方式</h4><p>用寻址特征表明现在的寻址方式</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012862.png" alt="image-20210604161158449" style="zoom:67%;" /><p>立即寻址</p><p>寄存器寻址 </p><p>直接寻址</p><p>寄存器间接寻址</p><p>基址寻址（BR）面向操作系统，内容操作系统确定，有利于<strong>多道程序数据块</strong></p><p>变址寻址（IX）用于循环程序，<strong>数组</strong>的偏移</p><p>相对寻址（PC）  （PC）+A  <strong>跳转指令</strong></p><p>寄存器寻址：（SP）保存栈顶指针</p><p>间接寻址</p><h4 id="CISC、RISC"><a href="#CISC、RISC" class="headerlink" title="CISC、RISC"></a>CISC、RISC</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012863.png" alt="image-20210604165458037"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012864.png" alt="image-20210604165743389"></p><h3 id="5-CPU"><a href="#5-CPU" class="headerlink" title="5.CPU"></a>5.CPU</h3><p>ALU+CU+寄存器+中断系统</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012865.png" alt="image-20210605121433796" style="zoom:67%;" /><h4 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h4><p>cpu<strong>内部总线</strong>完成内部数据传输；MAR，MDR要和<strong>内外总线</strong>都要连接</p><p>还有一种结构为：寄存器之间通过<strong>专用线</strong>连接</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012866.png" alt="image-20210605122928712"></p><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>一个机器周期（CPU周期）是一次存取周期</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012867.png" alt="image-20210605123401431" style="zoom: 67%;" /><h4 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h4><p>取指、取数</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012868.png" alt="image-20210605132815242" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012869.png" alt="image-20210605132849850" style="zoom: 67%;" /></p><h4 id="控制器-1"><a href="#控制器-1" class="headerlink" title="控制器"></a>控制器</h4><p><strong>cpu控制方式：</strong></p><p>​同步控制方式、异步控制方式、联合控制方式</p><p>同步：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012867.png" alt="image-20210605123401431" style="zoom: 67%;" /><h5 id="硬布线：RISC"><a href="#硬布线：RISC" class="headerlink" title="硬布线：RISC"></a><strong>硬布线：</strong>RISC</h5><p><strong>节拍发生器</strong>：将时钟转为节拍</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012870.png" alt="image-20210605141903363" style="zoom:50%;" /><p><strong>安排微操作的时钟节拍</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012871.png" alt="image-20210605135938501"></p><p><strong>设计电路</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012872.png" alt="image-20210605141448990"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012873.png" alt="image-20210605141717000"></p><h5 id="微程序：CISC"><a href="#微程序：CISC" class="headerlink" title="微程序：CISC"></a>微程序：CISC</h5><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012874.png" alt="image-20210605154140727" style="zoom:50%;" /><p>​将微指令保存到控制存储器CM中（CPU内部，ROM实现，一条条已经写好的），类似于指令的保存执行</p><p>​水平型：可以同时执行。垂直型：类似机器指令</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012875.png" alt="image-20210605151805913"></p><p>​<strong>操作控制字段</strong>：标记一个个微操作，</p><p>​<strong>直接表示法</strong>：为1就执行 需要很长   <strong>快</strong></p><p>​<strong>编码表示法</strong></p><p>​<strong>混合</strong><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012876.png" alt="image-20210605152026694" style="zoom:50%;" />组内互斥</p><p>​<strong>顺序控制字段</strong>：下一条微指令是 跳转 还是 顺序 </p><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>将这几个过程重叠起来，并行运行</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012877.png" alt="image-20210605160344293" style="zoom: 67%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012878.png" alt="image-20210605160349615"></p><p><strong>问题：</strong></p><p>​时间不一样：全部统一为最长的时间</p><p><strong>冲突：</strong></p><p>​硬件：</p><p>​       结构相关（资源冲突）：硬件资源满足不了  <strong>同时需要访问内存</strong></p><p>​编程：</p><p>​   数据相关（数据冲突）：一条指令依赖前一条指令的执行结果(数据)却无法得到 c&#x3D;a+b； c++;</p><p>​ <strong>硬件直接暂停   添加空指令</strong>  <strong>数据旁路</strong>  <strong>编译优化</strong></p><p>​控制相关（控制冲突）：流水线遇到分支(if) 指令或其他改变PC值的指令</p><p>​（acm算法运行为非流水执行过程。）</p><h3 id="6-总线"><a href="#6-总线" class="headerlink" title="6.总线"></a>6.总线</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012879.png" alt="image-20210607212721351" style="zoom:67%;" /><p>​<strong>分时  共享</strong></p><p>​机械特性、电器特性、功能特性、时间特性</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>​串行、并行（宽度高、频率低） </p><p>​(内部总线、系统总线（数据、地址、控制）、I&#x2F;O总线) <strong>轮询</strong></p><p>​单总线双总线（速度不同，进行分离）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012880.png" alt="image-20210607213949316" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012881.png" alt="image-20210607213918796" style="zoom:50%;" /></p><p>​三总线（提高io速度）       <strong>DMA控制器</strong>控制高速传输（不用CPU），别的<strong>中断</strong>（鼠标键盘）实现</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012882.png" alt="image-20210607214207930" style="zoom: 67%;" /><p>4总线</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012883.png" alt="image-20210607225218682"></p><p>​地址总线(AB)—其宽度可表明地址空间范围  32位寻址范围2^32 4G</p><p>​数据总线(DB)—其宽度可表明一次读写的二进制位数  32位4B</p><p>​控制总线(CB)— 包括各种控制命令(如存储器读 写、I&#x2F;O读写)、请求信号与仲裁信号、中断请求与应答 等。</p><p>​<strong>复用AB和DB</strong></p><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>​时钟周期T：机器的时钟周期     时钟频率：1&#x2F;T</p><p>​传输周期：N个时钟周期：申请、寻址、传输、结束工作频率：1&#x2F;N</p><p>​总线宽度：DB宽度</p><p>​总线带宽：每秒传输的B ，工作频率 * 总线带宽 &#x2F; 8</p><h4 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h4><h5 id="集中总裁"><a href="#集中总裁" class="headerlink" title="集中总裁"></a>集中总裁</h5><p>​<strong>链式查询</strong>：BR BG BS ，  <strong>BG按顺序查询，距离近的优先级高</strong></p><p>​<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012884.png" alt="image-20210607220159388" style="zoom: 67%;" /></p><p>​<strong>计算器定时查询</strong>：独立的BG线，计数器每次加1代表访问下一个IO ， log n</p><p>​<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012885.png" alt="image-20210607220536152" style="zoom:67%;" /></p><p>​<strong>独立请求</strong>：需要排队、速度快。独立的BG线</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012886.png" alt="image-20210607220713828" style="zoom:67%;" /><h5 id="分布式仲裁："><a href="#分布式仲裁：" class="headerlink" title="分布式仲裁："></a><strong>分布式仲裁</strong>：</h5><p>​不需要中央仲裁器，每个潜在的主 方功能模块都有自己的仲裁号和仲裁器</p><p>​将总裁号发到总裁总线上去比较</p><h4 id="总线操作"><a href="#总线操作" class="headerlink" title="总线操作"></a>总线操作</h4><p>​申请分配（请求、仲裁）、寻址阶段、传输阶段、结束阶段</p><p>​<strong>同步定时方式</strong>：根据时钟的<strong>上升沿</strong>控制节奏</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012887.png" alt="image-20210607222304595" style="zoom:50%;" /><p>​<strong>异步定时方式</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012888.png" alt="image-20210607222129667" style="zoom: 50%;" /><p>​<strong>半同步通信</strong>：加控制信号，当数据没传到位时等待</p><p>​<strong>分离式通信：</strong>将准备数据时，总线控制权交出来</p><h4 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012889.png" alt="image-20210607224104543"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012890.png" alt="image-20210607224633259"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012891.png" alt="image-20210607224925037"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012892.png" alt="image-20210607225022641"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012893.png" alt="image-20210607225726363"></p><h3 id="7-IO"><a href="#7-IO" class="headerlink" title="7.IO"></a>7.IO</h3><p>CPU<strong>管理外围设备</strong>有几种方式：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012894.png" alt="image-20210626104910735" style="zoom:67%;" /><p>IO指令由CPU产生，用来控制IO；通道指令为通道产生，具体执行</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012895.png" alt="image-20210626103906731" style="zoom:67%;" /><h4 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h4><p>​输入： 鼠标键盘    输出 ：显示器打印机</p><p>​外存</p><p><strong>磁表面存储</strong> </p><p>​串行读取</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012896.png" alt="image-20210626110114399" style="zoom:67%;" /><p>​</p><p><strong>磁盘</strong></p><p>​按照扇区读取，寻道-&gt;旋转-&gt;传输时间。利用便宜可以实现加速或者冗余</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012897.png" alt="image-20210626110421321"></p><p><strong>光盘</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012898.png" alt="image-20210626111615777" style="zoom:50%;" /><p><strong>固态硬盘</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012899.png" alt="image-20210626111746131" style="zoom:67%;" /><h4 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h4><p>控制、读取io其实就是访问响应寄存器</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012900.png" alt="image-20210626112849731" style="zoom:67%;" /><p>如何定位编址？统一编址、独立编址（主存的编址和IO的编址是否在一起）</p><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>​比如每秒查询鼠标30次，询问鼠标有没有数据。查到了还需要等待鼠标传输数据</p><h4 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012902.png" alt="image-20210626114555456" style="zoom: 67%;" /><p>在指令完成后，查看中断源寄存器是否有1，有1就进入中断</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012903.png" alt="image-20210626182320701" style="zoom:67%;" /><p>实现<strong>优先级</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012904.png" alt="image-20210626184052004" style="zoom:67%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012905.png" alt="image-20210626184644527"></p><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>​接收IO请求，向CPU发出占用总线的请求</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>并发：宏观上同时运行</li><li>共享：并发进程共同享用资源 </li><li>虚拟：一个物理实体对应多个逻辑</li><li>异步：进程走走停停</li></ul><h4 id="os不同时期发展"><a href="#os不同时期发展" class="headerlink" title="os不同时期发展"></a><strong>os不同时期发展</strong></h4><p>​人工、单道、多道、分时（时间片多用户）、实时</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>​用户接口；联机（cmd）、脱机（程序）、图形化</p><p>​程序接口：系统调用组成。程序调用相应功能系统调用</p><p>​大内核（模块集中）、微内核</p><h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h2><p>作业比程序更广泛，包含程序、数据和作业说明书</p><p><strong>程序</strong>是个静态的概念，<strong>进程</strong>是程序的一次执行</p><p><strong>进程</strong>：对并发执行的程序的控制和描述</p><p><strong>拥有资源</strong>（代码段 数据段  IO），<strong>唯一</strong>PCB</p><h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><p>​动态性、并发性、独立性、异步</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20210807140817329.png" alt="image-20210807140817329">编译</h4><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20210807141320862.png" alt="image-20210807141320862">线程</h4><p>​进程：处理机资源最小单位        创建、撤销和切换代价大</p><p>​线程：处理机调度单位         轻量级进程    TCB          QQ中与不同好友聊天</p><p>​临界资源与临界区</p><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>​1.关中断</p><p>​2.bool变量标识，while等待 ；    swap对换 原理一样         <strong>忙碌等待</strong></p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>​<strong>PV操作</strong></p><p>​S表示资源数目，当多个资源时，AND机制</p><p>​wait：  s–     if s &lt; 0，线程加入等待队列  </p><p>​signal：s++  if  s&lt;&#x3D;0, 唤醒等待队列</p><p>​    <strong>常见问题</strong>：生产者消费者、进餐、读写     （互斥加紧范围小）</p><h4 id="调度分类"><a href="#调度分类" class="headerlink" title="调度分类"></a>调度分类</h4><ul><li>​高级调度（作业调度）：外存到内存 并分配资源   根据JCB</li><li>​中级调度（内存调度）：阻塞程序调入外存，提高利用率和吞吐量     </li><li>​低级调度（进程调度）：分配cpu          （抢占、非抢占）</li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h5><ul><li>​先来先服务FCFS</li><li>​短作业优先SJF</li><li>​高响应比HRRN    (等待+服务时间)&#x2F;服务时间</li><li>​优先级调度PSA</li></ul><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><ul><li>​轮转RR</li><li>​优先级（抢占、非抢占）</li><li>​多级反馈队列：高优先级时间片短，未完成则降级</li></ul><h5 id="实时"><a href="#实时" class="headerlink" title="实时"></a>实时</h5><ul><li>​最早截止EDF（抢占、非抢占）</li><li>​最低松弛度优先LLF（不得不开始时抢占）</li><li>​优先倒置（1.不让抢占临界区  2.优先度继承）</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>​<strong>条件</strong>：互斥、请求和保持、不可抢占、循环等待</p><p>​<strong>处理方法</strong>：预防死锁（一次性分配资源、允许抢占）、避免死锁（银行家：在一次分配完后检查是否有安全序列能实现全部运行）、监测死锁（资源分配图）、解除死锁（资源剥夺、终止进程）</p><h2 id="3-内存"><a href="#3-内存" class="headerlink" title="3.内存"></a>3.内存</h2><h4 id="内存分配（连续）"><a href="#内存分配（连续）" class="headerlink" title="内存分配（连续）"></a>内存分配（连续）</h4><p>​<strong>单一连续分配</strong>（单程序）、<strong>固定分区分配</strong>（区域大小固定）、</p><p>​<strong>动态分区分配</strong>（每个区由一个双向指针连接起来）</p><h5 id="顺序方法"><a href="#顺序方法" class="headerlink" title="顺序方法"></a>顺序方法</h5><p>​首次适应FF：开头开始找到就用   循环首次适应NF：从上一次开始</p><p>​最佳适应BF：分配最小的能用的           最坏适应WF：分配最大的区域</p><h5 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h5><ul><li>​快速适应：多个按大小划分的链表（2kb，5kb..）</li><li>​伙伴系统：多个链表大小为2^i^ ，不存在该大小区域则拆分2^i+1^链表</li></ul><p>​用哈希来寻找表头指针</p><h4 id="分页管理（离散）"><a href="#分页管理（离散）" class="headerlink" title="分页管理（离散）"></a>分页管理（离散）</h4><p>​内存以页面为单位，地址&#x3D;页号+页内地址   ， 页面大小1kb~8kb</p><p>​所以程序的<strong>逻辑地址</strong>都转为<strong>分页地址</strong>。</p><p>​<strong>页表</strong>：程序中页号（逻辑地址）与内存页号（物理地址）<strong>对应关系</strong>，存放在内存中。PCB中的PTR保持页表起始地址。 页表在<strong>内存管理单元</strong>（MMU）中</p><p>​每次访问需要访问两次内存，引入<strong>快表</strong>（高速缓冲寄存器） ；查询时间  <strong>2t + λ -t*a</strong> </p><p>​<strong>多级列表</strong>：将页表空间离散，2^20^  &#x3D;  2^10^  * 2^10^</p><h4 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h4><p>​满足编程上要求，主程序、子程序、数据段</p><p>​当用户共享一段内存时，只需要一个段表，而分页需要多个</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>​时间、空间<strong>局部性</strong></p><p>​作业的页面可能不在内存中，需要从外存调入</p><p>​分配规则：规定分配局部置换（单程序内换）、可变分配局部置换（一起换）、可变分配局部置换（动态加页）</p><h5 id="置换算法"><a href="#置换算法" class="headerlink" title="置换算法"></a>置换算法</h5><ul><li>​最佳置换算法 （无法实现）</li><li>​先进先出</li><li>​最久未使用LRU</li><li>​最少使用LFU   -&gt;  Clock算法  （第一次不换出）</li></ul><h2 id="4-文件"><a href="#4-文件" class="headerlink" title="4.文件"></a>4.文件</h2><p>文件：一系列记录</p><p>记录：一系列数据，有key</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>​顺序文件：顺序存储记录，读取N&#x2F;2</p><p>​索引文件：按键排序建立索引表，logN复杂度</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>单级目录、多级目录、树形目录</p><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>连续组织方式</p><p>链接组织方式：隐式（只存首地址，下一个盘块在当前盘块中），显式（全存到FCB中）FAT表 </p><h2 id="5-io"><a href="#5-io" class="headerlink" title="5.io"></a>5.io</h2><h4 id="磁盘-1"><a href="#磁盘-1" class="headerlink" title="磁盘"></a>磁盘</h4><p>​盘面 磁道 扇区</p><p>寻道+旋转+传输</p><h4 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h4><ul><li>先来先服务FCFS</li><li>最短寻道时间SSTF</li><li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li><li>CSCAN：单方向电梯</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="进程间通信方式："><a href="#进程间通信方式：" class="headerlink" title="进程间通信方式："></a>进程间通信方式：</h3><p>​管道  消息队列  信号量 套接字socket</p><h3 id="临界区："><a href="#临界区：" class="headerlink" title="临界区："></a>临界区：</h3><p>​访问临界资源的片段</p><h3 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h3><p>限制访问能力，防止一些程序访问其它程序的内存数据</p><ul><li>用户态：受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；</li><li>内核态：内存所有数据、外围设备，程序的切换。</li></ul><p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用<strong>陷阱指令</strong>，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p><h3 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h3><p>程序地址页并非都在内存中，需要再装入。所以实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
