<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动手学深度学习NLP</title>
    <link href="/2023/05/23/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0NLP/"/>
    <url>/2023/05/23/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0NLP/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html">https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html</a></p><p><a href="https://course.d2l.ai/zh-v2/">课程安排 - 动手学深度学习课程 (d2l.ai)</a></p><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><h3 id="时序模型"><a href="#时序模型" class="headerlink" title="时序模型"></a>时序模型</h3><p>当前数据与之前数据相关</p><p>音乐、语言、文本</p><p>与前面所有有关：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003519.png" alt="image-20230515113440168"></p><p>对过去的数据建模，然后预测自己：<strong>自回归模型</strong></p><p>A：<strong>马可夫模型</strong>：当前数据只与最近数据相关；用函数前4个值作为特征，预测下一个值，2层MLP</p><p><code>nn.Sequential(nn.Linear(4, 10),nn.ReLU(),nn.Linear(10, 1))</code></p><p>紫线为单步预测，绿线为长步预测</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003521.png" alt="image-20230515115303920"></p><p>B：<strong>潜变量</strong>：引入潜变量，来概括历史信息  RNN  两个模型，（在实际训练中，还是切成了一段段step，实际可以理解为暗含隐马可夫step）</p><p>​ot利用ht输出（ht由 xt-1 和 ht-1 求出，保存<strong>历史信息</strong>），来推测xt</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003522.png" alt="image-20210818124506982" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003523.png" alt="image-20210818124810932" style="zoom:67%;" /><p>QA：</p><ol><li>RNN甚至可以用来排序？因为可用记住</li><li>数据到底和多长的前面的数据相关呢？transformer自动探索多少个</li><li>传感器、电池故障预测。单步多步不是重点，关键在于负样本数量</li><li>序列也是一维数据，可用用CNN做分类吗？ 可以用1维卷积，效果不错的</li></ol><p>Vocab</p><p>tokenize：将文章按<strong>词</strong>或<strong>字母</strong>划分，如果是词中文需要分词</p><p>Vocab：文本词汇表，可以按单词分也可以按字母分，将单词映射为index。  按频率排序，方便观察、常用数据内存在一起</p><h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><p>估计联合概率p(x1 x2 xT)，序列出现的概率</p><ul><li>做预序列模型 BERT GPT-3</li><li>文本生成</li><li>判断序列更常见      语音识别哪个更正常  打字</li></ul><p>使用计数建模：判断文本出现的概率</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003524.png" alt="image-20210817212714212"></p><p>n元语法：一个单词出现的概率与它前面的n-1个单词有关。n-1阶段马可夫模型</p><p>二元词汇：两个词合起来算一个token</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 扫一边，长度还是为n，但重复的会减少，种类会增加</span><br>bigram_tokens = [pair <span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(corpus[:-<span class="hljs-number">1</span>], corpus[<span class="hljs-number">1</span>:])]<br>trigram_tokens = [triple <span class="hljs-keyword">for</span> triple <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>    corpus[:-<span class="hljs-number">2</span>], corpus[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>], corpus[<span class="hljs-number">2</span>:])]<br>[((<span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;traveller&#x27;</span>), <span class="hljs-number">59</span>),<br> ((<span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;machine&#x27;</span>), <span class="hljs-number">30</span>),]<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003525.png" alt="image-20210817221810317" style="zoom: 67%;" /><h4 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h4><p>将corpus 转为 batchsize，单个长度为num_step</p><p>1.batch间随机；随机起始点，每个单词每次只用一次</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003527.png" alt="image-20230515160816014"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-number">2</span>， step = <span class="hljs-number">5</span><br>X:  tensor([[<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],<br>        [ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]) <br>Y: tensor([[<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>],<br>        [ <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<br>X:  tensor([[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],<br>        [<span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>]]) <br>Y: tensor([[ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],<br></code></pre></td></tr></table></figure><p>2.batch间连续</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">X:  tensor([[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>],<br>        [<span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]]) <br>Y: tensor([[ <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],<br>        [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>]])<br>X:  tensor([[ <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>],<br>        [<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>]]) <br>Y: tensor([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>],<br></code></pre></td></tr></table></figure><p>load_data_time_machine: 封装数据并返回vocab</p><p>x &#x3D; [b,t] y&#x3D;[b,t]                                 <strong>特征抽取</strong></p><p><strong>x</strong> -&gt;onehot-&gt;   <strong>[t, b, infeature]</strong>  -&gt;layer-&gt;   <strong>[t, b,  hidden]</strong>  -&gt;linear-&gt;   <strong>[t*b, outfeature]</strong></p><p>​                                                      定义：**[in, hidden]**  state:( layers * direction, batch, hidden，)</p><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><p>任务定义：给定一串字母，生成下一个或者n个</p><p>模型的好坏（<strong>困惑度</strong>）：每一个词都可以看成分类，将每一个词的交叉熵求和求平均。最后做个指数</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003528.png" alt="image-20210818125137879" style="zoom:67%;" /><p>T个时间上的梯度连乘，需要梯度剪裁。但无法处理梯度消失</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003529.png" alt="image-20230515165612896" style="zoom:50%;" /><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003530.png" alt="image-20210818125528564" style="zoom: 50%;" /><p>视频Tracking：不需要用rnn，直接判断bbox帧间周围的情况</p><h4 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h4><p>h是一个hiddens长的特征记录信息，每一个序列x都会更新下一个h，同时该h能够给出一个o输出，代表着预测的输出</p><p>关注h，h是对历史的建模，从h到o只是一个线性回归</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003522.png" alt="image-20210818124506982" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003523.png" alt="image-20210818124810932" style="zoom:67%;" /><p><strong>参数定义：</strong>五个参数，需要梯度。并且需要定义初始化h的函数 ( (b, hiddens),  )</p><p><strong>forward函数：</strong></p><p>序列输入，所以t一定是在最外面。b的作用仅仅是泛化，b之间互不影响。h也是存储了b个</p><ol><li>输入<code>[b,t]</code>和<code>state</code> 转置onehot转为<code>[t, b, onehot]</code> </li><li>按t遍历输入到网络中，每次输出<code>[b onehot]</code>， 并更新t次state</li><li>(和y计算损失函数，预测的下一个字母)</li><li>最后堆叠输出 <code>[t*b, onehot]</code>，<code>new_state</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 传入[t, b, vocab_size]  以及参数、初始状态  返回   [t*b, vocab_size]</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rnn</span>(<span class="hljs-params">inputs, state, params</span>):<br>    <span class="hljs-comment"># `inputs`的形状：(`时间步数量`，`批量大小`，`词表大小`)</span><br>    W_xh, W_hh, b_h, W_hq, b_q = params<br>    H, = state<br>    outputs = []<br>    <span class="hljs-comment"># `X`的形状：(`批量大小`，`词表大小`)</span><br>    <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> inputs:<br>        <span class="hljs-comment"># 一次序列更新一次H，生成一个Y</span><br>        H = torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h)<br>        Y = torch.mm(H, W_hq) + b_q<br>        outputs.append(Y)<br>    <span class="hljs-keyword">return</span> torch.cat(outputs, dim=<span class="hljs-number">0</span>), (H,)<br><br>对于一个 [t, b, vocab_size]， 根据state，每次传入[b, vocab_size]给出[b]个结果预测<br><br><br><span class="hljs-comment"># 网络执行的方式，X传进来后需要onehot</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, X, state</span>):<br>    X = F.one_hot(X.T, self.vocab_size).<span class="hljs-built_in">type</span>(torch.float32)<br>    <span class="hljs-keyword">return</span> self.forward_fn(X, state, self.params)<br></code></pre></td></tr></table></figure><p><strong>剪裁 ：</strong>梯度二范数 torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params)) &lt;  θ  </p><p><strong>预测</strong>： 用预先给的词初始化h，并不断forward给输出并更新state</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据h和上一个x来预测下一个值x，并更新h</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_ch8</span>(<span class="hljs-params">prefix, num_preds, net, vocab, device</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;在`prefix`后面生成新字符。&quot;&quot;&quot;</span><br>    state = net.begin_state(batch_size=<span class="hljs-number">1</span>, device=device)<br>    outputs = [vocab[prefix[<span class="hljs-number">0</span>]]]<br>    get_input = <span class="hljs-keyword">lambda</span>: torch.tensor([outputs[-<span class="hljs-number">1</span>]], device=device).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    <span class="hljs-comment"># 根据input，更新state</span><br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> prefix[<span class="hljs-number">1</span>:]:  <span class="hljs-comment"># 预热期</span><br>        _, state = net(get_input(), state)<br>        outputs.append(vocab[y])<br>        <br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_preds):  <span class="hljs-comment"># 预测`num_preds`步</span><br>        y, state = net(get_input(), state)<br>        outputs.append(<span class="hljs-built_in">int</span>(y.argmax(dim=<span class="hljs-number">1</span>).reshape(<span class="hljs-number">1</span>)))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([vocab.idx_to_token[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> outputs])<br></code></pre></td></tr></table></figure><p><strong>训练：</strong>一个epoch中，注意batch间如果打乱了的化，state要重新初始化。否者沿用之前的，并且需要<strong>detach_()</strong></p><p><strong>损失函数：</strong>直接CrossEntropy 注意更新前先剪裁梯度。y是[b, t] 传入前先转置一下</p><h4 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h4><p>核心：通过保存state信息，对t个features编码，转为t个num_hiddens</p><p>RNN的定义是没有b的，只需要features num_hiddens，但state有b且多了个1维度</p><p>RNN实际上就是对输入的t个时间序列，进行建模处理，并返回hidden维度信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入维度，隐藏层维度</span><br>rnn_layer = nn.RNN(features, num_hiddens)<br><span class="hljs-comment">#传入数据也是onehot后的， 输出没有输出层，加一层linear, state需要自己传入，</span><br><br><span class="hljs-comment"># X：[t, b, features]    </span><br><span class="hljs-comment"># state： [1, b, num_hiddens]</span><br>Y,   state            = rnn_layer (X ,             state )<br><span class="hljs-comment"># Y [t, b, num_hiddens]   t次最后一个layer的H的cat</span><br><span class="hljs-comment"># state_new [1, b, num_hiddens]  用于传入下一次  1为num_layer</span><br><br><span class="hljs-comment"># 所以网络的输出是t个时间段全部的（num_layer[-1].state值cat，最后一个state）   Y[-1] == state_new </span><br></code></pre></td></tr></table></figure><p>输入数据中的t代表着输入数据的时序长度，很像t次MLP分类，但是前面的数据会影响state从而影响后面的分类</p><p>为什么没有out层？输出不一定要和输入的维度一样，比如我可以只去做一个情感分类，或者只想提取特征。如果想分类，直接输入到全连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Y, state = self.rnn(X, state)<br><span class="hljs-comment"># 全连接层首先将`Y`的形状改为(num_steps * b, `隐藏单元数`)。</span><br>output = self.linear(Y.reshape((-<span class="hljs-number">1</span>, Y.shape[-<span class="hljs-number">1</span>])))<br></code></pre></td></tr></table></figure><h4 id="QA："><a href="#QA：" class="headerlink" title="QA："></a>QA：</h4><ol><li><p>处理视频时序序列，t就是想要关联的帧长度，而onehot则改成了由神经网络抽取出来单帧图片的特征。所以[t,features]输入到rnn后，rnn返回给你[t,features’ ] ，根据这个提取出信息</p></li><li><p>如果用<strong>单词作为预测目标</strong>，<code>onehot</code>将会非常长。不利于预测</p></li><li><p>RNN不能处理长序列：<code>num_hiddens</code>决定着你记录<strong>之前的状态</strong>。但太大会过拟合，太小会无法记录下之前的消息</p></li><li><p>高频词可以对概率开根号，或者随机去除</p></li></ol><h3 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h3><p>添加两个门，<strong>更好的保留以前的信息</strong>：如一群老鼠突然出现一直猫，注意点要转移到猫上。（0~1取值，按位乘）</p><p><strong>遗忘门R：</strong>计算h<del>t</del>时，h<del>t-1</del>h忘记多少    <strong>更新门Z</strong>：h<del>t</del>和现在h<del>t-1</del>所占的比例</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003531.png" alt="image-20210819132116519" style="zoom: 67%;" /><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>获取参数</strong> ：11个  <code>W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q</code></p><p><strong>forward函数</strong>：按照公式写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gru</span>(<span class="hljs-params">inputs, state, params</span>):<br>    W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q = params<br>    H, = state<br>    outputs = []<br>    <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> inputs:<br>        Z = torch.sigmoid((X @ W_xz) + (H @ W_hz) + b_z)<br>        R = torch.sigmoid((X @ W_xr) + (H @ W_hr) + b_r)<br>        H_tilda = torch.tanh((X @ W_xh) + ((R * H) @ W_hh) + b_h)<br>        H = Z * H + (<span class="hljs-number">1</span> - Z) * H_tilda<br>        Y = H @ W_hq + b_q<br>        outputs.append(Y)<br>    <span class="hljs-keyword">return</span> torch.cat(outputs, dim=<span class="hljs-number">0</span>), (H,)<br></code></pre></td></tr></table></figure><p>和前面一样封装到类中，需要传入infeature hidden  <code>get_param</code>  <code>init_state</code>  <code>forward</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = d2l.RNNModelScratch(<span class="hljs-built_in">len</span>(vocab), num_hiddens, device, get_params,<br>                            init_gru_state, gru)<br>d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)<br></code></pre></td></tr></table></figure><h4 id="简洁："><a href="#简洁：" class="headerlink" title="简洁："></a>简洁：</h4><p>封装到RNNModel中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">gru_layer = nn.GRU(num_inputs, num_hiddens)<br>model = d2l.RNNModel(gru_layer, <span class="hljs-built_in">len</span>(vocab))<br><span class="hljs-comment"># state依然是(1, b, num_hiddens)</span><br><span class="hljs-comment"># nn.GRU输入为[t,b,in] 输出为[t,b,hi],[1,b,hi]</span><br></code></pre></td></tr></table></figure><p>对比GRU，虽然计算复杂了，但运算速度反而更快了 242822.8  -&gt;  26820.1   tokens&#x2F;sec</p><h4 id="QA"><a href="#QA" class="headerlink" title="QA:"></a>QA:</h4><ol><li>GRU LSTM参数更多，但稳定性比RNN更好</li><li>尽量不要使用RNN</li></ol><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><p>两个state ：C、H</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003532.png" alt="image-20210819142947789" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003533.png" alt="image-20210819143001209" style="zoom:50%;" /></p><p>F （忘记门） 和 I （输入门）决定以前C和现在C~所占比例，O（输出门）决定C求出来后如何向H转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens)<br><span class="hljs-comment"># state: ([1, b, num_hiddens],[1, b, num_hiddens])   H C</span><br><br>Y, state_new = lstm_layer(X, state)<br><span class="hljs-comment"># Y [t, b, num_hiddens])   最后一个H的集合</span><br><span class="hljs-comment"># state_new ([1, b, num_hiddens],[1, b, num_hiddens])  用于传入下一次  1为num_layer</span><br></code></pre></td></tr></table></figure><p>实际内存难以计算，cudnn会用内存换速度，直接跑来看占用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RNNModel</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;The RNN model.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Defined in :numref:`sec_rnn-concise`&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, rnn_layer, vocab_size, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(RNNModel, self).__init__(**kwargs)<br>        self.rnn = rnn_layer<br>        self.vocab_size = vocab_size<br>        self.num_hiddens = self.rnn.hidden_size<br>        <span class="hljs-comment"># If the RNN is bidirectional (to be introduced later),</span><br>        <span class="hljs-comment"># `num_directions` should be 2, else it should be 1.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.rnn.bidirectional:<br>            self.num_directions = <span class="hljs-number">1</span><br>            self.linear = nn.Linear(self.num_hiddens, self.vocab_size)<br>        <span class="hljs-keyword">else</span>:<br>            self.num_directions = <span class="hljs-number">2</span><br>            self.linear = nn.Linear(self.num_hiddens * <span class="hljs-number">2</span>, self.vocab_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs, state</span>):<br>        X = F.one_hot(inputs.T.long(), self.vocab_size)<br>        X = X.to(torch.float32)<br>        Y, state = self.rnn(X, state)<br>        <span class="hljs-comment"># The fully connected layer will first change the shape of `Y` to</span><br>        <span class="hljs-comment"># (`num_steps` * `batch_size`, `num_hiddens`). Its output shape is</span><br>        <span class="hljs-comment"># (`num_steps` * `batch_size`, `vocab_size`).</span><br>        output = self.linear(Y.reshape((-<span class="hljs-number">1</span>, Y.shape[-<span class="hljs-number">1</span>])))<br>        <span class="hljs-keyword">return</span> output, state<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">begin_state</span>(<span class="hljs-params">self, device, batch_size=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(self.rnn, nn.LSTM):<br>            <span class="hljs-comment"># `nn.GRU` takes a tensor as hidden state</span><br>            <span class="hljs-keyword">return</span>  torch.zeros((self.num_directions * self.rnn.num_layers,<br>                                 batch_size, self.num_hiddens),<br>                                device=device)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># `nn.LSTM` takes a tuple of hidden states</span><br>            <span class="hljs-keyword">return</span> (torch.zeros((<br>                self.num_directions * self.rnn.num_layers,<br>                batch_size, self.num_hiddens), device=device),<br>                    torch.zeros((<br>                        self.num_directions * self.rnn.num_layers,<br>                        batch_size, self.num_hiddens), device=device))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_epoch_ch8</span>(<span class="hljs-params">net, train_iter, loss, updater, device, use_random_iter</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Train a net within one epoch (defined in Chapter 8).</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Defined in :numref:`sec_rnn_scratch`&quot;&quot;&quot;</span><br>    state, timer = <span class="hljs-literal">None</span>, d2l.Timer()<br>    metric = d2l.Accumulator(<span class="hljs-number">2</span>)  <span class="hljs-comment"># Sum of training loss, no. of tokens</span><br>    <span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> train_iter:<br>        <span class="hljs-keyword">if</span> state <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> use_random_iter:<br>            <span class="hljs-comment"># Initialize `state` when either it is the first iteration or</span><br>            <span class="hljs-comment"># using random sampling</span><br>            state = net.begin_state(batch_size=X.shape[<span class="hljs-number">0</span>], device=device)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(net, nn.Module) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(state, <span class="hljs-built_in">tuple</span>):<br>                <span class="hljs-comment"># `state` is a tensor for `nn.GRU`</span><br>                state.detach_()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># `state` is a tuple of tensors for `nn.LSTM` and</span><br>                <span class="hljs-comment"># for our custom scratch implementation</span><br>                <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> state:<br>                    s.detach_()<br>        y = Y.T.reshape(-<span class="hljs-number">1</span>)<br>        X, y = X.to(device), y.to(device)<br>        y_hat, state = net(X, state)<br>        l = loss(y_hat, y.long()).mean()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(updater, torch.optim.Optimizer):<br>            updater.zero_grad()<br>            l.backward()<br>            grad_clipping(net, <span class="hljs-number">1</span>)<br>            updater.step()<br>        <span class="hljs-keyword">else</span>:<br>            l.backward()<br>            grad_clipping(net, <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># Since the `mean` function has been invoked</span><br>            updater(batch_size=<span class="hljs-number">1</span>)<br>        metric.add(l * d2l.size(y), d2l.size(y))<br>    <span class="hljs-keyword">return</span> math.exp(metric[<span class="hljs-number">0</span>] / metric[<span class="hljs-number">1</span>]), metric[<span class="hljs-number">1</span>] / timer.stop()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers)<br>model = d2l.RNNModel(lstm_layer, <span class="hljs-built_in">len</span>(vocab))<br><br>d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)<br></code></pre></td></tr></table></figure><h3 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h3><p>多个隐藏层获得非线性性</p><p>​                             <img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003534.png" alt="image-20210819150224101" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003535.png" alt="image-20230516144012521" style="zoom:50%;" /></p><p>在同一个时刻，保存多个<code>Ht</code>  ,由左下角推理而来</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003536.png" alt="image-20210819150931603"></p><p>state: ([1, b, num_hiddens],[1, b, num_hiddens])  -&gt;([2, b, num_hiddens],[2, b, num_hiddens])   两层够了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens，num_layer)  num_layer决定H个数<br></code></pre></td></tr></table></figure><h3 id="双向"><a href="#双向" class="headerlink" title="双向"></a>双向</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003537.png" alt="image-20230516145522237"></p><p>两个H，一个依赖以前的，一个依赖以后的。相互独立，cat在一起决定输出</p><p>抽取特征，分类，填空、翻译。但不能预测未来，因为反方向不存在</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003538.png" alt="image-20210819160940494" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003539.png" alt="image-20210819161400150" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003540.png" alt="image-20210819161423155" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens，num_layer, bidirectional=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>对句子做特征提取：做翻译、改写，不能做预测，因为完全没有反方向的信息</p><h3 id="机器翻译数据集"><a href="#机器翻译数据集" class="headerlink" title="机器翻译数据集"></a>机器翻译数据集</h3><ul><li>读入数据，预处理去除大写、特殊字符。</li><li>单词化后，英语，法语分别绘制vocab，加入一些特殊字符</li><li>批量计算，每一个句子长度要想同，所以限制最大长度，不足补vocab[‘<pad>‘]</li><li>每一个句子结尾补上vocab[‘<eos>‘]，并将词汇转为下标</li><li>封装成batch，每次返回 <code>X, X_valid_len, Y, Y_valid_len</code>.   len为实际句子长度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> X, X_valid_len, Y, Y_valid_len <span class="hljs-keyword">in</span> train_iter:<br>X: tensor([[<span class="hljs-number">93</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">13</span>, <span class="hljs-number">34</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>]])<br>valid lengths <span class="hljs-keyword">for</span> X: tensor([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br><br>Y: tensor([[  <span class="hljs-number">0</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">105</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">121</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>]], dtype=torch.int32)<br>valid lengths <span class="hljs-keyword">for</span> Y: tensor([<span class="hljs-number">6</span>, <span class="hljs-number">3</span>])<br>    <br>b=<span class="hljs-number">2</span>，每个句子最大长度num_steps=<span class="hljs-number">8</span>    输入为一个句子，输出也为一个句子<br>不同于文本生成：序列中每一个输入都有一个输出<br>机器翻译为一整个序列输入：对应一整个序列输出<br></code></pre></td></tr></table></figure><h3 id="Encoder-Decoder"><a href="#Encoder-Decoder" class="headerlink" title="Encoder-Decoder"></a>Encoder-Decoder</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003541.png" alt="image-20210819171331079" style="zoom:80%;" /><p>encoder最后的隐藏状态作为decoder的输入，decoder还可以有额外输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderDecoder</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;编码器-解码器架构的基类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, encoder, decoder, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(EncoderDecoder, self).__init__(**kwargs)<br>        self.encoder = encoder<br>        self.decoder = decoder<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, enc_X, dec_X, *args</span>):<br>        enc_outputs = self.encoder(enc_X, *args)<br>        dec_state = self.decoder.init_state(enc_outputs, *args)<br>        <span class="hljs-keyword">return</span> self.decoder(dec_X, dec_state)<br></code></pre></td></tr></table></figure><h3 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h3><p>句子生成句子，使用编码器解码器架构</p><p>注意编码器用于提取句子(生成state)，解码器输入为前一个单词和state的concate</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003542.png" alt="image-20230516154007581"></p><p>encoder可用<strong>双向</strong>，对输入编码后返回编码器最后的状态，作为decoder输入</p><p>训练时decoder每次用的正确的输入（强制教学），推理用的上一次输出</p><h4 id="衡量结果"><a href="#衡量结果" class="headerlink" title="衡量结果"></a>衡量结果</h4><p>如何衡量生成序列的好坏</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003543.png" alt="image-20230516154646648" style="zoom:50%;" /><ol><li>编码器获得state后，把最后一次的state <code>[num_layer, b, num_hiddens]</code> 作为解码器的输入state</li><li>解码器负责将state[-1]重复t次，作为历史状态，并和输入Y<code>[b,t]</code> concat <code>[t, b, emb+hid]</code>传入GRU网络</li><li>GRU将t个state作为dense的输入，输出<code>t * b * vocab</code> permute<code>b * t * vocab</code></li></ol><h4 id="model"><a href="#model" class="headerlink" title="model"></a>model</h4><h5 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">输入 b, t<br>输出 [t, b, hiddens] [numlayer, b, hiddens]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Seq2SeqEncoder</span>(d2l.Encoder):<br>    <span class="hljs-string">&quot;&quot;&quot;用于序列到序列学习的循环神经网络编码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, embed_size, num_hiddens, num_layers,</span><br><span class="hljs-params">                 dropout=<span class="hljs-number">0</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(Seq2SeqEncoder, self).__init__(**kwargs)<br>        <span class="hljs-comment"># 嵌入层</span><br>        self.embedding = nn.Embedding(vocab_size, embed_size)<br>        self.rnn = nn.GRU(embed_size, num_hiddens, num_layers,<br>                          dropout=dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, *args</span>):<br>        <span class="hljs-comment"># 输出&#x27;X&#x27;的形状：(batch_size,num_steps,embed_size)</span><br>        X = self.embedding(X)<br>        <span class="hljs-comment"># 在循环神经网络模型中，第一个轴对应于时间步</span><br>        X = X.permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 如果未提及状态，则默认为0</span><br>        output, state = self.rnn(X)<br>        <span class="hljs-comment"># output的形状:(num_steps,batch_size,num_hiddens)</span><br>        <span class="hljs-comment"># state的形状:(num_layers,batch_size,num_hiddens)</span><br>        <span class="hljs-keyword">return</span> output, state<br></code></pre></td></tr></table></figure><h5 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">输入 X[b, t]   embedding -&gt;  X[t, b, embed_size]  + cat state[t, b, hiddens] = [t, b, em+hiddens]<br>输出[t, b, hiddens] 经过dense [b, t, vocab_size]  一次性得到t次预测做loss，predict时每次输出一个<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Seq2SeqDecoder</span>(d2l.Decoder):<br>    <span class="hljs-string">&quot;&quot;&quot;用于序列到序列学习的循环神经网络解码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, embed_size, num_hiddens, num_layers,</span><br><span class="hljs-params">                 dropout=<span class="hljs-number">0</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(Seq2SeqDecoder, self).__init__(**kwargs)<br>        self.embedding = nn.Embedding(vocab_size, embed_size)<br>        self.rnn = nn.GRU(embed_size + num_hiddens, num_hiddens, num_layers,<br>                          dropout=dropout)<br>        self.dense = nn.Linear(num_hiddens, vocab_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_state</span>(<span class="hljs-params">self, enc_outputs, *args</span>):<br>        <span class="hljs-keyword">return</span> enc_outputs[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, state</span>):<br>        <span class="hljs-comment"># 输出&#x27;X&#x27;的形状：(batch_size,num_steps,embed_size)</span><br>        X = self.embedding(X).permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 广播context，使其具有与X相同的num_steps</span><br>        context = state[-<span class="hljs-number">1</span>].repeat(X.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        X_and_context = torch.cat((X, context), <span class="hljs-number">2</span>)<br>        output, state = self.rnn(X_and_context, state)<br>        output = self.dense(output).permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># output的形状:(batch_size,num_steps,vocab_size)</span><br>        <span class="hljs-comment"># state的形状:(num_layers,batch_size,num_hiddens)</span><br>        <span class="hljs-keyword">return</span> output, state<br></code></pre></td></tr></table></figure><h4 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要根据实际的长度，超出valid_len部分weights为0从而损失为0, 忽略pad</span><br>X = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]) b, t<br>sequence_mask(X, torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))<br>输出 [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaskedSoftmaxCELoss</span>(nn.CrossEntropyLoss):<br>    <span class="hljs-string">&quot;&quot;&quot;带遮蔽的softmax交叉熵损失函数&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># pred的形状：(batch_size,num_steps,vocab_size)</span><br>    <span class="hljs-comment"># label的形状：(batch_size,num_steps)</span><br>    <span class="hljs-comment"># valid_len的形状：(batch_size,)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, pred, label, valid_len</span>):<br>        weights = torch.ones_like(label)<br>        weights = sequence_mask(weights, valid_len)<br>        self.reduction=<span class="hljs-string">&#x27;none&#x27;</span><br>        unweighted_loss = <span class="hljs-built_in">super</span>(MaskedSoftmaxCELoss, self).forward(<br>            pred.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>), label)<br>        weighted_loss = (unweighted_loss * weights).mean(dim=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> weighted_loss<br></code></pre></td></tr></table></figure><h4 id="train"><a href="#train" class="headerlink" title="train"></a>train</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> data_iter:<br>    optimizer.zero_grad()<br>    X, X_valid_len, Y, Y_valid_len = [x.to(device) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> batch]<br>    bos = torch.tensor([tgt_vocab[<span class="hljs-string">&#x27;&lt;bos&gt;&#x27;</span>]] * Y.shape[<span class="hljs-number">0</span>],<br>                       device=device).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    dec_input = torch.cat([bos, Y[:, :-<span class="hljs-number">1</span>]], <span class="hljs-number">1</span>)  <span class="hljs-comment"># 强制教学 你好啊 -&gt;    &lt;bos&gt;你好</span><br>    Y_hat, _ = net(X, dec_input, X_valid_len) <span class="hljs-comment"># 这里X_valid_len没有用上</span><br>    l = loss(Y_hat, Y, Y_valid_len)<br>    l.<span class="hljs-built_in">sum</span>().backward()<span class="hljs-comment"># 反向传播</span><br>    d2l.grad_clipping(net, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="predict"><a href="#predict" class="headerlink" title="predict"></a>predict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_seq2seq</span>(<span class="hljs-params">net, src_sentence, src_vocab, tgt_vocab, num_steps,</span><br><span class="hljs-params">                    device, save_attention_weights=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;序列到序列模型的预测&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 在预测时将net设置为评估模式</span><br>    net.<span class="hljs-built_in">eval</span>()<br>    src_tokens = src_vocab[src_sentence.lower().split(<span class="hljs-string">&#x27; &#x27;</span>)] + [<br>        src_vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]]<br>    enc_valid_len = torch.tensor([<span class="hljs-built_in">len</span>(src_tokens)], device=device)<br>    src_tokens = d2l.truncate_pad(src_tokens, num_steps, src_vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>])<br>    <span class="hljs-comment"># 添加批量轴</span><br>    enc_X = torch.unsqueeze(<br>        torch.tensor(src_tokens, dtype=torch.long, device=device), dim=<span class="hljs-number">0</span>)<br>    enc_outputs = net.encoder(enc_X, enc_valid_len)<br>    dec_state = net.decoder.init_state(enc_outputs, enc_valid_len)<br>    <span class="hljs-comment"># 添加批量轴</span><br>    dec_X = torch.unsqueeze(torch.tensor(<br>        [tgt_vocab[<span class="hljs-string">&#x27;&lt;bos&gt;&#x27;</span>]], dtype=torch.long, device=device), dim=<span class="hljs-number">0</span>)<br>    output_seq, attention_weight_seq = [], []<br>    <span class="hljs-comment"># 输入dec_X为(1, 1) tb都等于</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_steps):<br>        Y, dec_state = net.decoder(dec_X, dec_state)<br>        <span class="hljs-comment"># 我们使用具有预测最高可能性的词元，作为解码器在下一时间步的输入</span><br>        dec_X = Y.argmax(dim=<span class="hljs-number">2</span>)<br>        pred = dec_X.squeeze(dim=<span class="hljs-number">0</span>).<span class="hljs-built_in">type</span>(torch.int32).item()<br>        <span class="hljs-comment"># 保存注意力权重（稍后讨论）</span><br>        <span class="hljs-keyword">if</span> save_attention_weights:<br>            attention_weight_seq.append(net.decoder.attention_weights)<br>        <span class="hljs-comment"># 一旦序列结束词元被预测，输出序列的生成就完成了</span><br>        <span class="hljs-keyword">if</span> pred == tgt_vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]:<br>            <span class="hljs-keyword">break</span><br>        output_seq.append(pred)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(tgt_vocab.to_tokens(output_seq)), attention_weight_seq<br></code></pre></td></tr></table></figure><h4 id="QA：-1"><a href="#QA：-1" class="headerlink" title="QA："></a>QA：</h4><ol><li>word2vec没讲，跳过了</li><li>transformer可以代替seq2seq</li></ol><h3 id="束搜索"><a href="#束搜索" class="headerlink" title="束搜索"></a>束搜索</h3><p>预测时，每一步都是取最优的（贪心），但贪心不一定是全局最优，例如下面第二步取C</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003544.png" alt="image-20230516202920183"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003545.png" alt="image-20230516202927638"></p><p>穷举：指数级 太大了</p><p>束搜索：每次在所有kn个选项中，保留k个最大的。只保留一个就是贪心</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003546.png" alt="image-20230516203605851" style="zoom:50%;" /><h2 id="注意力"><a href="#注意力" class="headerlink" title="注意力"></a>注意力</h2><h3 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h3><p><code>query</code>：输入   <code>key，value</code>  ：已有的一些数据</p><p>attention的核心 根据<code>query</code>和<code>keyi</code>的关系，决定出<code>valuei</code>的权重，加权得到一个最终value</p><h4 id="核回归"><a href="#核回归" class="headerlink" title="核回归"></a>核回归</h4><h5 id="非参数"><a href="#非参数" class="headerlink" title="非参数"></a>非参数</h5><p>query为输入x，根据数据（(xi,yi)）给出预测y。<code>xi-yi</code>是<code>keys-values</code></p><ol><li>最简单的是对y的数据求平均，这样每个数据给出的f(x)都一样</li><li>根据一个权重，加权求和。权重为根据K(距离)函数求出来的。如果k是高斯核，就等价于用高斯距离<code>softmax</code>加权</li></ol><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003547.png" alt="image-20230517120533488"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003548.png" alt="image-20230517121458578"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># X_repeat的形状:(n_test,n_train),</span><br><span class="hljs-comment"># 每一行都包含着相同的测试输入（例如：同样的查询）</span><br>X_repeat = x_test.repeat_interleave(n_train).reshape((-<span class="hljs-number">1</span>, n_train))<br><span class="hljs-comment"># x_train包含着键。attention_weights的形状：(n_test,n_train),</span><br><span class="hljs-comment"># 每一行都包含着要在给定的每个查询的值（y_train）之间分配的注意力权重</span><br>attention_weights = nn.functional.softmax(-(X_repeat - x_train)**<span class="hljs-number">2</span> / <span class="hljs-number">2</span>, dim=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># y_hat的每个元素都是值的加权平均值，其中的权重是注意力权重</span><br>y_hat = torch.matmul(attention_weights, y_train)<br>plot_kernel_reg(y_hat)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003549.png" alt="image-20230517114942706"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003550.png" alt="image-20230517115633471"></p><p>一行代表，对哪个inpute的权重更大。权重给的比较平滑，所以pred也比较平滑</p><h5 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h5><p>引入可学习的<code>w=nn.Parameter(torch.rand((1,), requires_grad=True))</code>  控制高斯核的窗口大小，w越大窗口越小<br>$$<br>\begin{aligned}f(x) &amp;&#x3D; \sum_{i&#x3D;1}^n \alpha(x, x_i) y_i \&amp;&#x3D; \sum_{i&#x3D;1}^n \frac{\exp\left(-\frac{1}{2}((x - x_i)w)^2\right)}{\sum_{j&#x3D;1}^n \exp\left(-\frac{1}{2}((x - x_j)w)^2\right)} y_i \&amp;&#x3D; \sum_{i&#x3D;1}^n \mathrm{softmax}\left(-\frac{1}{2}((x - x_i)w)^2\right) y_i.\end{aligned}<br>$$<br><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003551.png" alt="image-20230517120017210"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003552.png" alt="image-20230517120026332"></p><p>窗口更窄了，只给离得近的分配权重，所以pred更加弯曲</p><h4 id="注意力分数"><a href="#注意力分数" class="headerlink" title="注意力分数"></a>注意力分数</h4><p>拓展到<strong>高维</strong>情况，q k v都是向量</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003553.png" alt="image-20230517121659643"></p><ul><li>k和q长度一样：kq做内积</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003554.png" alt="image-20230517122729061"></p><ul><li>k和q长度不一样：k和q  concat输入到隐藏层为h输出为1的MLP，再乘上vT输出为分数值。有参</li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003555.png" alt="image-20230517122801534" style="zoom:67%;" /><p>对于每一个query，我都需要得到一个<code>len(“键-值”对)</code>的向量，多个query就是一个weight矩阵 <code>[len(query), len(“键-值”对)]</code>，weight*values得到加权输出<code>[querys, d(v)]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br>[querys, d(q)]  -》  [querys, d(v)]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdditiveAttention</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;加性注意力&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, num_hiddens, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(AdditiveAttention, self).__init__(**kwargs)<br>        self.W_k = nn.Linear(key_size, num_hiddens, bias=<span class="hljs-literal">False</span>)<br>        self.W_q = nn.Linear(query_size, num_hiddens, bias=<span class="hljs-literal">False</span>)<br>        self.w_v = nn.Linear(num_hiddens, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        self.dropout = nn.Dropout(dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, queries, keys, values, valid_lens</span>):<br>        <span class="hljs-comment"># valid_lens对于每个query 考虑多少个kv</span><br>        queries, keys = self.W_q(queries), self.W_k(keys)<br>        <span class="hljs-comment"># 在维度扩展后，</span><br>        <span class="hljs-comment"># queries的形状：(batch_size，查询的个数，1，num_hidden)</span><br>        <span class="hljs-comment"># key的形状：(batch_size，1，“键－值”对的个数，num_hiddens)</span><br>        <span class="hljs-comment"># 使用广播方式进行求和</span><br>        features = queries.unsqueeze(<span class="hljs-number">2</span>) + keys.unsqueeze(<span class="hljs-number">1</span>)<br>        features = torch.tanh(features)<br>        <span class="hljs-comment"># self.w_v仅有一个输出，因此从形状中移除最后那个维度。</span><br>        <span class="hljs-comment"># scores的形状：(batch_size，查询的个数，“键-值”对的个数)</span><br>        scores = self.w_v(features).squeeze(-<span class="hljs-number">1</span>)<br>        self.attention_weights = masked_softmax(scores, valid_lens) <span class="hljs-comment"># valid_lens强行把scores得分1e-6</span><br>        <span class="hljs-comment"># values的形状：(batch_size，“键－值”对的个数，值的维度)</span><br>        <span class="hljs-keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)<br></code></pre></td></tr></table></figure><p>应用：key value query到底是什么</p><h3 id="注意力机制的seq2seq"><a href="#注意力机制的seq2seq" class="headerlink" title="注意力机制的seq2seq"></a>注意力机制的seq2seq</h3><p>翻译时额外添加原句子的对应信息，而不是只用最后一个state。具体用以前的哪个state由attention决定</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003556.png" alt="image-20230517144406568"></p><ul><li>key-value：编码器每一次的RNN 的输出states</li><li>query：解码器上一次输出</li></ul><p>对比之前的改进：之前直接用最后一个state，现在对所有state拿出来做一个weight</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003557.png" alt="image-20230517150923131"></p><ul><li><code>query</code>：当前state[-1]  <code>[batch_size,1,num_hiddens]</code> </li><li><code>key-value</code>: encoder的output<code>[batch_size,num_steps,num_hiddens]</code></li></ul><p><strong>以前的context</strong>：t次都一样，都是最后的state</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoder的state重复t次，代表着我t次上下文关注点都一样</span><br>context = state[-<span class="hljs-number">1</span>].repeat(X.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>X_and_context = torch.cat((X, context), <span class="hljs-number">2</span>)<br>output, state = self.rnn(X_and_context, state)  直接一次性输入到网络<br></code></pre></td></tr></table></figure><p><strong>现在的context：</strong>每次都不一样，为output的加权。<strong>需要遍历</strong></p><ul><li><code>query</code>为上次state[-1]，代表着当前状态 <code>[batch_size, query=1, num_hiddens]</code>  当前状态的维度为<code>num_hiddens</code></li><li><code>key-value = enc_outputs</code>是encoder的output转置下  <code>[batch_size, num_steps, num_hiddens]</code> 代表着有t次状态，每个状态的维度为<code>num_hiddens</code>，attention对t次状态加权后得到<code>[batch_size, query=1, num_hiddens]</code>, 权重矩阵为<code>[b, query=1, num_steps]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> X:  <span class="hljs-comment"># 每一次query(当前状态都不同，代表着翻译到了哪个单词)</span><br>    <span class="hljs-comment"># query的形状为(batch_size, 1, num_hiddens)          1代表着一次询问</span><br>    query = torch.unsqueeze(hidden_state[-<span class="hljs-number">1</span>], dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># context的形状为(batch_size,1,num_hiddens)   enc_valid_lens忽略输入的pad</span><br>    context = self.attention(query, enc_outputs, enc_outputs, enc_valid_lens)<br>    <br>    <span class="hljs-comment"># 在特征维度上连结</span><br>    x = torch.cat((context, torch.unsqueeze(x, dim=<span class="hljs-number">1</span>)), dim=-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 将x变形为(t=1, batch_size, embed_size+num_hiddens)</span><br>    out, hidden_state = self.rnn(x.permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>), hidden_state)<br></code></pre></td></tr></table></figure><p>QA：</p><ol><li>BERT 其实是纯attention</li></ol><h3 id="self-attention"><a href="#self-attention" class="headerlink" title="self-attention"></a>self-attention</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003558.png" alt="image-20230517161838017"></p><p>key value query都是x</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003559.png" alt="image-20230517164245269"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原来： [querys, d(q)]  -&gt;  [querys, d(v)]</span><br>o = attention(queries, keys, values)   self.attention(query, enc_outputs, enc_outputs)<br><br><span class="hljs-comment"># 现在: [t, d(x)]  -&gt;  [t, d(x)]</span><br>X = self.attention(X, X, X)<br></code></pre></td></tr></table></figure><h4 id="pos-encoding"><a href="#pos-encoding" class="headerlink" title="pos-encoding"></a>pos-encoding</h4><p>失去了位置信息，添加上位置P矩阵。n个词i，每个d维j。也可以是可学习（BERT）<br>$$<br>\begin{aligned} p_{i, 2j} &amp;&#x3D; \sin\left(\frac{i}{10000^{2j&#x2F;d}}\right),\p_{i, 2j+1} &amp;&#x3D; \cos\left(\frac{i}{10000^{2j&#x2F;d}}\right).\end{aligned}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save </span><br>[b, t, d]  -&gt;  [b, t, d]    p:[<span class="hljs-number">1</span>, max_len, num_hiddens]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PositionalEncoding</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;位置编码&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_hiddens, dropout, max_len=<span class="hljs-number">1000</span></span>):<br>        <span class="hljs-built_in">super</span>(PositionalEncoding, self).__init__()<br>        self.dropout = nn.Dropout(dropout)<br>        <span class="hljs-comment"># 创建一个足够长的P</span><br>        self.P = torch.zeros((<span class="hljs-number">1</span>, max_len, num_hiddens))<br>        X = torch.arange(max_len, dtype=torch.float32).reshape(<br>            -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) / torch.<span class="hljs-built_in">pow</span>(<span class="hljs-number">10000</span>, torch.arange(<br>            <span class="hljs-number">0</span>, num_hiddens, <span class="hljs-number">2</span>, dtype=torch.float32) / num_hiddens)<br>        self.P[:, :, <span class="hljs-number">0</span>::<span class="hljs-number">2</span>] = torch.sin(X)<br>        self.P[:, :, <span class="hljs-number">1</span>::<span class="hljs-number">2</span>] = torch.cos(X)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        X = X + self.P[:, :X.shape[<span class="hljs-number">1</span>], :].to(X.device)<br>        <span class="hljs-keyword">return</span> self.dropout(X)<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003560.png" alt="image-20230517164528517" style="zoom:67%;" /><p>QA：</p><ol><li>self-attention理解为一个layer，有输入输出</li></ol><h3 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h3><ul><li>encoder-decoder架构</li><li>纯注意力，n个transformer块</li><li>block input-output形状一样</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003561.png" alt="image-20230523122148500"></p><h4 id="muti-head-attention"><a href="#muti-head-attention" class="headerlink" title="muti-head-attention"></a>muti-head-attention</h4><p>多个dot attention，也就是多个h</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003562.png" alt="image-20230523112624348"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">num_hiddens, num_heads = <span class="hljs-number">100</span>, <span class="hljs-number">5</span><br><br>X = torch.ones((b, num_queries, num_hiddens))<br>Y = torch.ones((b, num_kvpairs, num_hiddens))<br>attention = MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens,<br>                               num_hiddens, num_heads, <span class="hljs-number">0.5</span>)<br>attention(X, Y, Y, valid_lens).shape = [b, num_queries, num_hiddens]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save </span><br>t:查询或者“键－值”对的个数<br>transpose_qkv：(b，t，num_hiddens) -&gt; (b*num_heads, t, num_hiddens/num_heads)<br>相对于num_hiddens保存了多个头的信息，输入时拆分出来，为了直接大矩阵乘法去除<span class="hljs-keyword">for</span>循环<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiHeadAttention</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;多头注意力&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span><br><span class="hljs-params">                 num_heads, dropout, bias=<span class="hljs-literal">False</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(MultiHeadAttention, self).__init__(**kwargs)<br>        self.num_heads = num_heads<br>        self.attention = d2l.DotProductAttention(dropout)<br>        self.W_q = nn.Linear(query_size, num_hiddens, bias=bias)<br>        self.W_k = nn.Linear(key_size, num_hiddens, bias=bias)<br>        self.W_v = nn.Linear(value_size, num_hiddens, bias=bias)<br>        self.W_o = nn.Linear(num_hiddens, num_hiddens, bias=bias)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, queries, keys, values, valid_lens</span>):<br>        <span class="hljs-comment"># queries，keys，values的形状:</span><br>        <span class="hljs-comment"># (batch_size，查询或者“键－值”对的个数，num_hiddens)</span><br>        <span class="hljs-comment"># valid_lens　的形状:</span><br>        <span class="hljs-comment"># (batch_size，)或(batch_size，查询的个数)</span><br>        <span class="hljs-comment"># 经过变换后，输出的queries，keys，values　的形状:</span><br>        <span class="hljs-comment"># (batch_size*num_heads，查询或者“键－值”对的个数，</span><br>        <span class="hljs-comment"># num_hiddens/num_heads)</span><br>        queries = transpose_qkv(self.W_q(queries), self.num_heads)<br>        keys = transpose_qkv(self.W_k(keys), self.num_heads)<br>        values = transpose_qkv(self.W_v(values), self.num_heads)<br><br>        <span class="hljs-keyword">if</span> valid_lens <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 在轴0，将第一项（标量或者矢量）复制num_heads次，</span><br>            <span class="hljs-comment"># 然后如此复制第二项，然后诸如此类。</span><br>            valid_lens = torch.repeat_interleave(<br>                valid_lens, repeats=self.num_heads, dim=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># output的形状:(batch_size*num_heads，查询的个数，</span><br>        <span class="hljs-comment"># num_hiddens/num_heads)</span><br>        output = self.attention(queries, keys, values, valid_lens)<br><br>        <span class="hljs-comment"># output_concat的形状:(batch_size，查询的个数，num_hiddens)</span><br>        output_concat = transpose_output(output, self.num_heads)<br>        <span class="hljs-keyword">return</span> self.W_o(output_concat)<br></code></pre></td></tr></table></figure><h4 id="FFN"><a href="#FFN" class="headerlink" title="FFN"></a>FFN</h4><p>基于位置的前馈网络两层 MLP，[b, t, in] -&gt; [b, t, out]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PositionWiseFFN</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;基于位置的前馈网络&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ffn_num_input, ffn_num_hiddens, ffn_num_outputs,</span><br><span class="hljs-params">                 **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(PositionWiseFFN, self).__init__(**kwargs)<br>        self.dense1 = nn.Linear(ffn_num_input, ffn_num_hiddens)<br>        self.relu = nn.ReLU()<br>        self.dense2 = nn.Linear(ffn_num_hiddens, ffn_num_outputs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        <span class="hljs-keyword">return</span> self.dense2(self.relu(self.dense1(X)))<br></code></pre></td></tr></table></figure><h4 id="AddNorm"><a href="#AddNorm" class="headerlink" title="AddNorm"></a>AddNorm</h4><p>残差标准化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddNorm</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;残差连接后进行层规范化&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, normalized_shape, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(AddNorm, self).__init__(**kwargs)<br>        self.dropout = nn.Dropout(dropout)<br>        self.ln = nn.LayerNorm(normalized_shape)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, Y</span>):<br>        <span class="hljs-keyword">return</span> self.ln(self.dropout(Y) + X)<br></code></pre></td></tr></table></figure><h4 id="mask-Mutiattention"><a href="#mask-Mutiattention" class="headerlink" title="mask-Mutiattention"></a>mask-Mutiattention</h4><p>predict时，不能使用未来的信息</p><h4 id="encoderblock"><a href="#encoderblock" class="headerlink" title="encoderblock"></a>encoderblock</h4><p>MultiHeadAttention + addnorm1 + ffn + addnorm2  输入输出维度不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.ones((<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>))<br>valid_lens = torch.tensor([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>])<br>encoder_blk = EncoderBlock(<span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">24</span>], <span class="hljs-number">24</span>, <span class="hljs-number">48</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0.5</span>)<br>encoder_blk.<span class="hljs-built_in">eval</span>()<br>encoder_blk(X, valid_lens).shape = [<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderBlock</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;Transformer编码器块&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span><br><span class="hljs-params">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span><br><span class="hljs-params">                 dropout, use_bias=<span class="hljs-literal">False</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(EncoderBlock, self).__init__(**kwargs)<br>        self.attention = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout,<br>            use_bias)<br>        self.addnorm1 = AddNorm(norm_shape, dropout)<br>        self.ffn = PositionWiseFFN(<br>            ffn_num_input, ffn_num_hiddens, num_hiddens)<br>        self.addnorm2 = AddNorm(norm_shape, dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, valid_lens</span>):<br>        Y = self.addnorm1(X, self.attention(X, X, X, valid_lens))<br>        <span class="hljs-keyword">return</span> self.addnorm2(Y, self.ffn(Y))<br></code></pre></td></tr></table></figure><h4 id="encoder-1"><a href="#encoder-1" class="headerlink" title="encoder"></a>encoder</h4><p>多个block堆叠。embedding + pos_encoding + 多个EncoderBlock</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">encoder = TransformerEncoder(<br>    <span class="hljs-number">200</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">24</span>], <span class="hljs-number">24</span>, <span class="hljs-number">48</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.5</span>)<br>encoder.<span class="hljs-built_in">eval</span>()<br>encoder(torch.ones((<span class="hljs-number">2</span>, <span class="hljs-number">100</span>), dtype=torch.long), valid_lens).shape<br>torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformerEncoder</span>(d2l.Encoder):<br>    <span class="hljs-string">&quot;&quot;&quot;Transformer编码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, key_size, query_size, value_size,</span><br><span class="hljs-params">                 num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,</span><br><span class="hljs-params">                 num_heads, num_layers, dropout, use_bias=<span class="hljs-literal">False</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(TransformerEncoder, self).__init__(**kwargs)<br>        self.num_hiddens = num_hiddens<br>        self.embedding = nn.Embedding(vocab_size, num_hiddens)<br>        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)<br>        self.blks = nn.Sequential()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_layers):<br>            self.blks.add_module(<span class="hljs-string">&quot;block&quot;</span>+<span class="hljs-built_in">str</span>(i),<br>                EncoderBlock(key_size, query_size, value_size, num_hiddens,<br>                             norm_shape, ffn_num_input, ffn_num_hiddens,<br>                             num_heads, dropout, use_bias))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, valid_lens, *args</span>):<br>        <span class="hljs-comment"># 因为位置编码值在-1和1之间，</span><br>        <span class="hljs-comment"># 因此嵌入值乘以嵌入维度的平方根进行缩放，</span><br>        <span class="hljs-comment"># 然后再与位置编码相加。</span><br>        X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))<br>        self.attention_weights = [<span class="hljs-literal">None</span>] * <span class="hljs-built_in">len</span>(self.blks)<br>        <span class="hljs-keyword">for</span> i, blk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.blks):<br>            X = blk(X, valid_lens)<br>            self.attention_weights[<br>                i] = blk.attention.attention.attention_weights<br>        <span class="hljs-keyword">return</span> X<br></code></pre></td></tr></table></figure><h4 id="decoderblock"><a href="#decoderblock" class="headerlink" title="decoderblock"></a>decoderblock</h4><p>需要自己的输入和encoder的输出。输入输出维度不变！</p><p><code>self-MultiHeadAttention + addnorm1 + MultiHeadAttention（编码器解码器注意力） + addnorm2  + fnn + addnorm3</code></p><ul><li>第一次mask-self-attention就是<code>attention1(X, X, X, dec_valid_lens)</code>，dec_valid_lens保证不看后面</li><li>第二次需要用到encoder输出<code>attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoderBlock</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;解码器中第i个块&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span><br><span class="hljs-params">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span><br><span class="hljs-params">                 dropout, i, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(DecoderBlock, self).__init__(**kwargs)<br>        self.i = i<br>        self.attention1 = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout)<br>        self.addnorm1 = AddNorm(norm_shape, dropout)<br>        self.attention2 = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout)<br>        self.addnorm2 = AddNorm(norm_shape, dropout)<br>        self.ffn = PositionWiseFFN(ffn_num_input, ffn_num_hiddens,<br>                                   num_hiddens)<br>        self.addnorm3 = AddNorm(norm_shape, dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, state</span>):<br>        enc_outputs, enc_valid_lens = state[<span class="hljs-number">0</span>], state[<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 训练阶段，输出序列的所有词元都在同一时间处理，</span><br>        <span class="hljs-comment"># 因此state[2][self.i]初始化为None。</span><br>        <span class="hljs-comment"># 预测阶段，输出序列是通过词元一个接着一个解码的，</span><br>        <span class="hljs-comment"># 因此state[2][self.i]包含着直到当前时间步第i个块解码的输出表示</span><br>        <span class="hljs-keyword">if</span> state[<span class="hljs-number">2</span>][self.i] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            key_values = X<br>        <span class="hljs-keyword">else</span>:<br>            key_values = torch.cat((state[<span class="hljs-number">2</span>][self.i], X), axis=<span class="hljs-number">1</span>)<br>        state[<span class="hljs-number">2</span>][self.i] = key_values<br>        <span class="hljs-keyword">if</span> self.training:<br>            batch_size, num_steps, _ = X.shape<br>            <span class="hljs-comment"># dec_valid_lens的开头:(batch_size,num_steps),</span><br>            <span class="hljs-comment"># 其中每一行是[1,2,...,num_steps] 因为X相对于有num_steps个query，后面的query长度更长</span><br>            dec_valid_lens = torch.arange(<br>                <span class="hljs-number">1</span>, num_steps + <span class="hljs-number">1</span>, device=X.device).repeat(batch_size, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            dec_valid_lens = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 自注意力</span><br>        X2 = self.attention1(X, key_values, key_values, dec_valid_lens)<br>        Y = self.addnorm1(X, X2)<br>        <span class="hljs-comment"># 编码器－解码器注意力。</span><br>        <span class="hljs-comment"># enc_outputs的开头:(batch_size,num_steps,num_hiddens)</span><br>        Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)<br>        Z = self.addnorm2(Y, Y2)<br>        <span class="hljs-keyword">return</span> self.addnorm3(Z, self.ffn(Z)), state<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">decoder_blk = DecoderBlock(<span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">24</span>], <span class="hljs-number">24</span>, <span class="hljs-number">48</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>)<br>decoder_blk.<span class="hljs-built_in">eval</span>()<br>X = torch.ones((<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>))<br>state = [encoder_blk(X, valid_lens), valid_lens, [<span class="hljs-literal">None</span>]]<br>decoder_blk(X, state)[<span class="hljs-number">0</span>].shape <span class="hljs-comment"># [2, 100, 24]</span><br></code></pre></td></tr></table></figure><h4 id="decoder-1"><a href="#decoder-1" class="headerlink" title="decoder"></a>decoder</h4><p>embedding + pos_encoding + 多个decoderBlock + dense；decoderBlock需要的state训练时不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformerDecoder</span>(d2l.AttentionDecoder):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, key_size, query_size, value_size,</span><br><span class="hljs-params">                 num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,</span><br><span class="hljs-params">                 num_heads, num_layers, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(TransformerDecoder, self).__init__(**kwargs)<br>        self.num_hiddens = num_hiddens<br>        self.num_layers = num_layers<br>        self.embedding = nn.Embedding(vocab_size, num_hiddens)<br>        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)<br>        self.blks = nn.Sequential()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_layers):<br>            self.blks.add_module(<span class="hljs-string">&quot;block&quot;</span>+<span class="hljs-built_in">str</span>(i),<br>                DecoderBlock(key_size, query_size, value_size, num_hiddens,<br>                             norm_shape, ffn_num_input, ffn_num_hiddens,<br>                             num_heads, dropout, i))<br>        self.dense = nn.Linear(num_hiddens, vocab_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_state</span>(<span class="hljs-params">self, enc_outputs, enc_valid_lens, *args</span>):<br>        <span class="hljs-keyword">return</span> [enc_outputs, enc_valid_lens, [<span class="hljs-literal">None</span>] * self.num_layers]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, state</span>):<br>        X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))<br>        self._attention_weights = [[<span class="hljs-literal">None</span>] * <span class="hljs-built_in">len</span>(self.blks) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">2</span>)]<br>        <span class="hljs-keyword">for</span> i, blk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.blks):<br>            X, state = blk(X, state)<br>            <span class="hljs-comment"># 解码器自注意力权重</span><br>            self._attention_weights[<span class="hljs-number">0</span>][<br>                i] = blk.attention1.attention.attention_weights<br>            <span class="hljs-comment"># “编码器－解码器”自注意力权重</span><br>            self._attention_weights[<span class="hljs-number">1</span>][<br>                i] = blk.attention2.attention.attention_weights<br>        <span class="hljs-keyword">return</span> self.dense(X), state<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">attention_weights</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._attention_weights<br></code></pre></td></tr></table></figure><h4 id="train-1"><a href="#train-1" class="headerlink" title="train"></a>train</h4><p><code>num_hiddens， num_heads</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">num_hiddens, num_layers, dropout, batch_size, num_steps = <span class="hljs-number">32</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">64</span>, <span class="hljs-number">10</span><br>lr, num_epochs, device = <span class="hljs-number">0.005</span>, <span class="hljs-number">200</span>, d2l.try_gpu()<br>ffn_num_input, ffn_num_hiddens, num_heads = <span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">4</span><br>key_size, query_size, value_size = <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span><br>norm_shape = [<span class="hljs-number">32</span>]<br><br>train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps)<br><br>encoder = TransformerEncoder(<br>    <span class="hljs-built_in">len</span>(src_vocab), key_size, query_size, value_size, num_hiddens,<br>    norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,<br>    num_layers, dropout)<br>decoder = TransformerDecoder(<br>    <span class="hljs-built_in">len</span>(tgt_vocab), key_size, query_size, value_size, num_hiddens,<br>    norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,<br>    num_layers, dropout)<br>net = d2l.EncoderDecoder(encoder, decoder)<br>d2l.train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device)<br></code></pre></td></tr></table></figure><h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><p>预测t+1：前t个转为key value，第t个为query</p><h4 id="QA：-2"><a href="#QA：-2" class="headerlink" title="QA："></a>QA：</h4><ol><li>concat特征比加权平均好</li><li>transfomer硬件要求还好，BERT很大</li><li>很多模型只有encoder，如bert</li><li>可以处理图片，抠出一个个patch</li></ol><h3 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h3><p>使用预训练模型提取句子特征，如word2vec(忽略时序)。预训练模型可以不更新，只修改output layer</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003563.png" alt="image-20230523145131209" style="zoom: 33%;" /><p>只有transformer的encoder：<code>block=12 24 hiddensize=768 1024 head=12 16   parameters=110 340M</code>  10亿个词</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul><li>Segment：没有解码器，所以输入输出都输入到encoder，用<sep>分开并且添加额外编码</li><li>Position：可学习</li><li>Token：普通编码</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003564.png" alt="image-20230523150435634"></p><h4 id="训练任务"><a href="#训练任务" class="headerlink" title="训练任务"></a>训练任务</h4><h5 id="带掩码"><a href="#带掩码" class="headerlink" title="带掩码"></a>带掩码</h5><p>transformer是双向的，如何做单向预测？</p><p>带掩码的语言模型：15%将一些词作为<mask>，完形填空</p><p>微调任务时，压根没有没有mask，让模型能在有答案情况下填空：对于mask 80%不变、10%保持、10%替换别的</p><h5 id="下一句子预测"><a href="#下一句子预测" class="headerlink" title="下一句子预测"></a>下一句子预测</h5><p>句子是不是相邻</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003565.png" alt="image-20230523151222497"></p><h4 id="BERT代码"><a href="#BERT代码" class="headerlink" title="BERT代码"></a>BERT代码</h4><p>1.对token添加<cls> <sep></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_tokens_and_segments</span>(<span class="hljs-params">tokens_a, tokens_b=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;获取输入序列的词元及其片段索引&quot;&quot;&quot;</span><br>    tokens = [<span class="hljs-string">&#x27;&lt;cls&gt;&#x27;</span>] + tokens_a + [<span class="hljs-string">&#x27;&lt;sep&gt;&#x27;</span>]<br>    <span class="hljs-comment"># 0和1分别标记片段A和B</span><br>    segments = [<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(tokens_a) + <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> tokens_b <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        tokens += tokens_b + [<span class="hljs-string">&#x27;&lt;sep&gt;&#x27;</span>]<br>        segments += [<span class="hljs-number">1</span>] * (<span class="hljs-built_in">len</span>(tokens_b) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> tokens, segments<br></code></pre></td></tr></table></figure><h5 id="BERTEncoder"><a href="#BERTEncoder" class="headerlink" title="BERTEncoder"></a>BERTEncoder</h5><p>输入tokens，segments [b, t]，返回[b, t, hidden]。Encoder中包含pos_embedding</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERTEncoder</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT编码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, num_hiddens, norm_shape, ffn_num_input,</span><br><span class="hljs-params">                 ffn_num_hiddens, num_heads, num_layers, dropout,</span><br><span class="hljs-params">                 max_len=<span class="hljs-number">1000</span>, key_size=<span class="hljs-number">768</span>, query_size=<span class="hljs-number">768</span>, value_size=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">                 **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(BERTEncoder, self).__init__(**kwargs)<br>        self.token_embedding = nn.Embedding(vocab_size, num_hiddens)<br>        self.segment_embedding = nn.Embedding(<span class="hljs-number">2</span>, num_hiddens)<br>        self.blks = nn.Sequential()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_layers):<br>            self.blks.add_module(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, d2l.EncoderBlock(<br>                key_size, query_size, value_size, num_hiddens, norm_shape,<br>                ffn_num_input, ffn_num_hiddens, num_heads, dropout, <span class="hljs-literal">True</span>))<br>        <span class="hljs-comment"># 在BERT中，位置嵌入是可学习的，因此我们创建一个足够长的位置嵌入参数</span><br>        self.pos_embedding = nn.Parameter(torch.randn(<span class="hljs-number">1</span>, max_len,<br>                                                      num_hiddens))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, tokens, segments, valid_lens</span>):<br>        <span class="hljs-comment"># 在以下代码段中，X的形状保持不变：（批量大小，最大序列长度，num_hiddens）</span><br>        X = self.token_embedding(tokens) + self.segment_embedding(segments)<br>        X = X + self.pos_embedding.data[:, :X.shape[<span class="hljs-number">1</span>], :]<br>        <span class="hljs-keyword">for</span> blk <span class="hljs-keyword">in</span> self.blks:<br>            X = blk(X, valid_lens)<br>        <span class="hljs-keyword">return</span> X<br></code></pre></td></tr></table></figure><h5 id="MaskLM"><a href="#MaskLM" class="headerlink" title="MaskLM"></a>MaskLM</h5><p>对编码器的输出特征encoded_X，在指定位置上pred_positions，提取出该位置特征masked_X去分类</p><p><code>encoded_X：[b, t, hidden]    pred_positions：[b, num_pred]    masked_X：[b, num_pred, hidden]   </code></p><p><code>out: [b, num_pred, vocab_size]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaskLM</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT的掩蔽语言模型任务&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, num_hiddens, num_inputs=<span class="hljs-number">768</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(MaskLM, self).__init__(**kwargs)<br>        self.mlp = nn.Sequential(nn.Linear(num_inputs, num_hiddens),<br>                                 nn.ReLU(),<br>                                 nn.LayerNorm(num_hiddens),<br>                                 nn.Linear(num_hiddens, vocab_size))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, pred_positions</span>):<br>        num_pred_positions = pred_positions.shape[<span class="hljs-number">1</span>]<br>        pred_positions = pred_positions.reshape(-<span class="hljs-number">1</span>)<br>        batch_size = X.shape[<span class="hljs-number">0</span>]<br>        batch_idx = torch.arange(<span class="hljs-number">0</span>, batch_size)<br>        <span class="hljs-comment"># 假设batch_size=2，num_pred_positions=3</span><br>        <span class="hljs-comment"># 那么batch_idx是np.array（[0,0,0,1,1,1]）</span><br>        batch_idx = torch.repeat_interleave(batch_idx, num_pred_positions)<br>        masked_X = X[batch_idx, pred_positions]<br>        masked_X = masked_X.reshape((batch_size, num_pred_positions, -<span class="hljs-number">1</span>))<br>        mlm_Y_hat = self.mlp(masked_X)<br>        <span class="hljs-keyword">return</span> mlm_Y_hat<br></code></pre></td></tr></table></figure><h5 id="NextSentencePred"><a href="#NextSentencePred" class="headerlink" title="NextSentencePred"></a>NextSentencePred</h5><p>对<code>encoded_X[:, 0, :]</code><cls>的特征进行分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NextSentencePred</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT的下一句预测任务&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_inputs, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(NextSentencePred, self).__init__(**kwargs)<br>        self.output = nn.Linear(num_inputs, <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        <span class="hljs-comment"># X的形状：(batchsize,num_hiddens)</span><br>        <span class="hljs-keyword">return</span> self.output(X)<br></code></pre></td></tr></table></figure><h5 id="BERTModel"><a href="#BERTModel" class="headerlink" title="BERTModel"></a>BERTModel</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERTModel</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT模型&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, num_hiddens, norm_shape, ffn_num_input,</span><br><span class="hljs-params">                 ffn_num_hiddens, num_heads, num_layers, dropout,</span><br><span class="hljs-params">                 max_len=<span class="hljs-number">1000</span>, key_size=<span class="hljs-number">768</span>, query_size=<span class="hljs-number">768</span>, value_size=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">                 hid_in_features=<span class="hljs-number">768</span>, mlm_in_features=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">                 nsp_in_features=<span class="hljs-number">768</span></span>):<br>        <span class="hljs-built_in">super</span>(BERTModel, self).__init__()<br>        self.encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape,<br>                    ffn_num_input, ffn_num_hiddens, num_heads, num_layers,<br>                    dropout, max_len=max_len, key_size=key_size,<br>                    query_size=query_size, value_size=value_size)<br>        self.hidden = nn.Sequential(nn.Linear(hid_in_features, num_hiddens),<br>                                    nn.Tanh())<br>        self.mlm = MaskLM(vocab_size, num_hiddens, mlm_in_features)<br>        self.nsp = NextSentencePred(nsp_in_features)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, tokens, segments, valid_lens=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                pred_positions=<span class="hljs-literal">None</span></span>):<br>        encoded_X = self.encoder(tokens, segments, valid_lens)<br>        <span class="hljs-keyword">if</span> pred_positions <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            mlm_Y_hat = self.mlm(encoded_X, pred_positions)<br>        <span class="hljs-keyword">else</span>:<br>            mlm_Y_hat = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 用于下一句预测的多层感知机分类器的隐藏层，0是“&lt;cls&gt;”标记的索引</span><br>        nsp_Y_hat = self.nsp(self.hidden(encoded_X[:, <span class="hljs-number">0</span>, :]))<br>        <span class="hljs-keyword">return</span> encoded_X, mlm_Y_hat, nsp_Y_hat<br></code></pre></td></tr></table></figure><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><ul><li>需要先获得 tokens, segments, is_next ； segments为0、1用于区别句子</li><li>对tokens进行mask替换，返回tokens，positions，positions上原词汇mlm_Y</li><li>pad  和对应 valid_lens。all_mlm_weights0或1用于过滤掉mask中，属于pad的词</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span> (tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X, mlm_Y, nsp_y) <span class="hljs-keyword">in</span> train_iter<br><br>torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 64]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 64]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 10]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 10]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 10]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512]</span>)<br><br>mlm_weights_X <span class="hljs-number">0</span>或<span class="hljs-number">1</span>用于过滤掉<span class="hljs-attribute">mask</span>中，属于pad的词<br></code></pre></td></tr></table></figure><h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>训练是不需要encoder_X,为了提升模型抽取encoder的能力</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">net = d2l.BERTModel(<span class="hljs-built_in">len</span>(vocab), num_hiddens=<span class="hljs-number">128</span>, norm_shape=[<span class="hljs-number">128</span>],<br>                    ffn_num_input=<span class="hljs-number">128</span>, ffn_num_hiddens=<span class="hljs-number">256</span>, num_heads=<span class="hljs-number">2</span>,<br>                    num_layers=<span class="hljs-number">2</span>, dropout=<span class="hljs-number">0.2</span>, key_size=<span class="hljs-number">128</span>, query_size=<span class="hljs-number">128</span>,<br>                    value_size=<span class="hljs-number">128</span>, hid_in_features=<span class="hljs-number">128</span>, mlm_in_features=<span class="hljs-number">128</span>,<br>                    nsp_in_features=<span class="hljs-number">128</span>)<br>devices = d2l.try_all_gpus()<br>loss = nn.CrossEntropyLoss()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_batch_loss_bert</span>(<span class="hljs-params">net, loss, vocab_size, tokens_X,</span><br><span class="hljs-params">                         segments_X, valid_lens_x,</span><br><span class="hljs-params">                         pred_positions_X, mlm_weights_X,</span><br><span class="hljs-params">                         mlm_Y, nsp_y</span>):<br>    <span class="hljs-comment"># 前向传播</span><br>    _, mlm_Y_hat, nsp_Y_hat = net(tokens_X, segments_X,<br>                                  valid_lens_x.reshape(-<span class="hljs-number">1</span>),<br>                                  pred_positions_X)<br>    <span class="hljs-comment"># 计算遮蔽语言模型损失 不计算pad的</span><br>    mlm_l = loss(mlm_Y_hat.reshape(-<span class="hljs-number">1</span>, vocab_size), mlm_Y.reshape(-<span class="hljs-number">1</span>)) *\<br>    mlm_weights_X.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    mlm_l = mlm_l.<span class="hljs-built_in">sum</span>() / (mlm_weights_X.<span class="hljs-built_in">sum</span>() + <span class="hljs-number">1e-8</span>)<br>    <span class="hljs-comment"># 计算下一句子预测任务的损失</span><br>    nsp_l = loss(nsp_Y_hat, nsp_y)<br>    l = mlm_l + nsp_l<br>    <span class="hljs-keyword">return</span> mlm_l, nsp_l, l<br></code></pre></td></tr></table></figure><h4 id="BERT表示文本"><a href="#BERT表示文本" class="headerlink" title="BERT表示文本"></a>BERT表示文本</h4><p>利用BERT获得句子的encoded_X，去进行分类、预测等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_bert_encoding</span>(<span class="hljs-params">net, tokens_a, tokens_b=<span class="hljs-literal">None</span></span>):<br>    tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b)<br>    token_ids = torch.tensor(vocab[tokens], device=devices[<span class="hljs-number">0</span>]).unsqueeze(<span class="hljs-number">0</span>)<br>    segments = torch.tensor(segments, device=devices[<span class="hljs-number">0</span>]).unsqueeze(<span class="hljs-number">0</span>)<br>    valid_len = torch.tensor(<span class="hljs-built_in">len</span>(tokens), device=devices[<span class="hljs-number">0</span>]).unsqueeze(<span class="hljs-number">0</span>)<br>    encoded_X, _, _ = net(token_ids, segments, valid_len)<br>    <span class="hljs-keyword">return</span> encoded_X<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">tokens_a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;crane&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;flying&#x27;</span>]<br>encoded_text = get_bert_encoding(net, tokens_a) [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">128</span>]<br><span class="hljs-comment"># 词元：&#x27;&lt;cls&gt;&#x27;,&#x27;a&#x27;,&#x27;crane&#x27;,&#x27;is&#x27;,&#x27;flying&#x27;,&#x27;&lt;sep&gt;&#x27;</span><br>encoded_text_cls = encoded_text[:, <span class="hljs-number">0</span>, :]  [<span class="hljs-number">1</span>, <span class="hljs-number">128</span>]<br><br>tokens_a, tokens_b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;crane&#x27;</span>, <span class="hljs-string">&#x27;driver&#x27;</span>, <span class="hljs-string">&#x27;came&#x27;</span>], [<span class="hljs-string">&#x27;he&#x27;</span>, <span class="hljs-string">&#x27;just&#x27;</span>, <span class="hljs-string">&#x27;left&#x27;</span>]<br>encoded_pair = get_bert_encoding(net, tokens_a, tokens_b)<br><span class="hljs-comment"># 词元：&#x27;&lt;cls&gt;&#x27;,&#x27;a&#x27;,&#x27;crane&#x27;,&#x27;driver&#x27;,&#x27;came&#x27;,&#x27;&lt;sep&gt;&#x27;,&#x27;he&#x27;,&#x27;just&#x27;, &#x27;left&#x27;,&#x27;&lt;sep&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="QA：-3"><a href="#QA：-3" class="headerlink" title="QA："></a>QA：</h4><ol><li>模型太大？ model分在不同GPU上</li></ol><h3 id="微调BERT"><a href="#微调BERT" class="headerlink" title="微调BERT"></a>微调BERT</h3><p>利用bert对每个词都抽取了特征，我们不需要考虑如何抽取句子特征、词特征了。只需要添加输出层。需要相同Vocab</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003566.png" alt="image-20230523164053828" style="zoom:50%;" /><ul><li><p>句子分类：直接用<cls>的特征，别的也可以但最好cls</p></li><li><p>识别词元是不是特殊词：人名、地名、机构。  对每一个词的特征做二分类</p></li><li><p>问题回答：给出一段话和一个问题。对于一段话中每一个词，预测是不是问题的开始和结束。三分类</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305241003567.png" alt="image-20230523164551697" style="zoom:50%;" /></li></ul><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>只需要用上encoder，hidden是bert中输出到NSP前的处理，这里也用上；相对于替换了NSP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERTClassifier</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, bert</span>):<br>        <span class="hljs-built_in">super</span>(BERTClassifier, self).__init__()<br>        self.encoder = bert.encoder<br>        self.hidden = bert.hidden<br>        self.output = nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs</span>):<br>        tokens_X, segments_X, valid_lens_x = inputs<br>        encoded_X = self.encoder(tokens_X, segments_X, valid_lens_x)<br>        <span class="hljs-keyword">return</span> self.output(self.hidden(encoded_X[:, <span class="hljs-number">0</span>, :]))<br></code></pre></td></tr></table></figure><h4 id="QA-1"><a href="#QA-1" class="headerlink" title="QA:"></a>QA:</h4><ol><li>YOLO基础效果不好，但加了大量trick细节</li><li>通过蒸馏十分之一大小，但精度不会下降很多</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
      <category>动手学深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 - jyy.md</title>
    <link href="/2023/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20jyy/"/>
    <url>/2023/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20jyy/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305141734125.png" alt="image-20230512154440672"></p><p>00 01 10 00 01 10</p><h4 id="源代码角度"><a href="#源代码角度" class="headerlink" title="源代码角度"></a>源代码角度</h4><p>同时我们也可以用C语言实现</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305141734343.png" alt="image-20230512155633763"></p><p>状态：内存中的所有东西，全部栈帧</p><p>使用栈模拟递归</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305141734388.png" alt="image-20230512161116475"></p><h4 id="二进制角度"><a href="#二进制角度" class="headerlink" title="二进制角度"></a>二进制角度</h4><ul><li>状态：内存 + 寄存器</li><li>初始状态：</li><li>迁移：一条01指令</li></ul><p>任何的程序都需要退出，也就是结束。因此需要特别的指令 <code>syscall</code> 把现在的状态交给操作系统</p><p>程序 &#x3D;  普通计算 + <code>syscall</code></p><p>实现与操作系统中别的对象交互</p><ul><li>读写文件  如果有权限，操作系统把状态写入程序的M, R</li><li>改变进程 杀死程序</li></ul><p>如何构造一个<code>printf(&quot;hello world&quot;)</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305141734432.png" alt="image-20230512171448873"></p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li>收编了所有对象，实现霸主地位</li><li>管理多个状态机，根据权限访问。打开文件，屏幕显示</li></ul><p>在程序眼里，操作系统就是<code>syscall</code>，strace a.out展示用到的所有的系统调用</p><p>c语言的第一条程序是什么，谁定义的，能不能修改</p><p>计算机没有玄学，一切都建立在确定的机制上。bug只要能复现，就能解决</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="多处理器编程"><a href="#多处理器编程" class="headerlink" title="多处理器编程"></a><a href="http://jyywiki.cn/OS/2022/slides/3.slides">多处理器编程</a></h3><p><strong>1.放弃原子性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> balance = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Alipay_withdraw</span><span class="hljs-params">(<span class="hljs-type">int</span> amt)</span> &#123;<br>  <span class="hljs-keyword">if</span> (balance &gt;= amt) &#123;<br>    balance -= amt;<br>    <span class="hljs-keyword">return</span> SUCCESS;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> FAIL;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) sum++;<br></code></pre></td></tr></table></figure><p><code>printf(&quot;a&quot;) </code>为什么不会报错？带了锁</p><p>互斥和原子性是本学期的重要主题</p><p> <strong>2.顺序丧失</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">-O1: R[eax] = sum; R[eax] += N; sum = R[eax]<br>    O1保证最终一致，如果要写入多次，直接一次性写入<br>    最终读出<span class="hljs-number">100000000</span><br>    <br>-O2: sum += N;  <span class="hljs-number">200000000</span><br>    <br>另一个例子： 系统默认done不会改变了<br>    <span class="hljs-keyword">while</span> (!done);<br>    <span class="hljs-comment">// would be optimized to</span><br>    <span class="hljs-keyword">if</span> (!done) <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>3.丧失可见性</strong></p><p>理论上输出 01 10 11, 但其实00也有输出</p><p>处理器也是一个编译器，一条指令拆分多个uops</p><p>如果想写入x时未命中，print就可以先执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">T1</span><span class="hljs-params">()</span> &#123;<br>  x = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> : : <span class="hljs-string">&quot;memory&quot;</span>)</span>; <span class="hljs-comment">// compiler barrier</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;y = %d\n&quot;</span>, y);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">T2</span><span class="hljs-params">()</span> &#123;<br>  y = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> : : <span class="hljs-string">&quot;memory&quot;</span>)</span>; <span class="hljs-comment">// compiler barrier</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %d\n&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="理解并发程序执行"><a href="#理解并发程序执行" class="headerlink" title="理解并发程序执行"></a><a href="http://jyywiki.cn/OS/2022/slides/4.slides">理解并发程序执行</a></h3><p>在<strong>共享内存</strong>实现并发时，一个反例   <code>get set</code>不是原子操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> locked = UNLOCK;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">critical_section</span><span class="hljs-params">()</span> &#123;<br>retry:<br>  <span class="hljs-keyword">if</span> (locked != UNLOCK) &#123;<br>    <span class="hljs-keyword">goto</span> retry;<br>  &#125;<br>  locked = LOCK;<br><br>  <span class="hljs-comment">// critical section</span><br><br>  locked = UNLOCK;<br>&#125;<br></code></pre></td></tr></table></figure><p>证明：直接画出状态机表达出全部状态。棋子代表：我想上厕所；门上贴的人代表着：谁能上厕所</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305141734471.png" alt="image-20230514163743735"></p><p>使用程序去遍历出全部的状态  Model Checker</p><p>没有工具（编程、测试、调试），不做系统</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>穿越计算机的迷雾</title>
    <link href="/2023/05/12/%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE/"/>
    <url>/2023/05/12/%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="bit入门"><a href="#bit入门" class="headerlink" title="bit入门"></a>bit入门</h3><p>如何用电来表达一个数字：</p><ul><li>1v为1  、2v为2… 但难以计算到底是几v</li><li>开关，0代表无 1代表有。二进制</li></ul><p>如何对二进制实现加法</p><ul><li>对于每一位<ul><li>两个输入一个进位</li><li>一个输出一个进位</li></ul></li><li>多位串联起来<ul><li>低位的进位传递给高位</li></ul></li></ul><h3 id="电与磁"><a href="#电与磁" class="headerlink" title="电与磁"></a>电与磁</h3><p>电能生磁，通过电流通断规律控制衔铁臂上下运动画出莫尔斯电报</p><p>​距离太远？继电器实现不同回路的继电</p><p>磁生电，线圈切割磁感线产生电流：<strong>话筒</strong>  声波-&gt;电流     <strong>扬声器</strong> 电流-&gt;声波   二者可以是同一个东西</p><p>为什么是交流电</p><ul><li>产生更容易，圆周运动</li><li>通过变压器轻松实现升降压，而高压传输损耗更小</li></ul><h3 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h3><ul><li><a href="https://fasionchan.com/computer/logic-gate/relay-logic-gate/">用电磁继电器实现逻辑门</a> 非(1)、与(2)、或(2)、与非(2)、异或门(<code>!AB+A!B</code>两非两与一或&#x3D;8、或 与非 与 &#x3D; 6)</li></ul><p>同门电路<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450617.png" alt="image-20230511153924305"></p><p>与非<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450618.png" alt="image-20230511154215546" style="zoom: 67%;" /></p><p>异或门</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450619.png" alt="image-20230511152444206" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450620.png" alt="image-20230511152733412"></p><ul><li><p>对全加器列出真值表，化简出逻辑表达式，并使用继电器构造出来，22个-&gt;18个  1940年计数器</p><p><code>S = A ⊕ B ⊕ Cin</code></p><p><code>Cout = (A B) + (Cin (A ⊕ B))</code></p></li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450621.png" alt="image-20230511151739600" style="zoom:80%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450622.png" alt="image-20230511172429980"></p><p>至此我们得到了<strong>运算器</strong></p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>为了记录下1bit！！！(后面采用电容存储1bit(DARM 内存；晶体管做触发器SRAM cache))</p><p>二极管：加热的灯丝可以放出电子</p><p>三极管：中间增加一个栅极，可以截断或者放大</p><p><strong>振荡器：</strong>把一个非门的输出接到输入</p><h4 id="触发器："><a href="#触发器：" class="headerlink" title="触发器："></a><strong>触发器：</strong></h4><p>​输出永远相反，而当输入只有一个1时，可以改变输出状态(输入期望也相反)   问题：我只想在想记录时记录</p><p>​输入S置为一后，Q一直会保持1，R(reset)可以将Q置零。都为1不稳定</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450623.png" alt="image-20230511163751743"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450624.png" alt="image-20230511164109382" style="zoom:67%;" /></p><h4 id="D触发器："><a href="#D触发器：" class="headerlink" title="D触发器："></a><strong>D触发器：</strong></h4><p>​增加一个控制端，实现1bit的保存。CP为1时，Q&#x3D;D保存输入，CP为0时，忽略</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450625.png" alt="image-20230511165325821"></p><h4 id="上升沿D触发器："><a href="#上升沿D触发器：" class="headerlink" title="上升沿D触发器："></a><strong>上升沿D触发器</strong>：</h4><p>​CP为上升信号时，触发保存。对于继电器，一次记录可能需要延时1s</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450627.png" alt="image-20230511165731250"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450628.png" alt="image-20230511170247155"></p><h4 id="走马灯：移位寄存器"><a href="#走马灯：移位寄存器" class="headerlink" title="走马灯：移位寄存器"></a><strong>走马灯：移位寄存器</strong></h4><p>​（移位寄存器）振荡器 + 循环连接的上升沿触发器，其中有一个1；每震荡一次1就传递给下一个。<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450629.png" alt="image-20230511170124003"></p><h4 id="寄存器：多个上升D"><a href="#寄存器：多个上升D" class="headerlink" title="寄存器：多个上升D"></a><strong>寄存器：</strong>多个上升D</h4><p>多个CP就可以构成寄存器存储数据</p><h4 id="T触发器："><a href="#T触发器：" class="headerlink" title="T触发器："></a><strong>T触发器：</strong></h4><p>​反转</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450630.png" alt="image-20230511170310516"></p><p>​串联： 二进制计数器，计算上升沿的数量</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450631.png" alt="image-20230511172102638"></p><p>至此我们得到了寄存器，能够缓存一部分数据。</p><p>继电器  -&gt;电子管  -&gt; 晶体管  -&gt;  集成电路</p><h3 id="一连串加法"><a href="#一连串加法" class="headerlink" title="一连串加法"></a>一连串加法</h3><p>之前的加法器只能保证两个输入得到一个输出，但不能连续计算。结合寄存器优化！！</p><p>1.基本思想：使用寄存器保存值，一个数为直接输入，另一个为RA寄存器的值。加法器会<strong>实时</strong>计算两个输入的值</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450632.png" alt="image-20230511190342020"></p><p>2.为了实现连续计算，加法器的输出要直接接到输入</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450633.png" alt="image-20230511190457135"></p><p>​<strong>问题：</strong>共用一条线（<strong>总线</strong>）会冲突，需要添加控制实现轮流使用总线</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450634.png" alt="image-20230511190610102" style="zoom:67%;" /><p>3.添加上总线控制GA，GB，总线控制是<strong>按住</strong>，而寄存器装载是上升沿<strong>按下松开</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450635.png" alt="image-20230511190438862"></p><p>10+3+2</p><p>第一步为装载，2~3为相加</p><ol><li>扳出10（在实际中，取数也是一个自动操作 后面实现），按住GA，延时后按下RA，装载输入1的值为10  </li><li>扳出3， 按住GA，这时候加法器已经得到了实时输出，按下TR，装载输出到寄存器</li><li>再按住GB，代表输出需要占用总线，数据传输到RA时按下RA装载结果，实现一次计算</li><li>重复2过程，扳出数字2…</li></ol><p>4.添加一个<strong>控制器</strong>控制，列出真值表，即可得到控制器电路（K的状态相当于指令，控制器电路需要解析指令）。延时问题后面解决</p><ul><li>上面两个为模式，选择一个</li><li>下面两个为当前模式下的操作，k0~x只有一个为1</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450636.png" alt="image-20230511195305178"></p><p>5.控制器优化，只使用一个控制</p><ol><li><p>既然操作t只有一个为1，那么用循环移位寄存器RR实现</p></li><li><p>延时问题，我现在先让G(控制线先输出)，而数据寄存器R需要再按下开关时才触发</p><p>   松开开关代表切换操作，松开状态下数据参数门打开</p><p>   松开后再按下代表上一个数据已经传过来了，要用快点用，按下瞬间装载数据</p><p>也就是松开实现模式切换，按下实现数据保存</p></li></ol><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450637.png" alt="image-20230511195839855"></p><h3 id="全自动加法"><a href="#全自动加法" class="headerlink" title="全自动加法"></a>全自动加法</h3><p>现在还需要手动将数据输入，能不能一次性全部输入：需要先存储  <strong>存储器！！</strong></p><p>单bit存储：输入和输出共用一条线，通过信号控制输入还是输出，G就相当于总线控制(输出器)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450638.png" alt="image-20230511193329800"></p><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>把多个bit连一起就可以组成一个大数（一行），多个数就可以组成存储器，需要地址译码器选择哪个数据(门牌号)</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450639.png" alt="image-20230511193502167" style="zoom:67%;" /><p>封装一下：输入：地址引线 RW ， 输出n个bit</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450640.png" alt="image-20230511193521662" style="zoom:50%;" /><h4 id="磁芯"><a href="#磁芯" class="headerlink" title="磁芯"></a>磁芯</h4><p>W：不同的电流方向导致不同的磁场方向</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450641.png" alt="image-20230511193659896" style="zoom:50%;" /><p>R：写入一个0，如果原来是0，读出线上电压变化很小。如果原来是1，磁场变化导致读出线上感应电压大</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450642.png" alt="image-20230511193820128" style="zoom:50%;" /><p>1949年10月21磁芯存储器专利</p><h4 id="自动取数"><a href="#自动取数" class="headerlink" title="自动取数"></a>自动取数</h4><p>需要一个计数器ACC，AR寄存计数器的值<strong>（地址寄存器）</strong>，DR寄存数据<strong>（数据寄存器）</strong></p><ol><li>按下K<del>AR</del>锁存当前地址</li><li>按住K<del>RD</del>读取数据，同时按下KDR寄存数据</li><li>按下K<del>AC</del>实现地址增加</li></ol><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450643.png" alt="image-20230511201809307"></p><p>同样使用一个循环移位1器和译码器实现上面的逻辑结构，至此按下三下即可取出一个数据到DR寄存器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450644.png" alt="image-20230511202034724"></p><h4 id="连接加法器"><a href="#连接加法器" class="headerlink" title="连接加法器"></a>连接加法器</h4><p>加法器包含2个操作，存储器包含三个，一共五个</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450645.png" alt="image-20230511202615465"></p><p>将相加还是装载添加到指令中，指令也是从存储器中取，指令通过<strong>EC解析</strong>后，翻译出当前的任务，反过来<strong>影响译码器</strong>，也就是告诉计算机进行的下一步操作。IR + EC + 译码器相当于是控制器</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450646.png" alt="image-20230511203156283" style="zoom:50%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450647.png" alt="image-20230511203046934"></p><p>现代的指令中，数据可以直接包含在指令中。原来的AC更像是现代中的PC指针，指向指令的位置</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450648.png" alt="image-20230511203602817"></p><p>最后，把手动按下K换成一个振荡器，即可实现全自动。需要添加一个中止指令，代表程序结束了</p><p>如何处理进位？额外产生一个进位标志来影响控制器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450649.png" alt="image-20230512122031198"></p><h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><p>SRAM：使用晶体管构建触发器，形成存储器，SRAM，但太贵了6个晶体管一个bit，只用来做cache</p><p>DRAM：使用电容和晶体三极管，2ms刷新一次DRAM，做内存</p><p>ROM：一开始只读，然后可擦除。U盘、固态硬盘</p><p>外存：磁芯 —&gt;  磁盘(机械硬盘 磁头+ 磁道 + 扇区) —&gt;  固态硬盘</p><p>流水线：充分利用CPU和内存，错开执行 取指 译码 运算 写回操作</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450650.png" alt="image-20230512125603868"></p><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>CPU从哪里读取数据：IO接口</p><p>什么时候去读：CPU不知道IO接口到底有没有数据</p><ul><li>不停的读：CPU不能干别的事情了</li><li>定时询问</li><li>中断：中断向量号表示谁请求了中断，再根据中断向量表转到相应中断处理逻辑</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B站秒杀项目</title>
    <link href="/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="B站秒杀项目"><a href="#B站秒杀项目" class="headerlink" title="B站秒杀项目"></a>B站秒杀项目</h1><p><a href="https://www.bilibili.com/video/BV1sf4y1L7KE">视频</a></p><ul><li>前后端结合项目，两种处理页面方式，二者对比可以看orderDetail页面</li><li>前端页面在template下，通过controller返回访问，并<code>model.add添加数据</code>。<code>h:text=&quot;$&#123;goods.goodsName&#125;&quot;</code>区数据， 不可直接访问</li><li>在static下的页面可直接访问，并在页面加载时ajax请求返回json数据，<code>$(&quot;#goodsName&quot;).text(goods.goodsName);</code>根据id注入数据。（代码中的方式，相当于静态化了，视频中一开始是上面的方式，后面才做的静态化）</li></ul><p>秒杀的接口有三个，先在goodsdetail中启用doSeckill1</p><ul><li>doSeckill1:  对应到 <strong>P43</strong>，         update排他+唯一索引实现秒杀(没有做order页面静态化)</li><li>doSeckill2：对应到 <strong>P53</strong>，         order界面静态化 +  redis预减库存 + 内存标记 + MQ</li><li>doSeckill ：最终秒杀方案          一些安全上的优化</li></ul><p>对应到发起请求界面static\goodsDetail.html 52~67行</p><h2 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h2><ol><li>项目框架搭建<ol><li>SpringBoot环境搭建</li><li>集成Thymeleaf,RespBean</li><li>MyBatis</li></ol></li><li>分布式会话<ol><li>用户登录<ol><li>设计数据库</li><li>明文密码二次MD5加密</li><li>参数校验+全局异常处理</li></ol></li><li>共享Session<ol><li>SpringSession</li><li>Redis</li></ol></li></ol></li><li>功能开发<ol><li>商品列表</li><li>商品详情</li><li>秒杀</li><li>订单详情</li></ol></li><li>系统压测<ol><li>JMeter</li><li>自定义变量模拟多用户</li><li>JMeter命令行的使用</li><li>正式压测<ol><li>商品列表</li><li>秒杀</li></ol></li></ol></li><li>页面优化<ol><li>页面缓存+URL缓存+对象缓存</li><li>页面静态化，前后端分离</li><li>静态资源优化</li><li>CDN优化</li></ol></li><li>接口优化<ol><li>Redis预减库存减少数据库的访问</li><li>内存标记减少Redis的访问</li><li>RabbitMQ异步下单<ol><li>SpringBoot整合RabbitMQ</li><li>交换机</li></ol></li></ol></li><li>安全优化<ol><li>秒杀接口地址隐藏</li><li>算术验证码</li><li>接口防刷</li></ol></li><li>主流的秒杀方案</li></ol><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><table><thead><tr><th>技术</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>Spring Boot</td><td>2.6.4</td><td></td></tr><tr><td>MySQL</td><td>8</td><td></td></tr><tr><td><a href="https://github.com/baomidou/generator">MyBatis Plus</a></td><td>3.5.1</td><td></td></tr><tr><td>Swagger2</td><td>2.9.2</td><td>Swagger-models2.9.2版本报错，使用的是1.5.22</td></tr><tr><td><a href="https://doc.xiaominfo.com/">Kinfe4j</a></td><td>2.0.9</td><td>感觉比Swagger UI漂亮的一个工具，访问地址是ip:端口&#x2F;doc.html</td></tr><tr><td>Spring Boot Redis</td><td></td><td></td></tr></tbody></table><p>快（高性能） 准（一致性） 稳（高可用）</p><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>spring 模板，并添加相应依赖，再添加mybatisplus</p><p>配置mybatis-plus  datasource  log</p><p>创建controller service mapper 和mapper.xml， @MapperScan Dao层</p><p>新建测试接口测试</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>创建数据库表以及mapper service controller层</p><p>​pass  &#x3D;  MD5(MD5(pass名为+salt) + salt2)，前端传过来的时候也加密一次。这里salt2是存在数据库里的</p><p>创建一个项目作为逆向生成工具项目，勾选spring web，添加mybatis plus，官网代码生成器</p><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>&#x2F;doLogin</p><p>导入登录界面，前端传密码前用md5加密一下</p><p>添加通用返回类以及枚举对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RespBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title function_">success</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RespBean</span>(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RespBeanEnum</span> &#123;<br>    <span class="hljs-comment">//通用</span><br>    SUCCESS(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;SUCCESS&quot;</span>),<br>    ERROR(<span class="hljs-number">500</span>, <span class="hljs-string">&quot;服务端异常&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>校验在service中，还可以导入<code>spring-boot-starter-validation</code>包然后通过注解<code>@NotNull</code>实现校验。</p><ul><li><p>service如果出现异常，抛出并且<code>全局异常处理</code></p></li><li><p>登录成功后存一个uuid到session，并用cookie(直接返回也可以)返回给前端，前端每次都带上这个；或者返回一个token，前端每次携带</p></li><li><p>添加<code>spring-session-data-redis</code>依赖后可以将session自动存入redis中实现分布式session，</p></li><li><p>或者直接存数据到redis, key为uuid，通过cookie传来。之后相当于每次<strong>通过uuid拿到用户信息</strong>。导入<code>redis</code>包，配置 ip port等，配置类实现redis序列化，object序列化为json</p></li><li><p>使用配置MVC，继承 <code>WebMvcConfigurer</code>实现mvc的配置</p><p>​配置自定义参数配置， 每次取出user传入参数（这里只做了取出参数User，没有拦截请求）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903365.png" alt="image-20230315100229300"></p><p>​    还可以配置拦截器，添加拦截器，拦截哪些请求。（也可以拦截器直接实现参数，自己代码）</p></li></ul><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><p><strong>界面</strong>：商品列表 商品详情 订单 </p><p><strong>表</strong>：商品表 订单表 秒杀商品表（秒杀活动很多，添加一个标识字段不合适）  秒杀订单表</p><p><code>秒杀表</code>：商品ID、秒杀库存、开始结束时间</p><h3 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h3><p>名称 图片 价格 秒杀价 秒杀库存</p><p>由于需要显示的数据包含<code>商品表</code>和<code>秒杀商品表</code>，添加vo继承商品表添加额外信息</p><p><code>toList</code>接口返回商品列表，还需要添加<strong>mvc静态资源映射</strong> ：<code>addResourceHandlers</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903366.png" alt="image-20230307190839362"></p><h3 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h3><p>需要知道秒杀是否开始结束，后端通过时间判断返回给前端一个状态（未开始、进行中、已结束）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903367.png" alt="image-20230307193103679"></p><h3 id="秒杀功能"><a href="#秒杀功能" class="headerlink" title="秒杀功能"></a>秒杀功能</h3><p>&#x2F;doSeckill1  传统秒杀</p><p>传入user，goodsId</p><ul><li>判断该goodsId是否还有库存，库存是看秒杀商品表， <code>进一步：redis预减</code></li><li>判断该userId是否购买过goodId（查看秒杀订单表）：&#x3D;&#x3D;优化：查询redis&#x3D;&#x3D;</li><li>都没问题时，减库存，生成订单，生成秒杀订单          <code>进一步：加入队列</code></li></ul><p>代码中，前端页面需要将接口改为doSeckill1</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>建表，需要额外秒杀商品表（价格、库存、开始结束时间）、秒杀订单（商品id、订单id）</li><li>登录，存入信息到redis，key为时间戳，访问通过cookie携带</li><li>全局异常处理处理业务异常，拦截器拦截未登录用户（cookie时间戳不合理），静态资源配置</li><li>商品列表、商品详情页，秒杀功能</li></ul><h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>jmeter</p><ul><li>QPS：每秒请求次数</li><li>TPS：每秒事务（吞吐量）次数</li><li>一个页面一个TPS可能多次QPS</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903368.png" alt="image-20230314094536441"></p><p>但windos和linux相差可能很多</p><p><strong>配置mysql：</strong>为了安全性创建新用户xx，打开阿里云安全组，关闭防火墙</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">CREATE USER &#x27;xx&#x27;@&#x27;%&#x27; IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br>grant <span class="hljs-attribute">all</span> on *.* <span class="hljs-selector-tag">to</span> &#x27;xx&#x27;@&#x27;%&#x27;;<br><br>sudo firewall-cmd <span class="hljs-attr">--list-ports</span><br>sudo firewall-cmd <span class="hljs-attr">--add-port</span>=<span class="hljs-number">3306</span>/tcp <span class="hljs-attr">--permanent</span><br>sudo firewall-cmd <span class="hljs-attr">--reload</span><br></code></pre></td></tr></table></figure><p><strong>配置redis</strong>  (使用docker)，并配置远程访问以及持久化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"># 持久化<br>mkdir -<span class="hljs-selector-tag">p</span> /root/docker/redis/data<br>mkdir -<span class="hljs-selector-tag">p</span> /root/docker/redis/conf<br>vi /root/docker/redis/conf/redis<span class="hljs-selector-class">.conf</span><br>    # bind <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br>    protected-mode no<br>    appendonly yes<br>requirepass <span class="hljs-number">123123</span><br><br>docker run <span class="hljs-attr">--name</span> my_redis -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -v /root/docker/redis/data:/data -v /root/docker/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf <br><br>redis-server /etc/redis/redis.conf：在容器内执行的命令，启动 Redis 服务，并使用 /etc/redis/redis.conf 作为配置文件。<br><br></code></pre></td></tr></table></figure><p>安装jmeter，配置encodin，导入配置，放到bin目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./jmeter.sh -n -t first.jmx -l result.jtl<br>result.jtl 拿到win 聚合报告下查看<br></code></pre></td></tr></table></figure><p>部署java 到docker容器中,但我mysql redis都装在宿主机，需要合并网络不好访问，所以还是部署出来（或者用dockercompose部署）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"># 使用 openjdk 作为基础镜像<br><span class="hljs-selector-tag">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-alpine<br><br># 设置工作目录<br>WORKDIR /app<br><br># 将打包好的jar复制到容器中<br>COPY target/seckill-demo-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar /app/seckill-demo-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar<br><br># 暴露应用程序端口，起提示作用<br>EXPOSE <span class="hljs-number">8080</span><br><br># 启动应用程序<br>CMD [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app/seckill-demo-0.0.1-SNAPSHOT.jar&quot;</span>]<br><br>docker build -t myapp:v1 .<br>docker run -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> myapp:v1<br></code></pre></td></tr></table></figure><p><strong>问题</strong>：postman可以携带cookie请求成功，但浏览器不可以（跨域）</p><p>​现在没有拦截未登录用户，如果未携带cookie会导致User空指针异常</p><p><strong>小结</strong></p><ul><li>本地项目数据库、redis都用云的，并打包一份项目放到云上</li><li>云上部署，本地运行压测程序进行压测（标准应该云上压测，但比较麻烦）</li></ul><h3 id="配置文件导入多用户"><a href="#配置文件导入多用户" class="headerlink" title="配置文件导入多用户"></a>配置文件导入多用户</h3><ul><li><p>再创建一个用户，登录后把uuid保存下来，放到文件里逗号分隔</p></li><li><p>csv数据文件设置 <strong>定义</strong>变量名称<code>userTicket</code>, <code>$&#123;userTicket&#125;</code> 取出</p></li><li><p>测试&#x2F;user&#x2F;info接口，看下是不是 <strong>返回不同用户</strong></p></li><li><p>商品列表：5000 10 ：460</p></li></ul><p>生成100个用户，并且登录返回ticket,这里也可以生成用户用java，请求用python</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/createuser&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;压测创建配置文件&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">CreateUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        List&lt;TUser&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//生成用户</span><br><span class="hljs-comment">//        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="hljs-comment">//            TUser tUser = new TUser();</span><br><span class="hljs-comment">//            tUser.setId(1233L + i);</span><br><span class="hljs-comment">//            tUser.setNickname(&quot;user&quot; + i);</span><br><span class="hljs-comment">//            tUser.setSalt(&quot;1a2b3c&quot;);</span><br><span class="hljs-comment">//            tUser.setPassword(&quot;05314c6fbe1d0cdb5eab4e80f1bda30a&quot;);</span><br><span class="hljs-comment">//            list.add(tUser);</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        tUserService.saveBatch(list);</span><br><span class="hljs-comment">//        System.out.println(&quot;create user&quot;);</span><br><br>        <span class="hljs-comment">//读取用户</span><br>        list = tUserService.list();<br><br>        <span class="hljs-comment">//登录，生成UserTicket</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">urlString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://localhost:8080/login/doLogin&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\13000\\Desktop\\config.txt&quot;</span>);<br>        <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>            file.delete();<br>        &#125;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;rw&quot;</span>);<br>        randomAccessFile.seek(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-type">TUser</span> <span class="hljs-variable">tUser</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(urlString);<br>            <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">httpURLConnection</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();<br>            httpURLConnection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>            httpURLConnection.setDoOutput(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> httpURLConnection.getOutputStream();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mobile=&quot;</span> + tUser.getId() + <span class="hljs-string">&quot;&amp;password=c38dc3dcb8f0b43ac8ea6a70b5ec7648&quot;</span>;<br>            outputStream.write(params.getBytes());<br>            outputStream.flush();<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> httpURLConnection.getInputStream();<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> ((len = inputStream.read(buff)) &gt;= <span class="hljs-number">0</span>) &#123;<br>                byteArrayOutputStream.write(buff, <span class="hljs-number">0</span>, len);<br>            &#125;<br>            inputStream.close();<br>            byteArrayOutputStream.close();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">respone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteArrayOutputStream.toByteArray());<br>            <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>            <span class="hljs-type">RespBean</span> <span class="hljs-variable">respBean</span> <span class="hljs-operator">=</span> mapper.readValue(respone, RespBean.class);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">userTicket</span> <span class="hljs-operator">=</span> (String) respBean.getObject();<br>            System.out.println(<span class="hljs-string">&quot;create userTicket:&quot;</span> + tUser.getId());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> tUser.getId() + <span class="hljs-string">&quot;,&quot;</span> + userTicket;<br>            randomAccessFile.seek(randomAccessFile.length());<br>            randomAccessFile.write(row.getBytes());<br>            randomAccessFile.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;write to file :&quot;</span> + tUser.getId());<br>        &#125;<br>        randomAccessFile.close();<br>        System.out.println();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="测试秒杀接口"><a href="#测试秒杀接口" class="headerlink" title="测试秒杀接口"></a>测试秒杀接口</h3><p>&#x2F;doSeckill2</p><p>存在超卖问题！！</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="1-对象缓存redis"><a href="#1-对象缓存redis" class="headerlink" title="1.对象缓存redis"></a>1.对象缓存redis</h3><p>通过uuid缓存User对象，数据跟新后要删除redis</p><h3 id="2-页面缓存redis"><a href="#2-页面缓存redis" class="headerlink" title="2.页面缓存redis"></a>2.页面缓存redis</h3><p>把整个页面缓存到redis </p><p>​本来是<code>return ”goodsList“</code> 返回页面   - - 》》优化成 <code>渲染出整个页面</code>再返回，并缓存整个页面。<code>toList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/toList&quot;, produces = &quot;text/html;charset=utf-8&quot;, method = RequestMethod.GET)</span><br><span class="hljs-meta">@ResponseBody</span> <span class="hljs-comment">// 之前是返回字符串走mvc，现在是直接返回html文本</span><br><br>    <span class="hljs-comment">// 先看redis有没有</span><br>    <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> (String) valueOperations.get(<span class="hljs-string">&quot;goodsList&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(html)) &#123;<br>        <span class="hljs-keyword">return</span> html;<br>    &#125;<br>    <span class="hljs-comment">// 数据还是先放到model</span><br>    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    model.addAttribute(<span class="hljs-string">&quot;goodsList&quot;</span>, itGoodsService.findGoodsVo());<br>    <span class="hljs-comment">// 手动渲染goodsList这个界面</span><br>    <span class="hljs-type">WebContext</span> <span class="hljs-variable">webContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebContext</span>(request, response, request.getServletContext(), request.getLocale(), model.asMap());<br>    html = thymeleafViewResolver.getTemplateEngine().process(<span class="hljs-string">&quot;goodsList&quot;</span>, webContext);<br><br>    <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(html)) &#123;<br>        valueOperations.set(<span class="hljs-string">&quot;goodsList&quot;</span>, html, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <span class="hljs-keyword">return</span> html;<br></code></pre></td></tr></table></figure><h3 id="3-页面静态化"><a href="#3-页面静态化" class="headerlink" title="3.页面静态化"></a>3.页面静态化</h3><p>前后端分离</p><ul><li>静态页面放到static下，可以直接&#x2F;path.html访问，加载页面时请求返回json数据 <code>goodsDetail2</code> -&gt; <code>detail</code></li><li>之前跳转是<code>/goods/toDetail?goodsId=1</code>访问接口，现在是<code>/Detail.html?goodsId=1</code>直接访问页面，但加载页面时多一步ajax请求数据</li><li>前端加载数据 根据id注入: <code>$(&quot;#goodsName&quot;).text(goodsVo.goodsName); </code>  本来是Thymeleaf <code>th:text= &quot;$&#123;goodsVo.goodname&#125;&quot;</code></li></ul><p>orderDetial页面同理：</p><ul><li>原来发起doseckill1请求，成功加载数据return detaii跳转页面，失败返回到错误页面（代码就是这样）</li><li>现在发起doseckill2请求，成功后弹框问是否跳转到static下的detaii.html，然后再发起ajax请求加载detail</li></ul><h3 id="4-静态资源缓存"><a href="#4-静态资源缓存" class="headerlink" title="4.静态资源缓存"></a>4.静态资源缓存</h3><p>配置后static下的<code>goodsDetail.html</code>将被缓存，</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment">#静态资源处理</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-comment">#启动默认静态资源处理，默认启动</span><br>    <span class="hljs-attr">add-mappings:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">cache:</span><br>      <span class="hljs-attr">cachecontrol:</span><br>        <span class="hljs-comment">#缓存响应时间，单位秒</span><br>        <span class="hljs-attr">max-age:</span> <span class="hljs-number">3600</span><br>    <span class="hljs-attr">chain:</span><br>      <span class="hljs-comment">#资源配链启动缓存，默认启动</span><br>      <span class="hljs-attr">cache:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启动资源链，默认禁用</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启用压缩资源（gzip，brotil）解析，默认禁用</span><br>      <span class="hljs-attr">compressed:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启用h5应用缓存，默认禁用</span><br>      <span class="hljs-attr">html-application-cache:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">static-locations:</span> <span class="hljs-string">classpath:/static/</span><br></code></pre></td></tr></table></figure><h3 id="5-问题解决"><a href="#5-问题解决" class="headerlink" title="5.问题解决"></a>5.问题解决</h3><p>判断是否重复抢购，存入redis中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">TSeckillOrder tSeckillOrder = (TSeckillOrder) redisTemplate.opsForValue().get(&quot;order:&quot; + user.getId() + &quot;:&quot; + goodsId);<br></code></pre></td></tr></table></figure><p>单纯在减库存时判断商品库存是否为负，为负不再继续，解决超卖。<code>update会加行级别排他锁</code> &#x3D;&#x3D;影响并发量&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">seckillGoodsResult</span> <span class="hljs-operator">=</span> itSeckillGoodsService.update(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;TSeckillGoods&gt;()<br>                                                          .setSql(<span class="hljs-string">&quot;stock_count = &quot;</span> + <span class="hljs-string">&quot;stock_count-1&quot;</span>)<br>                                                          .eq(<span class="hljs-string">&quot;goods_id&quot;</span>, goodsVo.getId())<br>                                                          .gt(<span class="hljs-string">&quot;stock_count&quot;</span>, <span class="hljs-number">0</span>)<br>                                                         );<br><span class="hljs-keyword">if</span> (!seckillGoodsResult) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>订单表加唯一索引(user, goodid)防止单一用户多抢，<code>@Transactional</code>。</p><p>至此：单一购买以及超卖问题都解决了</p><h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>doseckill2</p><ul><li><p>redis预减库存（原子）</p></li><li><p>内存标记减少redis访问</p></li><li><p>用队列进行缓冲</p></li><li><p>静态化 + MQ + redis: QPS：<code>637-&gt;571</code>   反而下降了 </p></li><li><p><strong>分析原因</strong>：数据库在本地但redis在云上，导致redis读取过慢，<strong>redis本地</strong>后**<code>1933 -&gt; 3209</code>**，p55</p></li></ul><h3 id="1-预减库存"><a href="#1-预减库存" class="headerlink" title="1.预减库存"></a>1.<strong>预减库存</strong></h3><ul><li>加载时加入库存量 ;redis是&#x3D;&#x3D;原子操作&#x3D;&#x3D;，减库存时不会有并发问题，保证进入MQ的都是有库存的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().decrement(<span class="hljs-string">&quot;seckillGoods:&quot;</span> + goodsId);<br><span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span>)&#123;<br>    EmptyStockMap.put(goodsId, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 内存标记</span><br>    redisTemplate.opsForValue().increment(<span class="hljs-string">&quot;seckillGoods:&quot;</span> + goodsId);<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.EMPTY_STOCK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-内存标记："><a href="#2-内存标记：" class="headerlink" title="2.内存标记："></a>2.<strong>内存标记：</strong></h3><p>在访问redis前，使用一个map标记商品是否还有库存，减少redis访问（分布式会不会有问题？？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//内存标记，减少Redis的访问</span><br><span class="hljs-keyword">if</span> (EmptyStockMap.get(goodsId)) &#123;<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.EMPTY_STOCK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-消息队列："><a href="#3-消息队列：" class="headerlink" title="3.消息队列："></a>3.<strong>消息队列：</strong></h3><p>有库存要加入mq，传入参数中</p><ul><li>配置文件定义队列和交换机</li><li>MQSender文件封装发送方法</li><li>返回给前端排队中状态码</li><li>MQReceiver完成下单，再判断下库存、重复抢购</li></ul><h3 id="4-前端轮询："><a href="#4-前端轮询：" class="headerlink" title="4.前端轮询："></a><strong>4.前端轮询：</strong></h3><p> 下单后等待，添加一个接口查询是否下单成功</p><h3 id="lua脚本："><a href="#lua脚本：" class="headerlink" title="lua脚本："></a><strong>lua脚本：</strong></h3><p>&#x2F;&#x2F; 减少和增加不是原子的，但会有问题吗？？：redis库存可能负数，但不会超卖</p><p><code>setIfAbsent</code> ：setnx实现加锁，存在以下问题：</p><ul><li>异常了<strong>锁不会销毁</strong>：增加一个5s超时时间</li><li>如果处理时间超过了5s，会导致<strong>删别人的锁</strong>：value是版本号，保证删的是自己加的版本</li><li>（获取版本号 比较 删除）<strong>不是原子操作</strong>：lua脚本实现redis原子化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLock3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> valueOperations.setIfAbsent(<span class="hljs-string">&quot;k1&quot;</span>, value, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">if</span> (isLock) &#123;<br>        valueOperations.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) valueOperations.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + name);<br>        <span class="hljs-comment">//操作结束，删除锁</span><br>        System.out.println(valueOperations.get(<span class="hljs-string">&quot;k1&quot;</span>));<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Boolean) redisTemplate.execute(redisScript, Collections.singletonList(<span class="hljs-string">&quot;k1&quot;</span>), value);<br>        System.out.println(result);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;有线程在使用，请稍后再试&quot;</span>);<br>    &#125;<br>&#125;<br><br>lua：<br> <span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>])==ARGV[<span class="hljs-number">1</span>] then<br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>end<br></code></pre></td></tr></table></figure><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>验证码，存入redis <code>.set(&quot;captcha:&quot; + tUser.getId() + &quot;:&quot; + goodsId, captcha.text() )</code></li><li>对同一用户和商品生成一个唯一地址，拿地址再下单。获取地址需要验证码，地址同样redis</li><li>限流 （网关）</li></ul><p><strong>单接口简单限流</strong>：直接redis，存在5s最后临界问题  ； 漏桶算法；令牌桶算法（令牌不断生成到桶里）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">制访问次数，<span class="hljs-number">5</span>秒内访问<span class="hljs-number">5</span>次<br><span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>captcha = <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) valueOperations.get(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId());<br><span class="hljs-keyword">if</span> (count == <span class="hljs-literal">null</span>) &#123;<br>    valueOperations.set(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId(), <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">5</span>) &#123;<br>    valueOperations.increment(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.ACCESS_LIMIT_REACHED);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通用：</strong>拦截器+注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">需要限制的接口 <br><span class="hljs-meta">@AccessLimit(second = 5, maxCount = 5, needLogin = true)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span><br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AccessLimit &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">second</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maxCount</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器：去出注解中的参数进行判断。同时把user参数的写入也加进来，存入ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<br>        <span class="hljs-comment">// 参数User</span><br>        <span class="hljs-type">TUser</span> <span class="hljs-variable">tUser</span> <span class="hljs-operator">=</span> getUser(request, response);<br>        UserContext.setUser(tUser);<br>        <br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">hm</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>        <span class="hljs-type">AccessLimit</span> <span class="hljs-variable">accessLimit</span> <span class="hljs-operator">=</span> hm.getMethodAnnotation(AccessLimit.class);<br>        <span class="hljs-keyword">if</span> (accessLimit == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> accessLimit.second();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> accessLimit.maxCount();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needLogin</span> <span class="hljs-operator">=</span> accessLimit.needLogin();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>        <span class="hljs-keyword">if</span> (needLogin) &#123;<br>            <span class="hljs-keyword">if</span> (tUser == <span class="hljs-literal">null</span>) &#123;<br>                render(response, RespBeanEnum.SESSION_ERROR);<br>            &#125;<br>            key += <span class="hljs-string">&quot;:&quot;</span> + tUser.getId();<br>        &#125;<br>        <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) valueOperations.get(key);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-literal">null</span>) &#123;<br>            valueOperations.set(key, <span class="hljs-number">1</span>, second, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; maxCount) &#123;<br>            valueOperations.increment(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            render(response, RespBeanEnum.ACCESS_LIMIT_REACHED);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h2><p>网关过滤</p><p>2s 100w请求，20w商品。令牌桶。没获得令牌的直接失败</p><p>快速生成订单：redis （分片） ，再mq</p><p>超卖：分布式锁redisson。加锁解锁消耗：集群</p><p>nacos动态下发商品数量</p><ul><li>框架搭建<ul><li>Thymeleaf, RespBean</li><li>设计数据库 </li><li>全局异常 、通用返回、通用参数</li></ul></li><li>开发<ul><li>商品列表</li><li>商品详情</li><li>订秒杀</li><li>订单详情</li></ul></li><li>压测<ul><li>配置环境</li><li>多用户</li></ul></li><li>优化 页面、对象</li><li>进一步优化Redis预减、内存标记、MQ</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>框架搭建<ul><li>Thymeleaf, RespBean</li><li>设计数据库 </li><li>全局异常 、通用返回、通用参数</li></ul></li><li>开发<ul><li>商品列表</li><li>商品详情</li><li>订秒杀</li><li>订单详情</li></ul></li><li>压测<ul><li>配置环境</li><li>多用户</li></ul></li><li>优化 页面、对象</li><li>进一步优化Redis预减、内存标记、MQ</li></ul><p>笔记：<a href="https://goinggoinggoing.github.io/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE">https://goinggoinggoing.github.io/2023/03/20/B站秒杀项目</a><br>项目地址：<a href="https://github.com/Goinggoinggoing/seckill-study">https://github.com/Goinggoinggoing/seckill-study</a><br>项目来源：程序员来了666， 添加了一些中间过程接口以及注释<br>总结一下，分为三部分<br>第一个部分为基础的实现P43：到这里为了实现不超卖（减少库存的同时判断库存数量）且单一下单（唯一索引）：</p><p>boolean seckillGoodsResult &#x3D; itSeckillGoodsService.update(new UpdateWrapper<TSeckillGoods>()<br>        .setSql(“stock_count &#x3D; “ + “stock_count-1”)<br>        .eq(“goods_id”, goodsVo.getId())<br>        .gt(“stock_count”, 0)  &#x2F;&#x2F;大于零才下单<br>);<br>&#x2F;&#x2F; 防超卖，直接结束，很关键<br>if (!seckillGoodsResult) {<br>    return null;  &#x2F;&#x2F; 否则下单事务直接结束。update是排他锁，一定不会超卖<br>}<br>同时做了一些优化：页面静态化在前后端分离里默认就做了；下单后存入redis，加快是否重复下单判断。：</p><p>第二部分为进一步优化：1.用redis预减库存（减少数据库访问），redis是原子操作，可以防止超卖；2.满足还有库存后进入MQ队列；  3.我还想减少redis访问次数：引入内存标记。</p><p>第三部分为其他优化，比较清晰自己看即可</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建立博客</title>
    <link href="/2023/03/20/%E5%BB%BA%E7%AB%99/"/>
    <url>/2023/03/20/%E5%BB%BA%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>首先优先选择Hexo是因为Node.js已经安装好了，比较方便</p><p>主题选择：Fluid</p><ul><li><p>主题需要简洁，因为博客定位是笔记记录整理</p></li><li><p>需要有一定的美观（因为这个放弃了next主题）</p></li><li><p>基本的页面：首页 归档 分类(支持多级分类) 、标签、搜索功能</p></li></ul><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><ol><li>安装Nodejs</li><li>安装脚手架<code>npm install -g hexo-cli</code></li></ol><h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init blog   <span class="hljs-comment"># 初始化博客</span><br><span class="hljs-built_in">cd</span> blog<br>npm instal<br><br><br>hexo new fistt <span class="hljs-comment"># 创建第一个页面 填写内容</span><br><br>hexo g <span class="hljs-comment"># 生成文件</span><br>hexo s <span class="hljs-comment"># 启动  localhost:4000可以查看博客</span><br></code></pre></td></tr></table></figure><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><ol><li><p>新建 <code>用户名.github.io</code> 的仓库</p></li><li><p>配置博客推送到对应仓库</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span>  <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Goinggoinggoing/Goinggoinggoing.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li><li><p><code>npm install hexo-deployer-git --save</code>  安装git部署插件</p></li><li><p><code>hexo d</code> 推送到仓库</p></li></ol><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><ol><li><p><code>npm install --save hexo-theme-fluid</code></p></li><li><p>修改_config.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span><br>language: zh-CN  <span class="hljs-comment"># 指定语言</span><br></code></pre></td></tr></table></figure></li><li><p>重新生成并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <br>hexo s <br></code></pre></td></tr></table></figure></li></ol><h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><p>​<a href="https://hexo.fluid-dev.com/docs/guide/">官方文档</a></p><h4 id="文章配置"><a href="#文章配置" class="headerlink" title="文章配置"></a>文章配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">开发</span>, <span class="hljs-string">项目</span>]<br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 但可以通过链接访问</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span> <span class="hljs-comment"># 文章排序顺序 越大越前</span><br><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span> <span class="hljs-comment"># 封面图</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post_banner.jpg</span>  <span class="hljs-comment">#顶部图</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br><br></code></pre></td></tr></table></figure><h3 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h3><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><ul><li>修改博客配置文件，<code>post_asset_folder: true</code>，使得每次生成文章时默认携带一个同名文件夹，用来存放图片</li><li>引用图片： <code>![](test.png)</code>   或  <code>&#123;% asset_img test.png 图片引用方法一 %&#125;</code></li><li>存在的问题：本地typora记笔记是记录到  name.asset&#x2F;test.png，这样从本地到博客需要转换很麻烦</li></ul><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>​搭建github图床，每次本地完成后通过PicGo一键上传到图床，即可访问图片</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230402195401606.png" alt="image-20230402195401606"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_淡淡的说非的博客-CSDN博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2023/03/17/mysql/"/>
    <url>/2023/03/17/mysql/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL视频</a></p><p>下面是对章节与视频的对应关系和学习建议</p><p>【MySQL上篇：基础篇】<br>【第1子篇：数据库概述与MySQL安装篇】<br>p01-p11<br>学习建议：零基础同学必看，涉及理解和Windows系统下MySQL安装</p><p>【第2子篇：SQL之SELECT使用篇】<br>p12-p48<br>学习建议：学习SQL的重点，必须重点掌握，建议课后练习多写</p><p>【第3子篇：SQL之DDL、DML、DCL使用篇】<br>p49-p73<br>学习建议：学习SQL的重点，难度较SELECT低，练习写写就能掌握</p><p>【第4子篇：其它数据库对象篇】<br>p74-p93<br>学习建议：对于希望早点学完MySQL基础，开始后续内容的同学，这个子篇可以略过。<br>在工作中，根据公司需要进行学习即可。</p><p>【第5子篇：MySQL8新特性篇】<br>p94-p95<br>学习建议：对于希望早点学完MySQL基础，开始后续内容的同学，这个子篇可以略过。<br>在工作中，根据公司需要进行学习即可。</p><p>【MySQL下篇：高级篇】<br>【第1子篇：MySQL架构篇】<br>p96-p114<br>学习建议：涉及Linux平台安装及一些基本问题，基础不牢固同学需要学习</p><p>【第2子篇：索引及调优篇】<br>p115-p160<br>学习建议：面试和开发的重点，也是重灾区，需要全面细致的学习和掌握</p><p>【第3子篇：事务篇】<br>p161-p186<br>学习建议：面试和开发的重点，需要全面细致的学习和掌握</p><p>【第4子篇：日志与备份篇】<br>p187-p199<br>学习建议：根据实际开发需要，进行相应内容的学习</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式1：也是执行顺序<br>SELECT ...,....,...<br>FROM ...,...,....<br>WHERE 多表的连接条件<br>AND 不包含组函数的过滤条件<br>GROUP BY ...,...<br>HAVING 包含组函数的过滤条件<br>ORDER BY ... ASC/DESC<br>LIMIT ...,...<br>#方式2：<br>SELECT ...,....,...<br>FROM ... JOIN ...<br>ON 多表的连接条件<br>JOIN ...<br>ON ...<br>WHERE 不包含组函数的过滤条件<br>AND/OR 不包含组函数的过滤条件<br>GROUP BY ...,...<br>HAVING 包含组函数的过滤条件<br>ORDER BY ... ASC/DESC<br>LIMIT ...,...<br></code></pre></td></tr></table></figure><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p><ol><li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li><li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li><li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li></ol><ul><li>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。</li><li>然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的 基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。</li><li>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段 。</li><li>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2 。</li><li>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到 虚拟表 vt6 。</li><li>最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表 vt7 。</li><li>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT<br><br>SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5<br>FROM player JOIN team ON player.team_id = team.team_id # 顺序 1<br>WHERE height &gt; 1.80 # 顺序 2<br>GROUP BY player.team_id # 顺序 3<br>HAVING num &gt; 2 # 顺序 4<br>ORDER BY num DESC # 顺序 6<br>LIMIT 2 # 顺序 7<br></code></pre></td></tr></table></figure><h3 id="基础select"><a href="#基础select" class="headerlink" title="基础select"></a>基础select</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs mysql">别名：空行 或 as<br>DISTINCT 去重<br>空值：null <br>着重号：`order`<br>显示表结构：desc employees; <br><br>比较运算符：<br>= ：<br>1 = &#x27;1&#x27;  字符串会被转为整数<br>都是字符串会比较ANSI编码<br>!=<br>    ISNULL<br>    IS Not NULL<br>    BETWEEN x AND y<br>    IN<br>    NOT IN<br>    LIKE  % _<br>RLIKE 正则表达式<br>逻辑运算符<br>NOT 或 !<br>AND 或 &amp;&amp;<br>OR 或 ||<br>XOR<br><br>排序<br>ORDER BY x ASC(DESC), y ASC  多列排序在x相同才比y<br>分页<br>LIMIT [位置偏移量,] 行数     LIMIT 20,10; <br>UNION<br>连接两次查询<br><br>连接<br>SELECT emp.employee_id, dep.department_name<br>    FROM employee emp, department dep<br>    WHERE emp.`department_id` = dep.`department_id`;<br><br>JOIN / INNER JOIN   <br>    LEFT JOIN<br>    RIGHT JOIN<br>    FULL JOIN<br>    最后加上<br>    ON 条件<br>    USING 名称要对应并且值相等<br>    <br>    <br>    还有连接方式是直接选出来后where =条件连接，inner join（inner join即join）和=等号结果一样，但实现原理完全不同，join是基于hashtable连接比较，而=直接就是取笛卡尔集再过滤，所以后者效率低，是O(N^2)，前者是O(LogN)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">聚合函数<br>AVG()<br>SUM()<br>MAX()<br>MIN()<br>count(*) count(1) count(列名)<br>MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。 <br>Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。<br><br>GROUP BY 分组<br>SELECT的字段必须声明在GROUP BY或者聚合函数<br>HAVING 过滤分组<br>WITH ROLLUP 对统计出来的结果再求和，多一行<br><br><br></code></pre></td></tr></table></figure><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="~文件目录"></a>~文件目录</h2><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055458.png" alt="image-20230224113320725"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055459.png" alt="image-20230225090438227"></p><ul><li>Mysql5.7：ibd默认96KB，6个页</li><li>Mysql8.0：ibd默认112KB，结合了frm</li></ul><h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="~逻辑架构"></a>~逻辑架构</h2><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055460.png" alt="image-20230222201134751"></p><ol><li><strong>连接层</strong>TCP握手建立连接，确认账号密码。通过线程池分配线程</li><li><strong>服务层</strong>生成解析树，优化器生成执行计划完成优化 &#x3D;&#x3D;选取-投影-连接&#x3D;&#x3D;</li><li><strong>引擎层</strong>插件式存储引擎层，负责数据的提取和存储  show engines；</li></ol><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055461.png" alt="image-20230222202520557" style="zoom: 80%;" /><ol><li><p><strong>缓存</strong></p><p>缓存必须一模一样，命中率低；更新后还可能失效</p><p><code>show global variables like &quot;%query_cache_type%&quot;;  show status like &#39;%Qcache%&#39;;</code></p></li><li><p><strong>解析器</strong></p><p><strong>词法分析</strong>识别关键字</p><p><strong>语法分析</strong>查看是否满足mysql语法，然后生成语法树</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055462.png" alt="image-20230222203631132"></p></li><li><p><strong>优化器</strong></p><p>找到这其中最好的执行计划。</p><p>比如：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联 (join) 的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from test1 join test2 using(ID)<br>where test1.name=&#x27;zhangwei&#x27; and test2.name=&#x27;mysql高级课程&#x27;;<br><br>方案1：可以先从表 test1 里面取出 name=&#x27;zhangwei&#x27;的记录的 ID 值，再根据 ID 值关联到表 test2，再判<br>断 test2 里面 name的值是否等于 &#x27;mysql高级课程&#x27;。<br><br>方案2：可以先从表 test2 里面取出 name=&#x27;mysql高级课程&#x27; 的记录的 ID 值，再根据 ID 值关联到 test1，<br>再判断 test1 里面 name的值是否等于 zhangwei。<br><br>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化<br>器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。<br>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。<br></code></pre></td></tr></table></figure></li><li><p>执行器</p></li></ol><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="~存储引擎"></a>~存储引擎</h2><h3 id="①引擎"><a href="#①引擎" class="headerlink" title="①引擎"></a>①引擎</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engines;<br>show variables like &#x27;%storage_engine%&#x27; 或 SELECT @@default_storage_engine;<br>SET DEFAULT_STORAGE_ENGINE=MyISAM;   修改 my.cnf 文件：default-storage-engine=MyISAM<br><br></code></pre></td></tr></table></figure><p>不同的表可以设置不同的存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建<br>CREATE TABLE 表名(<br>建表语句;<br>) ENGINE = 存储引擎名称;<br>修改<br>ALTER TABLE 表名 ENGINE = 存储引擎名称;<br></code></pre></td></tr></table></figure><h3 id="②引擎介绍"><a href="#②引擎介绍" class="headerlink" title="②引擎介绍"></a>②引擎介绍</h3><p> 5.5之后，默认InnoDB </p><h4 id="1-InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#1-InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="1 InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>1 InnoDB 引擎：具备外键支持功能的事务存储引擎</h4><ul><li>事务型引擎。确保事务的完整提交(Commit)和回滚(Rollback)。 </li><li>行锁，更新一条数据只锁定一行</li><li>更新和删除效率高</li><li>外键</li><li><code>处理效率差一些，对内存要求(索引即数据，索引和数据存储在一起)</code></li></ul><h4 id="2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="2 MyISAM 引擎：主要的非事务处理存储引擎"></a>2 MyISAM 引擎：主要的非事务处理存储引擎</h4><ul><li>读速度快，针对select insert</li><li>count(*)等数据有额外存储</li></ul><h4 id="3-Archive-引擎：用于数据存档"><a href="#3-Archive-引擎：用于数据存档" class="headerlink" title="3 Archive 引擎：用于数据存档"></a>3 Archive 引擎：用于数据存档</h4><ul><li>只有插入和查询，适合存储大量独立历史记录</li><li>数据压缩，比MyISAM小75&amp;</li></ul><h4 id="4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a>4 Blackhole 引擎：丢弃写操作，读操作会返回空内容</h4><h4 id="5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a>5 CSV 引擎：存储数据时，以逗号分隔各个数据项</h4><h4 id="6-Memory-引擎：置于内存的表"><a href="#6-Memory-引擎：置于内存的表" class="headerlink" title="6 Memory 引擎：置于内存的表"></a>6 Memory 引擎：置于内存的表</h4><p>索引数据结构(B+) InnoDB数据结构  设计原则 性能分析工具 优化 数据库设计</p><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="~索引的数据结构"></a>~索引的数据结构</h2><h3 id="①-索引介绍"><a href="#①-索引介绍" class="headerlink" title="① 索引介绍"></a>① 索引介绍</h3><p>查找一个数据：遍历 索引二叉树(保存value, 地址)  减少磁盘IO</p><p><strong>定义</strong>：为了高效获取数据的数据结构  </p><p>在存储引擎中实现，不同引擎可以不一样结构</p><p><strong>优点</strong>：</p><ol><li><p>类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主 要的原因。 </p></li><li><p>通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。 </p></li><li><p>在实现数据的 参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。 </p></li><li><p>在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。‘</p></li></ol><p><strong>缺点：</strong></p><ol><li>创建和维护需要时间</li><li>索引需要磁盘空间</li><li>提高查询速度 但 降低 &#x3D;&#x3D;更新速度&#x3D;&#x3D;</li></ol><blockquote><p>频繁更新，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p></blockquote><h3 id="②-InnoDB中的索引"><a href="#②-InnoDB中的索引" class="headerlink" title="② InnoDB中的索引"></a>② InnoDB中的索引</h3><h4 id="普通查找"><a href="#普通查找" class="headerlink" title="普通查找"></a>普通查找</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;<br></code></pre></td></tr></table></figure><p>数据以页的形式存储，一页默认为16KB，查找时按照页逐步加载到内存</p><ol><li>数据在一页中（记录物理不连续，单链表，通过页目录实现二分）<ul><li>以主键搜索条件：主键通常为递增的 -&gt; 在 &#x3D;&#x3D;页目录 二分&#x3D;&#x3D; 定位对应槽 ，然后对槽内遍历</li><li>其他列：每一条记录为单链表连接(<strong>逻辑上连续</strong>)， 依次遍历</li></ul></li><li>很多页（页间双向链表连接）<ol><li>首先遍历页。<strong>没有索引无法快速定位</strong></li><li>再查找相应记录</li></ol></li></ol><h4 id="索引雏形"><a href="#索引雏形" class="headerlink" title="索引雏形"></a>索引雏形</h4><p>以<code>ROW_FORMAT = Compact </code>行格式创建表，表的每一条记录处理基本信息还有 是否最大 下一条地址 其他等，以下一条地址串联记录。</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055463.png" alt="image-20230223094205438" style="zoom: 50%;" /><p>为了针对主键设计索引，需要实现主键递增（主键不是自增的有个隐藏主键）</p><ul><li><p>页内是递增的，&#x3D;&#x3D;单向链表&#x3D;&#x3D;</p></li><li><p>页之间主键也是递增的，&#x3D;&#x3D;双向链表&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055464.png" alt="image-20230223094947963"></p></li></ul><blockquote><p>如果具体查找某一个主键还是得遍历全部页，然后页内二分，因此加一层。<br>加一个目录（目录可以连续存放）保存最小值，两次查找</p></blockquote><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055465.png" alt="image-20230223095322576" style="zoom: 67%;" /><h5 id="迭代1"><a href="#迭代1" class="headerlink" title="迭代1"></a>迭代1</h5><p>将目录转为页，<strong>实现快速定位数据页。</strong>目录也是页，用record_type&#x3D;1.通过&#x3D;&#x3D;页目录&#x3D;&#x3D;实现二分</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055466.png" alt="image-20230223100558168"></p><h5 id="迭代2"><a href="#迭代2" class="headerlink" title="迭代2"></a>迭代2</h5><p>一个目录页放不下，多个目录页。具体哪一个目录页要遍历，下面优化</p><h5 id="迭代3"><a href="#迭代3" class="headerlink" title="迭代3"></a>迭代3</h5><p>再往上迭代套娃，<strong>实现快速定位是哪个目录页</strong>。一个页为一次IO。总共3次IO</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055467.png" alt="image-20230223101559060"></p><h5 id="B-TreeB-Tree"><a href="#B-TreeB-Tree" class="headerlink" title="B+TreeB+Tree"></a>B+TreeB+Tree</h5><p>上面的结构就是3层的B+树，可以迭代任意层，但最多不超过4层（最多4次IO）</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055468.png" alt="image-20230223102937530" style="zoom: 33%;" /><p>假设存放记录的页可以100条，目录项的页为1000（页大小16KB，一条记录包含指针8KB主键8KB）条：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li><li>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。 </li><li>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。 </li><li>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！</li><li>一般2-4层，根节点常驻内存，所以1-3次磁盘操作</li></ul><p>页内数据通过&#x3D;&#x3D;链表&#x3D;&#x3D;连接，使用页目录实现&#x3D;&#x3D;二分法&#x3D;&#x3D;定位</p><p>同行页间通过&#x3D;&#x3D;双向链表&#x3D;&#x3D;连接</p><h4 id="常见索引"><a href="#常见索引" class="headerlink" title="常见索引"></a>常见索引</h4><h5 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h5><p><strong>基本的数据存储方式</strong>（叶子节点存放全部记录）。 <code>索引即数据，数据即索引   .ibd文件</code></p><p>在创建时自动构建出来–B+树。</p><blockquote><p> 术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起，只有一种存储方式所以聚簇索引只有一个</p></blockquote><ul><li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 </li><li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快</li></ul><ul><li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式(<del>UUID MD5 HASH</del>)，否则将会出现页分裂</li><li><code>更新主键的代价很高</code> ，一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code> ，第一次找到主键值，第二次根据主键值找到行数据</li></ul><h5 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h5><p>想以别的列作为搜索条件，需要以别的列构建B+树。</p><p>叶子节点存储<strong>索引列</strong>和<strong>主键</strong>。目录项存储<strong>索引列</strong>和<strong>页号</strong>（实际上是索引列和主键联合，后面会说 为保证唯一）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055470.png" alt="image-20230223154220793"></p><p>查询要查两次（<strong>回表</strong>）：先根据筛选条件在普通索引上定位id，再拿id再聚集索引上定位行</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055471.png" alt="image-20230223153459920" style="zoom:50%;" /><h5 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3.联合索引"></a>3.联合索引</h5><p>以c2和c3同时作为排列规则，优先c2，然后c3。别的和二级索引等价</p><h4 id="InnoDB注意事项"><a href="#InnoDB注意事项" class="headerlink" title="InnoDB注意事项"></a>InnoDB注意事项</h4><p><strong>1.根节点位置不变</strong><br>一开始根节点存放数据，满了后复制一份数据存储到别的地址，然后根节点升一级。此外，根节点常驻内存</p><p><strong>2.目录项记录的唯一性</strong><br>二级索引中<code>索引列 + 页号</code>搭配，索引列不唯一插入走哪条路就不知道了。所以默认会将<code>索引列+主键+页号</code>搭配，索引列和主键类似构建了一个联合索引。</p><p><strong>3.一个页面至少两条数据</strong></p><h3 id="③-MyISAM中索引"><a href="#③-MyISAM中索引" class="headerlink" title="③ MyISAM中索引"></a>③ MyISAM中索引</h3><p>索引与数据<strong>分离</strong> .myd存储数据（无序）， .myi存储索引</p><p>B树索引使用存储引擎如表所示：</p><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 <strong>地址</strong> 。&#x3D;&#x3D;相当于二级索引，但第二次是直接去磁盘&#x3D;&#x3D;</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055472.png" alt="image-20230223160434464" style="zoom: 67%;" /><p>​<code>这里是针对主键构建的，还可以根据c2，c3都构建。</code></p><p><strong>对比：</strong></p><ul><li>InnoDB对聚簇索引只需要查找一次，二级索引需要两次。MYISAM都是两次，但第二次很快</li><li>MYISAM索引文件分离</li><li>MYISAM可以没有主键</li></ul><h3 id="④-索引的代价"><a href="#④-索引的代价" class="headerlink" title="④ 索引的代价"></a>④ 索引的代价</h3><ul><li>空间：每一个索引都是一颗b+树</li><li>时间：增删改需要额外维护树结构</li></ul><h3 id="⑤-数据结构选择"><a href="#⑤-数据结构选择" class="headerlink" title="⑤ 数据结构选择"></a>⑤ 数据结构选择</h3><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>hashmap O(1)</p><ol><li>Hash只能进行&#x3D;和in的查询，不能进行范围查询(退化到O n)</li><li>无序 不能order by</li><li>联合索引时，hash值是一起构建的，无法拆开利用</li><li>重复值过多，冲突很多</li></ol><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>HASH索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>但Innodb也可以结合Hash，例如当某个条件WHERE a &#x3D; XXX经常访问时，将该条件对应地址直接存在hash中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%adaptive_hash_index&#x27;;<br></code></pre></td></tr></table></figure><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul><li>一个节点只能有两个子节点</li><li>左子节点 &lt; 本节点; 右子节点 &gt;&#x3D; 本节点</li><li>不平衡时退化</li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055473.png" alt="image-20230223163719556" style="zoom:50%;" /><h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>平衡二叉树且高度差小于1</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055474.png" alt="image-20230223163957242"></p><p>还可以变成多叉树来降低高度</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>每一个节点最多M个子节点，M称为树的阶。<strong>非叶子节点也存放数据</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055475.png" alt="image-20230223164347661"></p><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li>根节点的儿子数的范围是 [2,M]。 </li><li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M&#x2F;2), M]。 </li><li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。 </li><li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li><li>所有叶子节点位于同一层。</li></ol><p> 数据是一块的实现相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><strong>B+ 树和 B 树的<code>差异</code>在于以下几点：</strong></p><ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。 </li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中（小从小到大顺序链接）。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。</li></ol><p><strong>不在中间节点放数据，好处</strong></p><ul><li>数据都在叶子，查询效率稳定</li><li>非叶子无数据，可以存储更多数据，<strong>更矮胖</strong></li><li><strong>范围查找</strong>：叶子节点上直接进行范围查找效率高</li></ul><p>B树层数与节点数关系见：<a href="#B+Tree">B+Tree</a>，整课树能达到GB，不会全部加载到内存，只有根节点是常驻内存的</p><h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="~InnoDB数据存储结构"></a>~InnoDB数据存储结构</h2><p>索引是在存储引擎中实现的，存储引擎<strong>负责数据的读取和写入</strong></p><p>InnoDB将<strong>数据划分为页</strong>（16KB），页是磁盘和内存交换的&#x3D;&#x3D;基本单位&#x3D;&#x3D;，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;%innodb_page_size%&#x27;;<br></code></pre></td></tr></table></figure><p>SQL Server 中页的大小为 <code>8KB</code>，而在 Oracle 中我们用术语 “<code>块</code>“ （Block）来表示 “页”，Oracle 支持的快大小为2KB, 4KB, 8KB, 16KB, 32KB 和 64KB。</p><ul><li>页和页间<code>双向链表</code></li><li>页内数据按主键值<code>单向链表</code></li></ul><h3 id="①-上层结构"><a href="#①-上层结构" class="headerlink" title="① 上层结构"></a>① 上层结构</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055476.png" alt="image-20230224111638558" style="zoom:67%;" /><ul><li><p><strong>区</strong>：包含64个&#x3D;&#x3D;<strong>连续</strong>&#x3D;&#x3D;的页，<code>16*16KB = 1MB</code></p><p>范围查询时需要连续访问多个页，通过数据连续<strong>减少磁盘读取时间</strong> 10ms -&gt; 0.4ms</p><ul><li>随机读取 <code>单页10ms</code>(6ms寻道3ms等待1ms传输)</li><li>顺序读取 40MB&#x2F;s吞吐量，40&#x2F;16kb可以读取2560页，<code>单页0.4ms</code></li></ul></li><li><p><strong>段</strong>：多个区，数据库分配的基本单位：创建表、索引时分配。逻辑概念</p><p><strong>叶子节点</strong>放在一个区里，<strong>非叶子节点</strong>页在一个区里，区的集合叫做段</p></li><li><p><strong>碎片区：</strong>每次创建索引都会申请两整块区，太浪费。为了节约空间<code>碎片区内的页</code>可以服务于不同的段，当达到<code>32个碎片区</code>页面后，就申请完整的区。</p></li><li><p><strong>表空间</strong>：最高层逻辑容器，一个数据库由多个表空间：系统表空间、用户表空间等</p><ul><li><p>独立表空间: 即每张表有一个独立的表空间 .ibd  show variables like ‘innodb_file_per_table’</p></li><li><p>系统表空间 : 系统中所有表的索引外键路径等信息，也用B+树整合为表：<code>数据字典</code></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055477.png" alt="image-20230225102558798"></p></li></ul></li></ul><h3 id="②-页内结构"><a href="#②-页内结构" class="headerlink" title="② 页内结构"></a>② 页内结构</h3><p>数据页的 <code>16KB</code> 大小的存储空间被划分为<strong>七个部分</strong>：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055478.png" alt="image-20230224113534470" style="zoom:67%;" /><h4 id="第一部分：File-Header-文件头部-和-File-Trailer-文件尾部"><a href="#第一部分：File-Header-文件头部-和-File-Trailer-文件尾部" class="headerlink" title="第一部分：File Header (文件头部) 和 File Trailer (文件尾部)"></a>第一部分：File Header (文件头部) 和 File Trailer (文件尾部)</h4><p>File Header：页编号、页类型（Undo日志 数据页等）、上一页下一页、校验和（hash 文件-&gt;checksum）、日志位置</p><p>File Trailer：校验和（头尾一样代表完整）、日志位置</p><h4 id="第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)"></a>第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)</h4><p><strong>数据记录：</strong> 空闲空间-&gt;用户记录</p><p>最大最小记录：为了能构建B+树，同时是整个链表的首尾</p><h4 id="第三部分：Page-Directory-页目录-和-Page-Header-页面头部"><a href="#第三部分：Page-Directory-页目录-和-Page-Header-页面头部" class="headerlink" title="第三部分：Page Directory (页目录) 和 Page Header (页面头部)"></a>第三部分：Page Directory (页目录) 和 Page Header (页面头部)</h4><p><strong>页目录</strong>：记录分组（<code>直接二分空间太大，跳表</code>），每组4-8个(一个槽)，每个组拿出一个最大值排列出来，然后二分。</p><ul><li>最小记录单成组，最大记录4-8个</li><li>满9就拆分，所以很多都是4个</li></ul><p>页目录就负责记录下每组最大记录的（<code>地址偏移、最大值</code>）</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055479.png" alt="image-20230224121819782" style="zoom:67%;" /><p><strong>页面头部</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055480.png" alt="image-20230224122712920" style="zoom: 33%;" /><h3 id="③-行格式"><a href="#③-行格式" class="headerlink" title="③ 行格式"></a>③ 行格式</h3><p>链表记录的组合方式，为了链表有效组合，需要提供一定的额外信息，<strong>变长字段长度</strong>和<strong>NULL</strong>在&#x3D;&#x3D;InnoDB行格式&#x3D;&#x3D;讲</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055481.png" alt="image-20230224120801440" style="zoom: 50%;" /><p><strong>记录头信息</strong>(5bit)</p><ul><li>delete_mask 是否删除。逻辑删除，同时链表跳过它，并且修改组的数量最值。如果有新数据进来就覆盖一下</li><li>n_owned 每一组最后一条记录负责记下组内的记录个数</li><li>heap_no 页内位置编号  01是最小和最大记录</li><li>record_type 是否为叶子节点</li><li>next_record 链表next，记录偏移量</li></ul><h3 id="④-InnoDB行格式"><a href="#④-InnoDB行格式" class="headerlink" title="④ InnoDB行格式"></a>④ InnoDB行格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table emp3(id int)  row_format=compact;<br>alter table emp3 row_format=compact;<br></code></pre></td></tr></table></figure><ol><li><p>COMPACT</p><ul><li><strong>变长字段长度列表</strong>：对于变长字段不知道实际的长度<code>VARCHAR(8)</code>，需要有一个位子记录下实际上的长度 逆序</li><li><strong>NULL值列</strong>：对于可能为NULL的列，NULL在存储中如果用特殊字符表示会浪费空间，直接用bit位来标识是不是NULL</li><li><strong>记录头信息</strong>：同上</li><li><strong>隐藏列</strong>：<strong>row_id</strong>(行ID，无主键和Unique键时生成)  <strong>transaction_id</strong>(事务ID)  <strong>roll_pointer</strong>(回滚指针)</li></ul><p>.ibd文件讲解</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055482.png" alt="image-20230225091537989"></p><p><strong>行溢出：</strong></p><p>​对于varchar，最长共65535字节: 65532 + 2(长度值) + 1(null值)</p><p>​16KB&#x3D;16384字节，存不下varchar，所以compact存一部分然后存在别的地方，保存下地址</p></li><li><p>Dynamic(MySQL5.7)和Compressed</p><p>Dynamic行溢出只存地址不存数据，Compressed还会用zlib压缩数据</p></li><li><p>Redundant</p><p>字段偏移列表：所有列的偏移地址，等价于变长+NULL，但纯在冗余（对于非varchar）</p></li></ol><h2 id="索引创建"><a href="#索引创建" class="headerlink" title="~索引创建"></a>~索引创建</h2><p>创建完成，.ibd文件会增大</p><h3 id="①-索引基本操作"><a href="#①-索引基本操作" class="headerlink" title="① 索引基本操作"></a>① 索引基本操作</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><ul><li><p>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是<strong>普通索引</strong>、<strong>唯一索引</strong>（UNIQUE）、<strong>主键索引</strong>(UNIQUE+NOT NULL 唯一)、<strong>全文索引</strong>（提高大数据量的检索速度，被solr、ElasticSearch代替）。 </p></li><li><p>按照<code>物理实现</code>方式 ，索引可以分为 2 种：<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。 </p></li><li><p>按照<code>作用字段个数</code> 进行划分，分成<strong>单列索引</strong>和<strong>联合索引</strong>。</p></li></ul><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><strong>隐式：</strong><code>主键、Unique、外键</code> 会自动添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE dept(<br>dept_id INT PRIMARY KEY AUTO_INCREMENT, # <br>dept_name VARCHAR(20)<br>);<br><br>CREATE TABLE emp(<br>emp_id INT PRIMARY KEY AUTO_INCREMENT, # 主键<br>emp_name VARCHAR(20) UNIQUE, # unique<br>dept_id INT,<br>CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id) # 外键<br>)<br></code></pre></td></tr></table></figure><p><strong>显式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name [col_name data_type]<br>[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |<br>DESC]<br></code></pre></td></tr></table></figure><ul><li>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引； </li><li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引； </li><li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </li><li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </li><li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </li><li>ASC 或 DESC 指定升序或者降序的索引值存储。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INDEX (book_name)<br>INDEX multi_idx(book_id, book_name)<br>UNIQUE INDEX book_n(book_name)<br><br>SHOW INDEX FROM test3 \G # 查看全部索引<br><br>EXPLAIN select * from book where book_name = &quot;mysql&quot; # 查看是否用上索引<br></code></pre></td></tr></table></figure><h4 id="添加删除索引"><a href="#添加删除索引" class="headerlink" title="添加删除索引"></a>添加删除索引</h4><p><strong>添加</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_na ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]<br>[index_name] (col_name[length],...) [ASC | DESC]<br>ALTER TABLE book5 ADD INDEX book_n (book_name) ;<br><br>CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name<br>ON table_name (col_name[length],...) [ASC | DESC]<br></code></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_na DROP INDEX index_name;<br><br>DROP INDEX index_name ON table_na;<br><br># 唯一索引不能删除 起约束作用<br></code></pre></td></tr></table></figure><h3 id="②-8-0索引新特性"><a href="#②-8-0索引新特性" class="headerlink" title="② 8.0索引新特性"></a>② 8.0索引新特性</h3><h4 id="降序索引"><a href="#降序索引" class="headerlink" title="降序索引"></a>降序索引</h4><p>MySQL 8.x开始支持降序 DESC，之前版本的会被忽略。<code>多个列排序</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));<br></code></pre></td></tr></table></figure><p>查询时<code>order by a,b desc</code>，没有降序的化效果很差，需要文件排序</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055483.png" alt="image-20230226085758361"></p><h4 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h4><p>索引设置为隐藏索引，查询优化器<code>忽略这个索引</code>（更新时索引树还是会更新）。可以用来<code>验证某个索引性能</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE tablename<br>ADD INDEX indexname (propname [(length)]) INVISIBLE; # 添加隐藏索引<br><br>ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引<br>ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引<br></code></pre></td></tr></table></figure><h3 id="③-索引的设计原则"><a href="#③-索引的设计原则" class="headerlink" title="③ 索引的设计原则"></a>③ 索引的设计原则</h3><p>数据准备 100W条</p><h4 id="适合创建索引"><a href="#适合创建索引" class="headerlink" title="适合创建索引!"></a>适合创建索引!</h4><h5 id="唯一字段"><a href="#唯一字段" class="headerlink" title="唯一字段"></a>唯一字段</h5><p>业务上具有唯一特性的字段，即使是组合字段，也<code>必须建成唯一索引</code>。</p><blockquote><p>不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。（来源：Alibaba） </p></blockquote><h5 id="频繁where字段"><a href="#频繁where字段" class="headerlink" title="频繁where字段"></a>频繁where字段</h5><p>277ms-&gt;20ms</p><h5 id="经常-GROUP-BY-和-ORDER-BY-的列"><a href="#经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="经常 GROUP BY 和 ORDER BY 的列"></a>经常 GROUP BY 和 ORDER BY 的列</h5><h5 id="DISTINCT-字段"><a href="#DISTINCT-字段" class="headerlink" title="DISTINCT 字段"></a>DISTINCT 字段</h5><h5 id="多表JOIN时"><a href="#多表JOIN时" class="headerlink" title="多表JOIN时"></a>多表JOIN时</h5><ul><li><code>连接表的数量尽量不要超过 3 张</code></li><li><code>对 WHERE 条件创建索引</code></li><li><code>对用于连接的字段创建索引</code></li></ul><h5 id="使用前缀创建索引"><a href="#使用前缀创建索引" class="headerlink" title="使用前缀创建索引"></a>使用前缀创建索引</h5><p>不使用整个字符串构建。虽然不能精确查询，但查个大概然后回表查询完整的字符串。<strong>排序时用不上</strong></p><ul><li><code>太长存储空间太大</code></li><li><code>太长比较时需要占用更多时间</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 截取长度的选择：根据区分度    一般20 就可以达到90%以上<br>select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度<br>count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度<br>from shop<br></code></pre></td></tr></table></figure><h5 id="区分度高-散列性高"><a href="#区分度高-散列性高" class="headerlink" title="区分度高(散列性高)"></a>区分度高(散列性高)</h5><p><code>select count(distinct a) / count(*) from t1</code>，超过33%就不错的索引了</p><p>相对应的，像性别字段就不要添加索引</p><h5 id="最频繁的列放到联合索引的左侧"><a href="#最频繁的列放到联合索引的左侧" class="headerlink" title="最频繁的列放到联合索引的左侧"></a>最频繁的列放到联合索引的左侧</h5><p>对应最左前缀原则。</p><h5 id="多个字段都要创建时，联合索引更优"><a href="#多个字段都要创建时，联合索引更优" class="headerlink" title="多个字段都要创建时，联合索引更优"></a>多个字段都要创建时，联合索引更优</h5><ul><li>减少开销：一个联合索引<code>(c1,c2,c3)</code>，相当于<code>(c1)</code>,<code>(c1,c2)</code>,<code>(c1,c2,c3)</code>三个索引</li><li>覆盖索引：<code> select col1,col2,col3 from test where col1=1 and col2=2</code>，无需回表</li><li>效率高：索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1&#x3D;1 and col2&#x3D;2 and  col3&#x3D;3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%&#x3D;100w条数据，然后再回表从100w条数据中找到符合col2&#x3D;2 and col3&#x3D; 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w * (10% *10% *10%)&#x3D;1w，效率提升可想而知！</li></ul><h4 id="限制索引数量"><a href="#限制索引数量" class="headerlink" title="限制索引数量"></a>限制索引数量</h4><p>单表不超过六个：</p><ul><li>索引占用空间</li><li>更新时间</li><li>查询时，优化器需要对可能用到的索引进行比较，太多会降低性能</li></ul><h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="~性能分析工具"></a>~性能分析工具</h2><h3 id="①-优化步骤"><a href="#①-优化步骤" class="headerlink" title="① 优化步骤"></a>① 优化步骤</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055484.png" alt="image-20220627162248635"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055485.png" alt="image-20220627162345815"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055486.png" alt="image-20230226135825018" style="zoom:50%;" /><h3 id="②-查看系统性能-status"><a href="#②-查看系统性能-status" class="headerlink" title="② 查看系统性能 status"></a>② 查看系统性能 status</h3><p><code>SHOW STATUS</code> ：查询一些MySQL数据库服务器的<code>性能参数、执行频率</code>。 %是通配符任意匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW [GLOBAL|SESSION] STATUS LIKE &#x27;参数&#x27;;<br></code></pre></td></tr></table></figure><ul><li><p>Connections：连接MySQL服务器的次数。 </p></li><li><p>Uptime：MySQL服务器的上线时间。 </p></li><li><p>&#x3D;&#x3D;Slow_queries&#x3D;&#x3D;：慢查询的次数。 </p></li><li><p>Innodb_rows_read：Select查询返回的行数 </p></li><li><p>Innodb_rows_inserted：执行INSERT操作插入的行数 </p></li><li><p>Innodb_rows_updated：执行UPDATE操作更新的 行数 </p></li><li><p>Innodb_rows_deleted：执行DELETE操作删除的行数 </p></li><li><p>Com_select：查询操作的次数。 </p></li><li><p>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 </p></li><li><p>Com_update：更新操作 的次数。 </p></li><li><p>Com_delete：删除操作的次数。</p></li><li><p>&#x3D;&#x3D;last_query_cost&#x3D;&#x3D;：查看最后一次操作查询了多少张<strong>数据页</strong>。</p><ul><li>建立了索引，可以有效减少访问的页数。回表的化页数还要增加</li><li>页数多页不用担心，1.页可以在缓冲池或内存中、2.批量顺序读取速度也很快</li></ul></li></ul><h3 id="③-定位执行慢的-SQL：慢查询日志"><a href="#③-定位执行慢的-SQL：慢查询日志" class="headerlink" title="③ 定位执行慢的 SQL：慢查询日志"></a>③ 定位执行慢的 SQL：慢查询日志</h3><p>超过<code>long_query_time</code>的SQL会记录下，默认10s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;%slow_query_log%&#x27;; # 是否打开 以及 保存地址<br>set global slow_query_log=&#x27;ON&#x27;; # 打开<br><br> show variables like &#x27;%long_query_time%&#x27;; # 时间阈值<br> <br> # 设置时间<br> #测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并<br>mysql &gt; set global long_query_time = 1;<br>mysql&gt; show global variables like &#x27;%long_query_time%&#x27;;<br>mysql&gt; set long_query_time=1;<br>mysql&gt; show variables like &#x27;%long_query_time%&#x27;;<br></code></pre></td></tr></table></figure><p><code>show status like &#39;slow_queries&#39;</code> 显示有多少sql超时了</p><p> <code>mysqldumpslow</code> ：日志分析工具，给日志文件就可以定位sql。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#得到返回记录集最多的10个SQL<br>mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log<br><br>#得到访问次数最多的10个SQL<br>mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log<br><br>#得到按照时间排序的前10条里面含有左连接的查询语句<br>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log<br><br>#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况<br>mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more<br></code></pre></td></tr></table></figure><h3 id="④-PROFILE"><a href="#④-PROFILE" class="headerlink" title="④ PROFILE"></a>④ PROFILE</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;profiling&#x27;;<br>set profiling = &#x27;ON&#x27;;<br>show profiles; # 近几个查询<br>show profile; # 最近一个的细节   各个阶段耗时<br>show profile cpu,block io for query 2<br></code></pre></td></tr></table></figure><h3 id="⑤-EXPLAIN"><a href="#⑤-EXPLAIN" class="headerlink" title="⑤ EXPLAIN"></a>⑤ EXPLAIN</h3><p>不考虑各种Cache、不能显示优化工作、不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况 </p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055487.png" alt="image-20220628212049096" style="zoom: 80%;" /><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE s1 (<br>    id INT AUTO_INCREMENT,<br>    key1 VARCHAR(100),<br>    key2 INT,<br>    key3 VARCHAR(100),<br>    key_part1 VARCHAR(100),<br>    key_part2 VARCHAR(100),<br>    key_part3 VARCHAR(100),<br>    common_field VARCHAR(100),<br>    PRIMARY KEY (id),<br>    INDEX idx_key1 (key1),<br>    UNIQUE INDEX idx_key2 (key2),<br>    INDEX idx_key3 (key3),<br>    INDEX idx_key_part(key_part1, key_part2, key_part3)<br>) ENGINE=INNODB CHARSET=utf8;<br><br>CREATE TABLE s2 (<br>    id INT AUTO_INCREMENT,<br>    key1 VARCHAR(100),<br>    key2 INT,<br>    key3 VARCHAR(100),<br>    key_part1 VARCHAR(100),<br>    key_part2 VARCHAR(100),<br>    key_part3 VARCHAR(100),<br>    common_field VARCHAR(100),<br>    PRIMARY KEY (id),<br>    INDEX idx_key1 (key1),<br>    UNIQUE INDEX idx_key2 (key2),<br>    INDEX idx_key3 (key3),<br>    INDEX idx_key_part(key_part1, key_part2, key_part3)<br>) ENGINE=INNODB CHARSET=utf8;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。<br># Function<br>DELIMITER //<br>CREATE FUNCTION rand_string1(n INT)<br>RETURNS VARCHAR(255) #该函数会返回一个字符串<br>BEGIN<br>DECLARE chars_str VARCHAR(100) DEFAULT<br>&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;<br>    DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;<br>    DECLARE i INT DEFAULT 0;<br>    WHILE i &lt; n DO<br>        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));<br>        SET i = i + 1;<br>    END WHILE;<br>    RETURN return_str;<br>END //<br>DELIMITER ;<br><br># 存储过程<br>DELIMITER //<br>CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    SET autocommit = 0;<br>    REPEAT<br>    SET i = i + 1;<br>    INSERT INTO s1 VALUES(<br>        (min_num + i),<br>        rand_string1(6),<br>        (min_num + 30 * i + 5),<br>        rand_string1(6),<br>        rand_string1(10),<br>        rand_string1(5),<br>        rand_string1(10),<br>        rand_string1(10));<br>    UNTIL i = max_num<br>    END REPEAT;<br>    COMMIT;<br>END //<br>DELIMITER ;<br><br>DELIMITER //<br>CREATE PROCEDURE insert_s2 (IN min_num INT (10),IN max_num INT (10))<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    SET autocommit = 0;<br>    REPEAT<br>    SET i = i + 1;<br>    INSERT INTO s2 VALUES(<br>        (min_num + i),<br>        rand_string1(6),<br>        (min_num + 30 * i + 5),<br>        rand_string1(6),<br>        rand_string1(10),<br>        rand_string1(5),<br>        rand_string1(10),<br>        rand_string1(10));<br>    UNTIL i = max_num<br>    END REPEAT;<br>    COMMIT;<br>END //<br>DELIMITER ;<br><br># 调用<br>CALL insert_s1(10001,10000);<br>CALL insert_s2(10001,10000);<br></code></pre></td></tr></table></figure><h4 id="各列作用☆"><a href="#各列作用☆" class="headerlink" title="各列作用☆"></a>各列作用☆</h4><p>一条语句可多个select，一个select可from多个表，一个表一行记录</p><ol><li><p>&#x3D;&#x3D;<strong>table</strong>&#x3D;&#x3D;</p><p>对应表，每行记录都对应一个表。可能有临时表</p><p><code>EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</code> Union会构建临时表去重，一共3个</p></li><li><p>&#x3D;&#x3D;<strong>id</strong>&#x3D;&#x3D;</p><p>对应select个数，如子查询就有多个select</p><p>按照id从小到大执行，同一id前面的是驱动表</p></li><li><p><strong>&#x3D;&#x3D;select_type&#x3D;&#x3D;</strong>  小查询在整个大查询扮演的角色</p><ol><li>simple：简单 以及JOIN <code>EXPLAIN SELECT * FROM s1;</code>  <code>EXPLAIN SELECT * FROM s1 INNER JOIN s2;</code> </li><li>PRIMARY ：UNION最左边，子查询最外面的 <code>EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</code> s1</li><li>UNION：UNION剩下的 s2</li><li>UNION RESULT：UNION产生的临时表</li><li>SUBQUERY ：子查询里面<code>EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#39;a&#39;;</code></li><li>等等p137</li></ol></li><li><p>&#x3D;&#x3D;partition&#x3D;&#x3D;(分区相关)</p></li><li><p>&#x3D;&#x3D;type&#x3D;&#x3D; ☆</p><p>执行查询时的访问方法：<code>system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL</code> 。</p><ul><li><p><code>system</code> 一条记录且数据统计精准（MyISAM、Memory）</p></li><li><p><code>const</code> 主键或唯一二级索引与常数等值匹配</p></li><li><p><code>eq_ref</code> 连接时，被驱动表是通过主键或者唯一二级索引列</p></li><li><p><code>ref</code> 普通的二级索引列与常量进行等值匹配</p></li><li><p><code>index_merge</code> 条件为or时，同时用上多个索引</p></li><li><p>…</p></li><li><p><code>range</code> 索引的范围查询  <code>c1 IN (&#39;a&#39;, &#39;b&#39;)</code>   <code>c1 &gt; &#39;a&#39;</code>  <code>c1 LIKE &#39;abc%&#39;;</code></p></li><li><p><code>index</code> 索引覆盖，但需要扫描全部记录  <code>EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &#39;a&#39;;</code></p><p>​原因：扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p></li><li><p><code>ALL</code> 全表扫描</p><p><strong>system &gt; const &gt; eq_ref &gt; ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p><p>SQL 性能优化的目标：<strong>至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。</strong>（阿里巴巴 开发手册要求）</p></li></ul></li><li><p>&#x3D;&#x3D;possible_keys&#x3D;&#x3D;和&#x3D;&#x3D;key&#x3D;&#x3D;</p><p><code>可能用到的索引</code> 和 <code>实际用的</code>   ：<code>EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39; AND key3 = &#39;a&#39;;</code></p></li><li><p>&#x3D;&#x3D;key_len&#x3D;&#x3D; ☆</p><p>用上的索引字节长度，<strong>检查是否充分利用索引</strong>，主要针对联合索引。加上了变长和null</p><p>长度为 2个索引列 * （数据长度<em>3 utf-8 + 2变长字段 + 1null）  606 &#x3D; 2 * （100</em>3+2+1）</p><p><code>EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#39;a&#39; AND key_part2 = &#39;b&#39;; </code>   606 </p></li><li><p>&#x3D;&#x3D;ref&#x3D;&#x3D;</p><p>和索引列比较的结构是什么：const、s1.id、func等</p><p><code>WHERE s2 = &#39;a&#39;;</code>  <code>s1 INNER JOIN s2 ON s1.id = s2.id;</code>    <code>INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);</code></p></li><li><p>&#x3D;&#x3D;rows&#x3D;&#x3D;☆</p><p>预估的需要读取的记录条数，<code>值越小越好</code>。</p></li><li><p>&#x3D;&#x3D;filtered&#x3D;&#x3D;</p><p>加入条件时，剩下数据的比例。在驱动表中剩下越少，循环下一张表次数也就越少</p></li><li><p>&#x3D;&#x3D;Extra&#x3D;&#x3D;☆</p><ul><li><p><code>No tables used</code> </p></li><li><p><code>Impossible WHERE</code> where 永远false</p></li><li><p><code>Using where</code> 普通列</p></li><li><p><code>No matching min/max row</code> 有聚合函数但没有数据</p></li><li><p><code>Using index</code> 索引覆盖</p></li><li><p><code>Using index condition</code>   索引完后，先过滤key1 LIKE ‘%a’再去主表查询，<code>索引条件下推</code></p><p>​SELECT * FROM s1 WHERE key1 &gt; ‘z’ AND key1 LIKE ‘%a’; </p></li><li><p><code>Using join buffer (Block Nested Loop)</code>  被驱动表无索引，使用内存加速 <code>基于块的嵌套循环算法</code></p></li><li><p><code>Using filesort</code> 对普通列order by，需在内存或磁盘排序。慢！</p></li><li><p><code>Using temporary</code> 使用临时表：DISTINCT、 GROUP BY、UNION。<code>代价很大，最好使用索引来替代临时表</code></p></li></ul></li></ol><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><ol><li>传统格式</li><li>JSON格式  EXPLAIN FORMAT&#x3D;JSON</li><li>TREE格式  EXPLAIN FORMAT&#x3D;tree</li><li>Workbench可视化  快速查看</li></ol><h3 id="⑥-SHOW-WARNINGS"><a href="#⑥-SHOW-WARNINGS" class="headerlink" title="⑥ SHOW WARNINGS"></a>⑥ SHOW WARNINGS</h3><p><strong>查看完整SQL语句</strong>，涉及到内查询等优化器可能会帮我们优化掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * from s1 where key1 in (select key2 from s2 where common_field = &#x27;a&#x27;);<br>show warnings; # 内查询优化成了连接<br></code></pre></td></tr></table></figure><h3 id="⑦-trace：分析优化器执行"><a href="#⑦-trace：分析优化器执行" class="headerlink" title="⑦ trace：分析优化器执行"></a>⑦ trace：分析优化器执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 开启，结果保存到information_schema.optimizer_trace中<br>SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;<br>set optimizer_trace_max_mem_size=1000000;<br><br>select * from student where id &lt; 10;<br><br>select * from information_schema.optimizer_trace\G<br></code></pre></td></tr></table></figure><h3 id="⑧-sys-schema-：MySQL监控分析视图"><a href="#⑧-sys-schema-：MySQL监控分析视图" class="headerlink" title="⑧ sys schema ：MySQL监控分析视图"></a>⑧ sys schema ：MySQL监控分析视图</h3><p>查询需要消耗大量资源。查询结果来自  全部的数据库  的 全部的表</p><p>索引情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 查询冗余索引<br>select * from sys.schema_redundant_indexes;<br>#2. 查询未使用过的索引<br>select * from sys.schema_unused_indexes;<br>#3. 查询索引的使用情况<br>select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted<br>from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27;;<br></code></pre></td></tr></table></figure><p>表相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 查询表的访问量<br>select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from<br>sys.schema_table_statistics group by table_schema,table_name order by io desc;<br># 2. 查询占用bufferpool较多的表<br>select object_schema,object_name,allocated,data<br>from sys.innodb_buffer_stats_by_table order by allocated limit 10;<br># 3. 查看表的全表扫描情况<br>select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;<br></code></pre></td></tr></table></figure><p>语句相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 监控SQL执行的频率<br>select db,exec_count,query from sys.statement_analysis<br>order by exec_count desc;<br>#2. 监控使用了排序的SQL<br>select db,exec_count,first_seen,last_seen,query<br>from sys.statements_with_sorting limit 1;<br>#3. 监控使用了临时表或者磁盘临时表的SQL<br>select db,exec_count,tmp_tables,tmp_disk_tables,query<br>from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0<br>order by (tmp_tables+tmp_disk_tables) desc;<br></code></pre></td></tr></table></figure><p>IO相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 查看消耗磁盘IO的文件<br>select file,avg_read,avg_write,avg_read+avg_write as avg_io<br>from sys.io_global_by_file_by_bytes order by avg_read limit 10;<br></code></pre></td></tr></table></figure><p>Innodb 相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 行锁阻塞情况<br>select * from sys.innodb_lock_waits;<br></code></pre></td></tr></table></figure><h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="~索引优化与查询优化"></a>~索引优化与查询优化</h2><p>需要调优的角度：</p><ul><li>索引失效、没有充分利用到索引——建立索引  <code>物理查询优化</code></li><li>关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化 <code>逻辑查询优化</code></li><li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li><li>数据过多——分库分表</li></ul><h3 id="①-数据准备"><a href="#①-数据准备" class="headerlink" title="① 数据准备"></a>① 数据准备</h3><p><code>学员表</code> 插 <code>50万</code> 条，<code> 班级表</code> 插 <code>1万</code> 条。</p><h3 id="②-索引失效案例☆"><a href="#②-索引失效案例☆" class="headerlink" title="② 索引失效案例☆"></a>② 索引失效案例☆</h3><p>用B+树推理出来即可！</p><h4 id="2-1-全值匹配我最爱"><a href="#2-1-全值匹配我最爱" class="headerlink" title="2.1 全值匹配我最爱"></a>2.1 全值匹配我最爱</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 没有索引时全部遍历<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30;<br></code></pre></td></tr></table></figure><h4 id="2-2-最佳左前缀法则"><a href="#2-2-最佳左前缀法则" class="headerlink" title="2.2 最佳左前缀法则"></a>2.2 最佳左前缀法则</h4><p>最左边能匹配就能用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_age_classid_name ON student(age,classId,name);<br><br># 能用<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId=4;<br><br># 不能用<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId=4 AND student.age=30 AND student.name = &#x27;abcd&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-3-主键插入顺序"><a href="#2-3-主键插入顺序" class="headerlink" title="2.3 主键插入顺序"></a>2.3 主键插入顺序</h4><p>主键<code>AUTO_INCREMENT</code> ，防止<strong>页面分裂</strong>：把本页中的一些记录移动到新创建的这个页中</p><h4 id="2-4-计算、函数、类型转换-自动或手动-导致索引失效"><a href="#2-4-计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="2.4 计算、函数、类型转换(自动或手动)导致索引失效"></a>2.4 计算、函数、类型转换(自动或手动)导致索引失效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_name ON student(NAME);<br># 可以用上<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;<br><br># 函数千奇百怪，不知道返回什么，所以用不上<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-5-类型转换导致索引失效"><a href="#2-5-类型转换导致索引失效" class="headerlink" title="2.5 类型转换导致索引失效"></a>2.5 类型转换导致索引失效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 未使用到索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;<br># 使用到索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-6-范围条件右边的列索引失效"><a href="#2-6-范围条件右边的列索引失效" class="headerlink" title="2.6 范围条件右边的列索引失效"></a>2.6 范围条件右边的列索引失效</h4><p>联合索引，范围查询的后面列无法用上索引。但<code>c2 like &#39;c%&#39;</code>后面的可以用上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CAll proc_drop_index(&#x27;atguigudb2&#x27;, &#x27;student&#x27;);<br>CREATE INDEX idx_age_classid_name ON student(age,name,classId);<br><br># 用不上 key_len=68<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 3 and name &gt; &#x27;c&#x27; and classId = 20;<br># 用得上 key_len=73<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 3 and name like &#x27;c%&#x27; and classId = 20;<br></code></pre></td></tr></table></figure><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。创建的联合索引中，务必把范围涉及到的字段写在最后</p></blockquote><h4 id="2-7-不等于-x3D-或者-lt-gt-索引失效"><a href="#2-7-不等于-x3D-或者-lt-gt-索引失效" class="headerlink" title="2.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效"></a>2.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效</h4><p>不等于不能用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name &lt;&gt; &#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-8-is-null可以使用索引，is-not-null无法使用索引"><a href="#2-8-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="2.8 is null可以使用索引，is not null无法使用索引"></a>2.8 is null可以使用索引，is not null无法使用索引</h4><p>道理同上</p><blockquote><p>结论：最好在设计数据库的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将 INT 类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)。</p><p>扩展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描。</p></blockquote><h4 id="2-9-like以通配符-开头索引失效"><a href="#2-9-like以通配符-开头索引失效" class="headerlink" title="2.9 like以通配符%开头索引失效"></a>2.9 like以通配符%开头索引失效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name LIKE &#x27;%ab&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>拓展：Alibaba《Java开发手册》 </p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><h4 id="2-10-OR-前后存在非索引的列，索引失效"><a href="#2-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="2.10 OR 前后存在非索引的列，索引失效"></a>2.10 OR 前后存在非索引的列，索引失效</h4><p>or纯在非索引导致失效，and不会</p><p>因为OR的含义就是两个只要满足一个即可，因此<code>只有一个条件列进行了索引是没有意义的</code>，只要有条件列没有进行索引，就会进行<code>全表扫描</code>，因此所以的条件列也会失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 加入只有age有索引<br># 未使用到索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;<br></code></pre></td></tr></table></figure><h4 id="2-11-数据库和表的字符集统一使用utf8mb4"><a href="#2-11-数据库和表的字符集统一使用utf8mb4" class="headerlink" title="2.11 数据库和表的字符集统一使用utf8mb4"></a>2.11 数据库和表的字符集统一使用utf8mb4</h4><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不 同的 <code>字符集</code> 进行比较前需要进行 <code>转换</code> 会造成索引失效。</p><h3 id="③-关联查询优化"><a href="#③-关联查询优化" class="headerlink" title="③ 关联查询优化"></a>③ 关联查询优化</h3><h4 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h4><h4 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h4><p>不是绝对的左边为驱动表，如果左边有索引可能会变成被驱动表</p><p>驱动表<code>Using joion buffer</code> 使用缓存；添加索引被驱表可以走索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;<br></code></pre></td></tr></table></figure><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><p>优化器选择驱动表，选择有索引的或者大表作为被驱动表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;<br></code></pre></td></tr></table></figure><h4 id="JOIN原理"><a href="#JOIN原理" class="headerlink" title="JOIN原理"></a>JOIN原理</h4><p>MySQL5.5版本之前，只有嵌套循环。后来引入BNLJ算法优化嵌套查询。8.0.18引入Hash Join</p><h5 id="1-Simple-Nested-Loop-Join"><a href="#1-Simple-Nested-Loop-Join" class="headerlink" title="1.Simple Nested-Loop Join"></a>1.Simple Nested-Loop Join</h5><p>简单嵌套循环连接：相当于两层循环。比较了<code>A * B</code>次，读取了A+AB次记录。</p><h5 id="2-Index-Nested-Loop-Join"><a href="#2-Index-Nested-Loop-Join" class="headerlink" title="2. Index Nested-Loop Join"></a>2. Index Nested-Loop Join</h5><p>索引嵌套循环连接：被驱表走索引然后回表。比较<code>A*height</code>，读取了<code>A+B(match)</code></p><h5 id="3-Block-Nested-Loop-Join"><a href="#3-Block-Nested-Loop-Join" class="headerlink" title="3.Block Nested-Loop Join"></a>3.Block Nested-Loop Join</h5><p>块嵌套循环连接：引入块join buffer，把驱动表（分成一个个块）放在缓存中。被驱动一次比较一块驱动表记录，相当于外层循环变小了</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055488.png" alt="image-20230304103951379"></p><p>通过<code>show variables like &#39;%optimizer_switch%&#39;</code> 查看 <code>block_nested_loop</code>状态。默认是开启的。</p><p>这里缓存的不只是关联表的列，select后面的列也会缓存起来。</p><p>比较了<code>A * B</code>，读取了 <code>A + 块数*B</code>，访问磁盘次数少了</p><blockquote><p> join_buffer_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。</p></blockquote><h5 id="4-Hash-Join"><a href="#4-Hash-Join" class="headerlink" title="4. Hash Join"></a>4. Hash Join</h5><p><strong>等值连接</strong>。对BNLJ进一步优化，针对小表直接建立Hash表，大表每一条比较时间降低到O1</p><p>如果能完全放下小表，时间为A+B。如果不能放下需分块，相当于大表还是一次比较一整块记录，但时间优化到O1</p><h3 id="④-子查询"><a href="#④-子查询" class="headerlink" title="④ 子查询"></a>④ 子查询</h3><p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询 <code>不需要建立临时表</code> ，其 <code>速度比子查询</code> 要快 ，如果查询中使用索引的话，性能就会更好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM student stu1<br>WHERE stu1.`stuno` IN (<br>SELECT monitor<br>FROM class c<br>WHERE monitor IS NOT NULL<br>)<br># 优化<br>EXPLAIN SELECT stu1.* FROM student stu1 JOIN class c<br>ON stu1.`stuno` = c.`monitor`<br>WHERE c.`monitor` is NOT NULL;<br></code></pre></td></tr></table></figure><h3 id="⑤-排序"><a href="#⑤-排序" class="headerlink" title="⑤ 排序"></a>⑤ 排序</h3><p><code>FileSort</code> （内存中，占CPU）或 <code>Index</code> 排序。</p><p>还可以使用联合索引，where用一部分，order后一部分， <code>WHERE a = const AND b = const ORDER BY c</code></p><p>是否用所以还需要看排序代价，不大可以直接排序</p><h4 id="双路和单路排序"><a href="#双路和单路排序" class="headerlink" title="双路和单路排序"></a>双路和单路排序</h4><p>双路：只拿排序列数据，排完序后再全部遍历取出需要列。</p><p>单路：直接所有需要列区排序，但需要更多<code>sort_buffer_size</code>，默认1MB。如果数据量大于<code>max_length_for_sort_data</code>（1024~8192B）转用单路。</p><p>所以select * 在这是大忌。</p><ul><li>where效率高于having，能写在where限定的条件就不要写在having中了 </li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内</li></ul><h3 id="⑥-优化分页查询"><a href="#⑥-优化分页查询" class="headerlink" title="⑥ 优化分页查询"></a>⑥ 优化分页查询</h3><p><code>select * from sutdent limit 1000000,10</code>这种头疼问题</p><p>本来需要回表&gt;1000000，现在只需要回表10；使用连接优化子查询</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055489.png" alt="image-20230304122824862"></p><h3 id="⑦-索引覆盖"><a href="#⑦-索引覆盖" class="headerlink" title="⑦ 索引覆盖"></a>⑦ 索引覆盖</h3><p><code>索引列+主键</code> 包含 <code>SELECT 到 FROM之间查询的列</code> </p><p>索引覆盖可以提高速度，回表的IO很可能是随机IO（数据不连续）。但有维护代价，业务DBA（业务数据架构师）的工作。</p><p>此外，就算使用！&#x3D;导致索引失效，如果可以索引覆盖还是会去使用索引，因为二级索引更小遍历代价更低。</p><h3 id="⑧-索引条件下推"><a href="#⑧-索引条件下推" class="headerlink" title="⑧ 索引条件下推"></a>⑧ 索引条件下推</h3><p>​&#x3D;&#x3D;先过滤再回表&#x3D;&#x3D;</p><p>通常针对联合索引，(c1, c2, c3)   c1能使用但c2 c3用不了。c1用完索引后先c2 c3遍历过滤后再回表。</p><p>ICP的开启和关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set optimizer_switch = &#x27;index_condition_pushdown=on&#x27;  或者off<br><br>执行语句时关闭<br>select /*+ no_icp (table_name) */ * from table_name  where ...<br></code></pre></td></tr></table></figure><h3 id="⑨-其他优化策略"><a href="#⑨-其他优化策略" class="headerlink" title="⑨ 其他优化策略"></a>⑨ 其他优化策略</h3><h4 id="exists-和-in"><a href="#exists-和-in" class="headerlink" title="exists 和 in"></a>exists 和 in</h4><p>exists用外表驱动内表，拿一条条外表数据去内表查（相关子查询）       适合外小内大<br>in反过来，先查询内表，再拿数据去外表走索引                        </p><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT(*)"></a>COUNT(*)</h4><p><code>SELECT COUNT(*) 、 SELECT COUNT(1)</code>基本等价，效率相等，&#x3D;&#x3D;自动选取小空间的二级索引&#x3D;&#x3D;。MyISAM维护了变量</p><p><code>SELECT COUNT(具体字段)</code>尽量建立二级索引。</p><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT(*)"></a>SELECT(*)</h4><ul><li>需要先查询数据字典将*转换为列名</li><li>无法使用覆盖索引</li><li>空间更大</li></ul><h4 id="LIMIT-1"><a href="#LIMIT-1" class="headerlink" title="LIMIT 1"></a>LIMIT 1</h4><p>在确定数据唯一，并且无唯一索引时，可以提前结束扫描，加速。</p><h4 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h4><p>COMMIT 所释放的资源： </p><ul><li>回滚段上用于恢复数据的信息 </li><li>被程序语句获得的锁 </li><li>redo &#x2F; undo log buffer 中的空间 </li><li>管理上述 3 种资源中的内部花费</li></ul><h3 id="⑩-淘宝数据库，主键如何设计的？"><a href="#⑩-淘宝数据库，主键如何设计的？" class="headerlink" title="⑩ 淘宝数据库，主键如何设计的？"></a>⑩ 淘宝数据库，主键如何设计的？</h3><h4 id="自增ID的问题"><a href="#自增ID的问题" class="headerlink" title="自增ID的问题"></a>自增ID的问题</h4><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除 了简单，其他都是缺点，总体来看存在以下几方面的问题：</p><ol><li><p><strong>可靠性不高</strong></p><p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。 </p></li><li><p>**安全性不高 **</p><p>对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F;这样的接口，可以非常容易猜测用户ID的 值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。 </p></li><li><p><strong>性能差</strong> </p><p>自增ID的性能较差，需要在数据库服务器端生成。 </p></li><li><p><strong>交互多</strong> </p><p>业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的 网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。 </p></li><li><p>**局部唯一性 **</p><p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都 是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p></li></ol><h4 id="业务字段做主键"><a href="#业务字段做主键" class="headerlink" title="业务字段做主键"></a>业务字段做主键</h4><p>会员卡中的卡号：但如果用户注销了，购买记录还会给新的人。</p><p>身份证号：隐私问题等</p><blockquote><p>经验： 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业 务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p></blockquote><h4 id="淘宝的主键设计"><a href="#淘宝的主键设计" class="headerlink" title="淘宝的主键设计"></a>淘宝的主键设计</h4><p>淘宝的订单号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1550672064762308113<br>1481195847180308113<br>1431156171142308113<br>1431146631521308113<br><br>猜测：订单ID = 时间 + 去重字段 + 用户ID后6位尾号<br></code></pre></td></tr></table></figure><h4 id="推荐主键设计"><a href="#推荐主键设计" class="headerlink" title="推荐主键设计"></a>推荐主键设计</h4><p><strong>非核心业务</strong> ：对应表的主键自增ID，如告警、日志、监控等信息。</p><p><strong>核心业务</strong> ：<code>主键设计至少应该是全局唯一且是单调递增</code>。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。</p><h5 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h5><p>32个16进制数，纯数占用16B。实际占用36B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）<br><br>时间：100ns区别。秒在前面所以不是自增<br>36字节：字符串存储，且带有无用字符-<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055490.png" alt="image-20230305102015371"></p><h5 id="改造UUID"><a href="#改造UUID" class="headerlink" title="改造UUID"></a><strong>改造UUID</strong></h5><p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0</p><p>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的<code>-</code>字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p><p>MySQL8.0提供<code>uuid_to_bin</code>，<code>bin_to_uuid</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @uuid = UUID();<br>SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);<br></code></pre></td></tr></table></figure><h5 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h5><p>mybatis-plus默认，并且会将id自动set到实体对象中</p><ol><li>能满足高并发分布式系统环境下ID不重复</li><li>基于时间戳，可以保证基本有序递增</li><li>不依赖第三方的库或者中间件</li><li>生成效率极高</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> - <span class="hljs-number">0000000000</span> <span class="hljs-number">0000000000</span> <span class="hljs-number">0000000000</span> <span class="hljs-number">0000000000</span> <span class="hljs-number">0</span> - <span class="hljs-number">0000000000</span> - <span class="hljs-number">000000000000</span><br><br>符号位             时间戳                                机器码      序列号<br><span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="hljs-comment">//</span><br>                | (workerId &lt;&lt; workerIdShift) <span class="hljs-comment">//</span><br>                | sequence;<br></code></pre></td></tr></table></figure><ul><li>41位存储毫秒级时间戳，这个时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的ID生成器开始使用的时间，一般为项目创建时间，就是下面实现中代码的twepoch 属性，生成器根据时间戳插值进行初次尝试创建ID。</li><li>10位存储机器码，最多支持1024台机器，当并发量非常高，同时有多个请求在同一毫秒到达，可以根据机器码进行第二次生成。机器码可以根据实际需求进行二次划分，比如两个机房操作可以一个机房分配5位机器码。</li><li>12位存储序列号，当同一毫秒有多个请求访问到了同一台机器后，此时序列号就派上了用场，为这些请求进行第三次创建，最多每毫秒每台机器产生2的12次方也就是4096个id，满足了大部分场景的需求。</li></ul><blockquote><p>在Web开发中需要跟js打交道，而js支持最大的整型范围为53位，超过这个范围就会丢失精度，53之内可以直接由js读取，超过53位就需要转换成字符串才能保证js处理正确。</p><p>或者53位存储的话，32位存储秒级时间戳，5位存储机器码，16位存储序列化，这样每台机器每秒可以生产65536个不重复的id。</p></blockquote><h2 id="数据库设计规则"><a href="#数据库设计规则" class="headerlink" title="~数据库设计规则"></a>~数据库设计规则</h2><p>什么数据 什么表、crud时的约束检查、减低数据冗余度、方便数据库维护使用</p><p>表结构的调整代价很大</p><h3 id="①-范数"><a href="#①-范数" class="headerlink" title="① 范数"></a>① 范数</h3><p>关系型数据库的基本原则。但有时为了提高性能还会破坏规则，反规范化（降低冗余度，但业务可能复杂了）</p><p>六种：</p><ul><li>第一范式：列不能再分</li><li>第二范式：非主属性消除部分依赖</li><li>第三范式：非主属性消除传递依赖（平衡）</li><li>巴斯-科德范式：候选键只有一个，或者每个候选键都是单属性。主属性消除部分依赖</li><li>第四范式：不存在多组 多值依赖（一对多）：职工表（职工id，孩子姓名，职工课程），需要拆开</li><li>第五范式：理论研究</li></ul><p>找出所有码 -&gt; 主属性、非主属性 -&gt; 检查部分函数依赖 -&gt; 检查传递函数依赖</p><h4 id="键和相关概念"><a href="#键和相关概念" class="headerlink" title="键和相关概念"></a>键和相关概念</h4><ul><li><code>超键</code>：能唯一标识元组的属性集</li><li><code>候选键</code>：超键且不包括多余属性，可以多个 ；码</li><li><code>主键</code>：从候选键中选一个</li><li><code>外键</code>：R1中的属性不是R1的主键，而是R2的</li><li><code>主属性</code>：所有候选键中的所有属性</li><li><code>非主属性</code></li></ul><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>每个字段都<strong>不能拆分</strong>了，如不能把电话、姓名、地址都放到一个字段中。</p><p>first name，lastname是否拆分要看具体的业务需求</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p><strong>所有非主键完全依赖于候选键</strong>，如果存在<code>部分依赖，则抽出来新建表</code></p><p>成绩表：要想知道成绩，完全依赖于（学号、课程号）</p><p>在学生的成绩表中，不再放学生的地址等信息</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>非主属性C直接相关于主属性A，而不能依赖于其他非主属性B：主属性A-&gt;非主属性B-&gt;非属性C</p><p><strong>员工表</strong>中只放部门编号，不放部门其他信息，这些信息可以通过join查询获得</p><p><strong>商品表</strong>中只放商品类别id，不放类别名称</p><h3 id="②-反范式"><a href="#②-反范式" class="headerlink" title="② 反范式"></a>② 反范式</h3><p><code>业务优先</code>，增加冗余字段来提高读性能。空间换时间。<code>冗余字段修改需要同步</code></p><p><strong>员工表</strong>的查询经常要部门名称，加进来；商品表同理。<strong>违反了第三范式</strong></p><p><strong>学生表</strong>和<strong>课程评论表</strong>，查询课程的评论时经常要用学生名称</p><p>学生表100w，评论表100w</p><p>查询某课程的前10000条评论的姓名和评论；反范式化后，把学生姓名加入评论表</p><p>0.1 -&gt; 0.036</p><p>&#x3D;&#x3D;条件&#x3D;&#x3D;：冗余字段不常修改  且  查询时必要</p><h2 id="数据库其他调优"><a href="#数据库其他调优" class="headerlink" title="~数据库其他调优"></a>~数据库其他调优</h2><p>从更大的层面来优化，主要就是下面这张表。垂直分库分表、读写分离</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055491.png" alt="image-20230307161933988"></p><p><strong>目标</strong>：吞吐量更大、响应速度更快</p><p><strong>问题发现</strong>：用户反馈、日志</p><h3 id="①-调优步骤"><a href="#①-调优步骤" class="headerlink" title="① 调优步骤"></a>① 调优步骤</h3><h4 id="1-合适的DBMS"><a href="#1-合适的DBMS" class="headerlink" title="1.合适的DBMS"></a>1.合适的DBMS</h4><p>事务以及安全性要求高，选择SQL Server、Oracle。单表可以存储上亿条数据。</p><h4 id="2-优化表设计"><a href="#2-优化表设计" class="headerlink" title="2.优化表设计"></a>2.优化表设计</h4><p>尽量遵循第三范式 并且 适当运用反范式</p><p>数据类型选择合适的</p><h4 id="3-优化逻辑查询"><a href="#3-优化逻辑查询" class="headerlink" title="3.优化逻辑查询"></a>3.优化逻辑查询</h4><p>SQL的重写：子查询变join</p><h4 id="4-优化物理查询"><a href="#4-优化物理查询" class="headerlink" title="4.优化物理查询"></a>4.优化物理查询</h4><p>索引</p><h4 id="5-使用Redis缓存"><a href="#5-使用Redis缓存" class="headerlink" title="5.使用Redis缓存"></a>5.使用Redis缓存</h4><p>redis支持持久化，除了内存还可以将数据放到硬盘上</p><h4 id="6-库级优化"><a href="#6-库级优化" class="headerlink" title="6.库级优化"></a>6.库级优化</h4><p>站在数据库维度进行优化。</p><p>多台机器读写分离、<code>分库分表</code>切割数据库</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055491.png" alt="image-20230307161933988"></p><h3 id="②-优化MySQL服务器"><a href="#②-优化MySQL服务器" class="headerlink" title="② 优化MySQL服务器"></a>② 优化MySQL服务器</h3><p>硬件层面：<code>大内存</code>、<code>高速磁盘系统(SCSI -&gt; SSD) </code>，<code>合理分布磁盘I/O</code>，<code>配置多处理器</code></p><p>MySQL参数：<code>innodb_buffer_pool_size (表、索引)</code>、<code>key_buffer_size </code>、<code>table_cache </code>、<code>query_cache_size(查询缓存、8.0没有)</code>、<code>sort_buffer_size(排序)</code>、<code>join_buffer_size(join缓存)</code>、<code>max_connections(默认151)</code></p><h3 id="③-表结构优化"><a href="#③-表结构优化" class="headerlink" title="③ 表结构优化"></a>③ 表结构优化</h3><h4 id="冷热数据分离"><a href="#冷热数据分离" class="headerlink" title="冷热数据分离"></a>冷热数据分离</h4><p>拆分：<code>会员表</code> 存储会员登录认证信息，该表中有很多字段，如<code>id、姓名、密码、地址、电 话、个人描述</code>字段。其中<code>地址、电话、个人描述</code>等字段并不常用，可以将这些不常用的字段分解出另一个表。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055492.png" alt="image-20230307161748616"></p><h4 id="增加中间表"><a href="#增加中间表" class="headerlink" title="增加中间表"></a>增加中间表</h4><p>经常需要联合查询的数据，直接多开一个中间表</p><h4 id="增加冗余字段"><a href="#增加冗余字段" class="headerlink" title="增加冗余字段"></a>增加冗余字段</h4><p>反范数</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>整数</strong>：通常int，unsigned要用就用</p><p><strong>TIMESTAMP</strong>：TIMESTAMP存储的时间范围1970-01-01 00:00:01 ~ 2038-01_19-03:14:07。TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。</p><p><strong>DECIMAL</strong>代替FLOAT和DOUBLE存储精确浮点数：精准的浮点数、4B存储9位，且可以存储比bigint大的整型数据</p><h3 id="④-大表优化"><a href="#④-大表优化" class="headerlink" title="④ 大表优化"></a>④ 大表优化</h3><h4 id="1-限定查询的范围"><a href="#1-限定查询的范围" class="headerlink" title="1 限定查询的范围"></a>1 限定查询的范围</h4><p>禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制 在一个月的范围内；</p><h4 id="2-读-x2F-写分离"><a href="#2-读-x2F-写分离" class="headerlink" title="2 读&#x2F;写分离"></a>2 读&#x2F;写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055493.png" alt="image-20230307161543744"></p><h4 id="3-垂直拆分"><a href="#3-垂直拆分" class="headerlink" title="3.垂直拆分"></a>3.垂直拆分</h4><p>冷热数据分离，也可以是经常使用的放一起</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055494.png" alt="image-20230307161824905"></p><h4 id="4-水平拆分"><a href="#4-水平拆分" class="headerlink" title="4.水平拆分"></a>4.水平拆分</h4><p>数据量尽量控制在1000w以内</p><p>按某个属性如年份划分到不同的表</p><p>但表数据还是同一个机器上，并发量还是上不去，还是<code>分库</code>比较好。</p><p>拆分会带来逻辑、部署、运维的复杂度</p><h2 id="事务"><a href="#事务" class="headerlink" title="~事务"></a>~事务</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055495.png" alt="image-20230311180107196"></p><p>MySQL中，只有InnoDB支持事务。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a><strong>ACID</strong></h4><p><strong>原子性（atomicity）：</strong> 不可分割</p><p><strong>一致性（consistency）：</strong> 数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。</p><p><strong>隔离型（isolation）：</strong><code>不能被其他事务干扰</code>，<strong>锁</strong>来实现。下小节为对应隔离级别</p><p><strong>持久性（durability）：</strong> 提交后<code>永久改变</code>。通过 <code>事务日志</code>（<code>重做日志</code> 和 <code>回滚日志</code>）来实现</p><h4 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h4><p>提交或者中止是一个事务生命周期的结束</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055496.png" alt="image-20230311175427170" style="zoom: 50%;" /><h4 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 显式事务会关闭自动提交<br>BEGIN;<br>#或者<br>START TRANSACTION (READ ONLY \ READ WRITE);<br><br>SAVEPOINT savepoint_name<br># 将事务回滚到某个保存点。 事务还没结束<br>ROLLBACK TO [SAVEPOINT]<br><br>## 结束事务<br># 提交事务。当提交事务后，对数据库的修改是永久性的。<br>COMMIT;<br># 回滚事务。即撤销正在进行的所有没有提交的修改<br>ROLLBACK;<br></code></pre></td></tr></table></figure><h4 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;autocommit&#x27;; <br>ON # 每个语句自动提交事务<br>SET autocommit = on\1 ;  OFF\0<br></code></pre></td></tr></table></figure><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>在并发场景下（若干个客户端连接），如何处理隔离</p><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><ol><li><p><strong>脏写</strong>（ Dirty Write ）：B在更新时，A先更新且commit了，但B rollback了，吞掉了A的更新。（实际上A需要排队）</p></li><li><p><strong>脏读</strong>（ Dirty Read ）：读取到了还没commit的数据</p></li><li><p><strong>不可重复读</strong>（ Non-Repeatable Read ）：一个事务两次读之间，值被别的人commit改了，导致每次读取不一样</p></li><li><p><strong>幻读</strong>（ Phantom ）：两次读之间，<code>插入</code>了一些新行（幻影记录）。</p></li></ol><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>解决上面的问题</p><p>1.<strong>读未提交</strong>（Read uncommitted）：内存有直接读内存</p><p>​    这种事务隔离级别下，select语句不加锁。</p><p>​    此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。</p><p>2.<strong>读已提交</strong>（Read committed）：读磁盘  Oracle</p><p>​    可避免 脏读 的发生。</p><p>​    在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。</p><p>3.<strong>可重复读</strong>（Repeatable read）：MySql  <code>SHOW VARIABLES LIKE &#39;tx_isolation&#39;;</code> <code>transaction_isolation</code></p><p>​    事务开始前尽可能创建快照（内存）。</p><p>​查询时<strong>先在快照区</strong>中查找数据的快照，如果快照区中没有该数据的快照，MySQL 就会<strong>再 undo 日志</strong>中查找该数据最新的修改操作，并将其还原到快照区中，然后再将数据返回给事务</p><p>​mysql其实也可以解决幻读，在锁里讲</p><p>4.<strong>串行化</strong>（Serializable ）：</p><p>​    可避免幻读</p><p>​加了行X锁，比如s1查询了id&#x3D;3的数据，s2的插入就会阻塞</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055497.png" alt="image-20230311183443046"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql，想永久修改需要修改配置文件<br>SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#x27;隔离级别&#x27;<br>#其中，隔离级别格式：<br>&gt; READ-UNCOMMITTED<br>&gt; READ-COMMITTED<br>&gt; REPEATABLE-READ<br>&gt; SERIALIZABLE<br></code></pre></td></tr></table></figure><blockquote><p>隔离级别越高，数据一致性就越好，但并发性越弱。</p></blockquote><h2 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h2><p>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。存储引擎层 (innodb) 生成</p><ul><li><p>REDO LOG 称为 <code>重做日志 </code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<strong>持久性</strong>。</p><p><code>&quot;物理级别&quot;</code>上的页修改操作，比如页号xxx，偏移量yyy写入了’zzz’数据。</p></li><li><p>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的<strong>原子性</strong>、一致性。</p><p> <code>逻辑操作</code> 日志，INSERT则会记录一条对应DELETE。用于 <code>事务的回滚</code>和 <code>一致性非锁定读</code></p></li></ul><p>COMMIT用REDO实现，ROLLBACK用UNDO实现。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055498.png" alt="image-20230313105558624"></p><h3 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h3><p>保证事务的<strong>持久性</strong>。</p><ul><li>首先需要读取<code>磁盘</code> -&gt; 内存中的<code>Buffer Pool</code></li><li>发生修改更先更新<code>Buffer Pool</code>，再更新<code>磁盘</code>；更新了但没写入磁盘的叫<code>脏页</code>。</li><li>内存是正确的，但刷盘是比较慢的且可能宕机， 为了保证磁盘数据是正确的：<ol><li>疯狂一直刷盘（代价大），并且事务修改不相邻页面时，IO是<code>随机IO</code></li><li>引入redo日志</li></ol></li></ul><p>WAL技术 (<code>Write-Ahead Logging</code>)：先写日志（写入了就算事务成功），再写磁盘。</p><p>实现更低频率更高速度的刷盘：</p><ul><li>低频：redo日志占用的<code>空间小</code>（存储表空间ID、页号、偏移量以及需要更新的值）</li><li>高速：<code>顺序IO</code></li></ul><h4 id="redo特点"><a href="#redo特点" class="headerlink" title="redo特点"></a>redo特点</h4><ul><li><p><strong>redo日志是顺序写入磁盘的</strong></p><p>一个事务多条语句,一条语句多条redo日志，这些日志是按照<code>产生的顺序写入磁盘的</code>，也就是使用顺序ID，效率比随机IO快。</p></li><li><p><strong>事务执行过程中，redo log不断记录</strong></p><p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p></li></ul><h4 id="redo日志组成"><a href="#redo日志组成" class="headerlink" title="redo日志组成"></a>redo日志组成</h4><ul><li><code>重做日志的缓冲 (redo log buffer)</code>：内存 <code>innodb_log_buffer_size</code> 16MB</li><li><code>重做日志文件 (redo log file) </code>：mysql&#x2F;data&#x2F;ib_logfile0  ib_logfile1</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055499.png" alt="image-20230312214754687"></p><blockquote><p>先持久化日志，再持久化数据(在commit后才会持久化)</p></blockquote><p>至此，关键的刷盘变成了<code>步骤3</code>，由参数<code>innodb_flush_log_at_trx_commit</code>控制</p><ul><li><code>设置为0</code> ：表示每次事务提交时不进行刷盘操作。</li><li><code>设置为2</code> ：表示每次事务提交时都只把 <code>redo log buffer</code> 内容写入 <code>page cache</code>（OS对写入磁盘的优化，由OS决定，有小概率宕机），不进行同步。由os自己决定什么时候同步到磁盘文件。此时MYSQL挂了不影响</li><li><code>设置为1</code> ：表示每次事务提交时都将进行同步（写入<code>page cache</code>并<code>同步磁盘</code>）（ 默认值，持久性的保证 ）</li></ul><p>此外：系统默认master thread每隔<strong>1s</strong>进行一次重做日志的同步：<code>redo log buffer</code>到<code>page cache</code>，然后刷盘</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055500.png" alt="image-20230312223435328"></p><p>或者写满<code>innodb_log_buffer_size</code>后刷盘。</p><h4 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h4><p>一个原子操作为一个<code>Mini-Transaction</code>，如一次插入。但一次插入可能移动多条数据，对应多个redo</p><p>一个MTR里的多个redo需要放在一起（不可分割），但一个事务内的多个MTR可以分割存放</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055501.png" alt="image-20230313101247985" style="zoom:67%;" /><p>t1、t2为两个事务，mtr_t1_1由多条redo组成<br>buffer由block组成，一个block512字节 <code>innodb_log_block_size</code>，对应一个扇区的大小</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055502.png" alt="image-20230313101924121"></p><p>头包含指针、已使用多少等信息</p><h4 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h4><ul><li><p><code>innodb_log_group_home_dir</code> 文件路径</p></li><li><p><code>innodb_log_files_in_group</code> 默认2组</p></li><li><p><code>innodb_log_file_size</code>  单个 redo log 文件设置大小，默认值为 <code>48M</code> </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055503.png" alt="image-20230313104804144"></p><p><code>write pos</code>指针（终点）：当前插入点</p><p><code>checkpoint</code>指针（起点）：checkpoint 和 write pos 之间为在内存中但还没写入磁盘，故障后需要恢复这部分数据</p></li><li><p><code>innodb_flush_log_at_trx_commit</code> 刷盘策略</p></li></ul><h4 id="施放时间"><a href="#施放时间" class="headerlink" title="施放时间"></a>施放时间</h4><ul><li>redo log 在事务的执行过程中不断记录。通常在事务提交时buffer-&gt;file。</li><li>理论上redo log file中的文件在数据写入磁盘（图4）后可以释放</li></ul><h3 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h3><p>更新数据前先更新undo log。在系统表空间，也可以使用独立表空间</p><p><strong>原子性：</strong>要么都做，要么都不做。可能发生意外，如何<code>逻辑恢复</code>到之前状态</p><ul><li>服务器错误、断电</li><li>手动ROLLBACK</li></ul><p>增删改都要记录反向操作</p><blockquote><p> undo日志为了实现持久化，需要同样会<strong>产生redo日志</strong>。</p></blockquote><p>在内存数据更新前先更新undo</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>作用1：回滚数据</strong></li><li><strong>作用2：MVCC</strong>（多版本并发控制）。当读取一条被占用的数据时，用undo读取之前的信息</li></ul><h4 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h4><p><code>innodb_undo_logs</code>个回滚段。一个回滚段多个页，一个页（可服务于多个事务，重用防止浪费）存放undo记录，</p><h4 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h4><ol><li><code>未提交的回滚数据(uncommitted undo information)</code>：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。 （避免脏读）</li><li><code>已经提交但未过期的回滚数据(committed undo information)</code>：该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。（避免不可重复读）</li><li><code>事务已经提交并过期的数据(expired undo information)</code>：事务已经提交，而且数据保存时间已经超过 undo retention参数指定的时间，可覆盖</li></ol><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul><li>正常提交就是提交，redo log file写入了就持久化了。在正常情况下rollback，根据undo日志回滚</li><li>如果没commit且没redo log file但宕机了，数据只内存中，不用改磁盘，事务结束</li><li>如果没commit但有redo log file宕机了，可以选择rollback，或者继续事务</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055505.png" alt="image-20230313161236154"></p><p>行格式中，每行数据都会有一个<code>事务id</code>，以及<code>回滚指针</code>（指向undo的指针）</p><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p>undo log在操作过程中串联起来，记录下数据差异，回滚时逆向进行</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055506.png" alt="image-20230313161721869"></p><ol><li>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除 </li><li>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0 </li><li>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom </li><li>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>实现事务的<code>隔离性</code></p><p>并发访问时的安全性</p><h3 id="并发事务情况"><a href="#并发事务情况" class="headerlink" title="并发事务情况"></a>并发事务情况</h3><ul><li><strong>读-读</strong> ：无影响</li><li><strong>写-写</strong>：<code>脏写</code>  <strong>必须加锁</strong>。 先来的加锁，后来的排队。先来的完成后把后来的激活</li><li><strong>读-写</strong>：<code>脏读、不可重复读、幻读</code>    <strong>重点关注</strong></li></ul><h3 id="读写解决"><a href="#读写解决" class="headerlink" title="读写解决"></a>读写解决</h3><ol><li>读（MVCC），写（加锁）。下章</li><li>读写都加锁。但插入的数据无法加，无法解决幻读 ；读-写 操作彼此需要 <code>排队执行</code> ，影响性能。</li></ol><p>一般情况下我们当然愿意采用 <code>MVCC</code> 来解决 <code>读-写</code> 操作并发执行的问题，但是<strong>业务在某些特殊情况</strong>下，要求必须采用 <code>加锁 </code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p><h3 id="锁的类别"><a href="#锁的类别" class="headerlink" title="锁的类别"></a>锁的类别</h3><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055507.png" alt="image-20230313164720406"></p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>InnoDB可以加表上、也可以加行上</p><ul><li><p>共享锁S：读也可以加X锁，这里是手动加锁。(MVCC中的当前读)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT   LOCK IN SHARE MODE<br>SELECT   FOR UPDATE (nowait 锁了就直接返回、不等待)<br></code></pre></td></tr></table></figure></li><li><p>排他锁X：写锁，会阻断X和S。有S时也不能加X。一直等到超时</p><ul><li>DELETE：X锁</li><li>INSERT：<code>隐式锁</code>，因为一开始没有空间</li><li>UPDATE：<ul><li>修改了主键：先del再insert</li><li>空间没有变：X锁</li><li>空间变化了：相当于修改主键，先del再insert</li></ul></li></ul></li></ul><h4 id="表-行-页-锁"><a href="#表-行-页-锁" class="headerlink" title="表 行 页 锁"></a>表 行 页 锁</h4><p>粒度越小，开销越大，并发性越高。InnoDB提供到行锁</p><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p><strong>不依赖于存储引擎</strong>，策略一样</p><h6 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h6><p>表锁：InnoDB一般在崩溃恢复时才加，MyISAM默认</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">`LOCK TABLES t READ`   `S锁`<br>`LOCK TABLES t WRITE`  `X锁` <br><br># 查看<br>SHOW OPEN TABLES; # 主要关注In_use字段的值<br>或者<br>SHOW OPEN TABLES where In_use &gt; 0;<br><br>UNLOCK TABLES; # 使用此命令解锁当前加锁的表<br></code></pre></td></tr></table></figure><p>MyISAM&#x3D;&#x3D;默认会在执行CRUD时对整个表加锁&#x3D;&#x3D;，只能读-读，导致查询性能下降的原因。InnoDB不加</p><p>注意加锁后，不能操作别的表了</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055508.png" alt="image-20230316144257602"></p><h6 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h6><p>InnoDB原本想加表锁，需要遍历全部数据查看有没有行锁</p><p>A加了行X锁后，自动加一个表的<code>X意向锁</code>（代表A有意向去操作整张表）其他人B就加不了表锁。  存储引擎 <code>维护</code> </p><p>也就是B加锁前，除了看有没有锁，还要看有没有同级别的意向锁的存在</p><ul><li><strong>协调</strong>多粒度锁共存，方便在加表锁时，查看有没有行锁</li></ul><h6 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h6><p><code>AUTO_INCREMENT</code></p><p>多并发下如何实现自增</p><p>直接加锁 等、</p><h6 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h6><p>DDL操作加锁：别人在读数据时，你不能改表结构</p><h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><ul><li><strong>优点：</strong>锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。</li><li><strong>缺点：</strong>对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</li></ul><p>① <strong>记录锁</strong>（Record Locks）</p><p>​<code>LOCK_REC_NOT_GAP</code>，就是正常的X、S锁。只有S-S共享</p><p>​例：一个事务在更新（自动加X），另一个不可以<code>select .. lock in share mode</code>，但可以直接读（MVCC）</p><p>② <strong>间隙锁</strong>（Gap Locks）</p><p>​在RR级别下<strong>解决幻读</strong></p><p>（1）防止间隙内有新数据被插入<br>（2）防止已存在的数据，更新成间隙内的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t WHERE id BETWEEN 100 AND 200；<br>查询后，100~200之间加上间隙锁，禁止再插入数据<br></code></pre></td></tr></table></figure><p>③ <strong>临键锁</strong>（Next-Key Locks）</p><p>​一个<code>记录锁</code>和一个<code>gap锁</code>的合体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">begin;<br>select * from student where id &lt;=8 and id &gt; 3 for update;<br></code></pre></td></tr></table></figure><h5 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h5><p>页锁就是在 <code>页的粒度</code> ，粒度在表和行之间</p><h4 id="乐观锁悲观锁"><a href="#乐观锁悲观锁" class="headerlink" title="乐观锁悲观锁"></a>乐观锁悲观锁</h4><p><strong>悲观锁：</strong>认为别人会影响自己，总是加锁阻塞其他线程。数据库实现 <code>synchronized</code>  <code>ReentrantLock</code> </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055509.png" alt="image-20230316161045465"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055510.png" alt="image-20230316161155532"></p><p>加锁后等待时间较长，所有扫描到的数据都会锁定，因此必须要索引</p><p><strong>乐观锁</strong></p><p>不上锁。</p><p>在表中设计一个 <code>版本字段 version</code> ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 <code>UPDATE ... SET version=version+1 WHERE version=version</code> 。version不一样说明别人修改过了</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055511.png" alt="image-20230316161722838"></p><p>上面可能会导致失败太多，再更新。减库存前先判断</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055512.png" alt="image-20230316161931349"></p><p><code>乐观锁</code> 适合 <code>读操作多</code> ，悲观锁相反</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055513.png" alt="image-20230316162041048"></p><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>整个数据库只读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Flush tables with read lock<br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055514.png" alt="image-20230316163506070"></p><ol><li>互斥条件：资源不能被共享，即每个资源一次只能被一个进程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完后自己释放。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h5 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h5><p><strong>方式1：</strong>等待，直到超时（<code>innodb_lock_wait_timeout</code>&#x3D;50s)。不太好</p><p><strong>方式2：</strong>使用死锁检测处理死锁程序， <code>wait-for graph</code>算法</p><p>需要存储全部事务构建的锁信息，构建等待图，存在环就存在死锁</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055515.png" alt="image-20230316164435644" style="zoom: 80%;" /><p>一旦检测到回路、有死锁，这时候InnoDB存储引擎会选择<code>回滚undo量最小的事务</code>，让其他事务继续执行（<code>innodb_deadlock_detect=on</code>表示开启这个逻辑）。</p><p>复杂度还是比较高</p><h3 id="锁结构"><a href="#锁结构" class="headerlink" title="锁结构"></a>锁结构</h3><p>InnoDB使用锁信息来跟踪行级锁。锁信息（<code>lock_t</code>）存储在锁管理器（<code>lock manager</code>），去锁管理器中查询该行是否被锁定。</p><p><code>InnoDB</code> 存储引擎中的 <code>锁结构</code> 如下：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055516.png" alt="image-20220714132306208"></p><p>结构解析：</p><p><code>1. 锁所在的事务信息 </code>：</p><p>不论是 <code>表锁</code> 还是 <code>行锁</code> ，都是在事务执行过程中生成的，哪个事务生成了这个锁结构 ，这里就记录这个 事务的指针</p><p><code>2. 索引信息</code> ：</p><p>对于 <code>行锁</code> 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><p><code>3. 表锁／行锁信息</code> ：</p><p><code>表锁结构</code> 和 <code>行锁结构</code> 在这个位置的内容是不同的：</p><ul><li><p>表锁：</p><p>记载着是对哪个表加的锁，还有其他的一些信息。</p></li><li><p>行锁：</p><p>记载了三个重要的信息：</p><ul><li><code>Space ID</code> ：记录所在表空间。</li><li><code>Page Number</code> ：记录所在页号。</li><li><code>n_bits </code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个<code>n_bis</code>属性代表使用了多少比特位。</li></ul><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构</p></blockquote></li></ul><p><code>4. type_mode</code> ：</p><p>这是一个32位的数，被分成了 <code>lock_mode</code> 、 <code>lock_type</code> 和 <code>rec_lock_type</code> 三个部分，如图所示：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055517.png" alt="image-20220714133319666"></p><ul><li>锁的模式（ <code>lock_mode</code> ），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code> （十进制的 0 ）：表示共享意向锁，也就是 <code>IS锁</code> 。 </li><li><code>LOCK_IX</code> （十进制的 1 ）：表示独占意向锁，也就是 <code>IX锁</code> 。 </li><li><code>LOCK_S</code> （十进制的 2 ）：表示共享锁，也就是 <code>S锁</code> 。 </li><li><code>LOCK_X</code> （十进制的 3 ）：表示独占锁，也就是 <code>X锁</code> 。 </li><li><code>LOCK_AUTO_INC</code> （十进制的 4 ）：表示 <code>AUTO-INC锁</code> 。</li></ul></li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（ <code>lock_type</code> ），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code> （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC </code>（十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（ <code>rec_lock_type</code> ），使用其余的位来表示。只有在 <code>lock_type</code> 的值为 <code>LOCK_REC</code> 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code> （十进制的 0 ）：表示 <code>next-key锁</code> 。</li><li><code>LOCK_GAP</code> （十进制的 512 ）：也就是当第10个比特位置为1时，表示 <code>gap锁</code> 。</li><li><code>LOCK_REC_NOT_GAP</code> （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 <code>记录锁</code> 。</li><li><code>LOCK_INSERT_INTENTION</code> （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><code>is_waiting</code> 属性呢？基于内存空间的节省，所以把 <code>is_waiting</code> 属性放到了 <code>type_mode</code> 这个32 位的数字中：<ul><li><code>LOCK_WAIT</code> （十进制的 256 ） ：当第9个比特位置为 1 时，表示 <code>is_waiting</code> 为 <code>true</code> ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 <code>is_waiting</code> 为 <code>false</code> ，也就是当前事务获取锁成功。</li></ul></li></ul><p><code>5. 其他信息</code> ：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p><p><code>6. 一堆比特位</code> ：</p><p>如果是 <code>行锁结构</code> 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 <code>n_bits</code> 属性 表示的。InnoDB数据页中的每条记录在 <code>记录头信息</code> 中都包含一个 <code>heap_no</code> 属性，伪记录 <code>Infimum</code> 的 <code>heap_no</code> 值为 0 ， <code>Supremum</code> 的 <code>heap_no</code> 值为 1 ，之后每插入一条记录， <code>heap_no</code> 值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 <code>heap_no</code> ，即一个比特位映射 到页内的一条记录。</p><h3 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询正在被锁阻塞的sql语句。<br>SELECT * FROM information_schema.INNODB_TRX\G;<br># 查询锁等待情况<br>SELECT * FROM data_lock_waits\G;<br># 查询锁的情况<br>SELECT * from performance_schema.data_locks\G;<br></code></pre></td></tr></table></figure><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC （Multiversion Concurrency Control），隔离级别我们可以设置，MVCC是如何实现隔离级别(RM和RR)</p><p>解决<code>读-写</code>冲突，读不加锁。读为<strong>快照读</strong>，写为<strong>当前读</strong></p><p>组成：<code>隐藏字段</code>、<code>undo日志</code>、<code>ReadView</code></p><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>基本的<code>select</code>。隔离级别不是串行级别</p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>为读到最新数据，加锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁，锁上后别人不能修改<br>SELECT * FROM student FOR UPDATE; # 排他锁<br>INSERT INTO student values ... # 排他锁<br>DELETE FROM student WHERE ... # 排他锁<br>UPDATE student SET ... # 排他锁<br></code></pre></td></tr></table></figure><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><h4 id="隔离级别-1"><a href="#隔离级别-1" class="headerlink" title="隔离级别"></a>隔离级别</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055518.png" alt="image-20230317134757906" style="zoom:67%;" /><h4 id="隐藏字段、Undo-Log版本链"><a href="#隐藏字段、Undo-Log版本链" class="headerlink" title="隐藏字段、Undo Log版本链"></a>隐藏字段、Undo Log版本链</h4><ul><li>隐藏字段包含：<ul><li><code>trx_id</code> ：最后一次修改的事务id</li><li><code>roll_pointer</code>: 操作的记录信息</li></ul></li><li>Undo Log版本链：包含历史信息</li></ul><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><p>如事务8插入了一条数据</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055519.png" alt="image-20230317135028917"></p><p>此时两个事务分别进行2次修改，注意他们不能同时更新，只能一个commit后再一个更新：<code>写锁</code></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055520.png" alt="image-20230317135251185" style="zoom:67%;" /><p>在完成后，第一条为记录，历史版本串成了undo日志</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055521.png" alt="image-20230317135348858"></p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>MVCC 的实现依赖于：<code>隐藏字段</code>、<code>Undo Log</code>、<code>Read View</code>。</p><p><strong>ReadView</strong>: <strong>事务</strong>在进行<strong>快照读</strong>时产生的 <strong>读视图</strong>（一对一）。有一个数组记录活跃事务ID</p><ul><li><code>READ UNCOMMITTED</code> ：读未提交，就是最新数据。&#x3D;&#x3D;不使用&#x3D;&#x3D;</li><li><code>READ COMMITTED</code>：每次读之前都会新生成一个视图</li><li><code>REPEATABLE READ</code>：第一次读时生成</li><li><code>SERIALIZABLE</code>：从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。并发度急剧下降，不建议使用。</li></ul><h4 id="ReadView组成"><a href="#ReadView组成" class="headerlink" title="ReadView组成"></a>ReadView组成</h4><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ol><li><p><code>creator_trx_id</code> ，创建这个 Read View 的事务 ID。</p><blockquote><p>说明：只有在<strong>CUD</strong>才会为 事务分配事务id，否则在<strong>R</strong>事务中的事务id值都默认为0。</p></blockquote></li><li><p><code>trx_ids</code> ，表示在生成ReadView时当前系统中活跃的读写事务的 <code>事务id列表</code> 。</p></li><li><p><code>up_limit_id</code> ，活跃的事务中最小的事务 ID。</p></li><li><p><code>low_limit_id</code> ，表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是系 统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p></li></ol><blockquote><p>为什么需要: 如果读到了在trx_ids中的，或者大于low_limit_id，什么数据被修改了，那就要回滚undo读历史版本</p><p>up_limit_id 作用就是方便比较，小于up_limit_id 的就可以直接读</p></blockquote><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p><code>trx_ids</code> ：   [<code>up_limit_id</code>  …     ]   <code>low_limit_id</code> </p><p><strong>规则：</strong></p><ul><li>快照读：如果改事务读到的行记录的<code>trx_id</code>&gt;&#x3D;<code>low_limit_id</code> || <code>trx_id</code> in <code>trx_ids</code> ,   说明这个行版本在事务创建后被修改过，就需要沿着Undo<strong>一直倒退</strong>到事务创建时的版本：<code>trx_id</code>&lt;<code>low_limit_id</code> || <code>trx_id</code> not in <code>trx_ids</code> 。</li><li>当前读：必须读取最新版本，也就是直接读到的数据</li></ul><p>步骤判断：</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><p>再根据生成规则，<code>READ COMMITTED</code>(每次读生成)  <code>REPEATABLE READ</code>(事务生成时生成)，这两种隔离级别都实现了。</p><h4 id="幻读解决"><a href="#幻读解决" class="headerlink" title="幻读解决"></a>幻读解决</h4><p><strong>快照读：</strong>插入的数据一定是活跃的事务或未来的事务：<code>trx_id</code>&gt;&#x3D;<code>low_limit_id</code> || <code>trx_id</code> in <code>trx_ids</code> ，也不能倒退版本，根据规则就被MVCC直接忽略了</p><p><strong>当前读：</strong>MVCC无法解决。A查询id&gt;3,B插入id&#x3D;6，A更新id&#x3D;6(当前读)，至此之后A都会读到幻影记录6.</p><p>​解决办法：在A查询id&gt;3时，自动添加<strong>间隙锁</strong>(RR并且有索引)。</p><p><a href="https://blog.csdn.net/Edwin_Hu/article/details/124392174">MVCC 幻读问题</a></p><p><a href="https://blog.csdn.net/Edwin_Hu/article/details/124392174">间隙锁原理</a></p><h2 id="事务总结"><a href="#事务总结" class="headerlink" title="事务总结"></a>事务总结</h2><p><strong>原子性：</strong> <code>undo日志</code>实现回滚，保证操作原子性</p><p><strong>隔离型：</strong>读-读、读-写（锁 或者 MVCC+锁）、写-写(锁)</p><p><strong>持久性：</strong> <code>redu日志</code>实现，数据持久化前，先把操作持久化</p><p>目标：<strong>一致性：</strong>  数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://www.bilibili.com/video/BV1vg411p7uJ">字节数据库优化</a>  <a href="https://mp.weixin.qq.com/s/CaSVhAJgycjjbCxAkII2ZA">慢 SQL 分析与优化</a></p><p><strong>InnoDB</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055522.png" alt="image-20221206102707216"></p><p><strong>回表查询</strong>：先根据筛选条件在普通索引上定位id，再拿id再聚集索引上定位行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> id, name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;shenjian&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> id, name, sex <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;shenjian&#x27;</span>; 需要回表<br></code></pre></td></tr></table></figure><p>limit: 先查询全部数据，再进行过滤   优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">（全部sn<span class="hljs-operator">=</span><span class="hljs-string">&#x27;XD12345678&#x27;</span>的数据要回表）<br><span class="hljs-keyword">SELECT</span> o1.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> sn<span class="hljs-operator">=</span><span class="hljs-string">&#x27;XD12345678&#x27;</span> LIMIT <span class="hljs-number">10000</span>,<span class="hljs-number">10</span> <br><br>（只回表<span class="hljs-number">10</span>条数据）<br><span class="hljs-keyword">SELECT</span> o1.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders o1<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> sn<span class="hljs-operator">=</span><span class="hljs-string">&#x27;XD12345678&#x27;</span> LIMIT <span class="hljs-number">10000</span>,<span class="hljs-number">10</span>) o2<br><span class="hljs-keyword">ON</span> o1.id <span class="hljs-operator">=</span> o2.id;<br></code></pre></td></tr></table></figure><p>不使用子查询：先查外表，外表大很慢</p><p>IN代替or：IN会将数组先排序，然后用二分去查找</p><p>少用select *</p><p>where groupby having  先where过滤</p><p>exists和in区别，要用<strong>小表驱动大表</strong>，因为是以驱动表建立for循环　<strong>被驱动表走索引</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">exists用外表驱动内表，拿一条条外表数据去内标查       适合外小内大<br><span class="hljs-keyword">in</span>反过来，先查询内表，再拿数据去外表走索引<br>子查询<span class="hljs-keyword">in</span> exists:https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/wpc2018/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">122948692</span><br></code></pre></td></tr></table></figure><p>join的驱动</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>）当连接查询没有<span class="hljs-keyword">where</span>条件时<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> 前面的表是驱动表，后面的表是被驱动表<br><span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> 后面的表是驱动表，前面的表是被驱动表<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">join</span> 会自动选择表数据比较少的作为驱动表<br>straight_join(≈<span class="hljs-keyword">join</span>) 直接选择左边的表作为驱动表（语义上与<span class="hljs-keyword">join</span>类似，但去除了<span class="hljs-keyword">join</span>自动选择小表作为驱动表的特性）<br><br><span class="hljs-number">2</span>）当连接查询有<span class="hljs-keyword">where</span>条件时，带<span class="hljs-keyword">where</span>条件的表是驱动表，否则是被驱动表<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot笔记</title>
    <link href="/2022/12/30/springboot/"/>
    <url>/2022/12/30/springboot/</url>
    
    <content type="html"><![CDATA[<h3 id="0-对比"><a href="#0-对比" class="headerlink" title="0.对比"></a>0.对比</h3><p>模板化的大量配置文件，不需要tomcat运行。遵循约定，简化配置</p><p>springboot只是进一步的升级，简化项目搭建和开发。引入依赖，几行配置</p><p>springboot 微框架 &#x3D; springmvc 控制器+ spring core项目管理</p><ul><li>spring存在父容器spring.xml,子容器springmvc.xml。springboot只有一个</li><li>内嵌tomcat</li><li>简化maven，自动配置spring springmvc，没有xml</li></ul><p>约定：</p><ul><li>只有一个入口类 xxxxApplication.java，在所有子包目录之上； 需要main项目启动函数</li><li>配置文件：根目录resources中application.yml | application.properties</li></ul><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050658.png" alt="image-20221216212408119" style="zoom: 80%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050660.png" alt="image-20221216202540351"></p><h3 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1.快速开始"></a>1.快速开始</h3><ol><li><pre><code class="xml">创建spring项目，勾选springweb or创建maven项目继承父项目 便于维护版本&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">   <br><span class="hljs-number">2.</span> 配置文件变成小树叶<br><br><span class="hljs-number">3.</span> ```java<br>   @SpringBootApplication 入口类，整个项目的总入口<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminApplication</span> &#123;<br>   <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>           <span class="hljs-comment">// 入口类对象，参数（可以动态设置参数，如端口等）</span><br>           SpringApplication.<span class="hljs-built_in">run</span>(AdminApplication.<span class="hljs-keyword">class</span>, args);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>写一个@RestController</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs j'a'v">@SpringBootApplication<br>    @SpringBootConfiguration  加载spring springmvc环境<br>    @EnableAutoConfiguration  开启自动配置 自动配置核心注解，配置spring以及第三方环境 <br>    @ComponentScan 组件扫描 当前包以及子包 <br>    &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;<br></code></pre></td></tr></table></figure><h3 id="2-多配置文件"><a href="#2-多配置文件" class="headerlink" title="2.多配置文件"></a>2.多配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br> <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-comment"># 规定走dev环境</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>      <br></code></pre></td></tr></table></figure><p>多环境情况：application为公共的</p><p>​application.yml          application-test.yml        application-dev.yml       application-prod.yml </p><p>此外，以外部生产配置文件启动（包含数据库隐私等）</p><p>java -jar –spring.config.location &#x3D; filepath  xxx.jar</p><h3 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3.创建对象"></a>3.创建对象</h3><p>springboot 微框架 &#x3D; springmvc 控制器</p><p>​ + spring  管理项目对象</p><p><strong>spring创建对象</strong></p><ol><li>&lt; bean &gt;</li><li>注解实现创建对象，需要扫描@Componet ，只是名称不同，为了更好的理解</li></ol><ul><li>@Controller</li><li>@Service</li><li>@Repository</li></ul><p><strong>Springboot</strong>：</p><ol><li><p>@configuration 定义配置类   相当于xml。 </p><p>​里面@Bean ，用在方法上，返回值交给工厂。默认方法名是id（或者@bean(“beanid”)）。 相当于&lt; bean&gt;</p></li><li><p>注解实现创建对象，启动时自动扫描了     指定名称: @Service(“helloImpl”)   @Qualifier(value &#x3D; “helloImpl”)</p><ul><li>@Controller</li><li>@Service</li><li>@Repository</li></ul></li></ol><h3 id="4-属性注入"><a href="#4-属性注入" class="headerlink" title="4.属性注入"></a>4.属性注入</h3><p>和spring一样，但都通过注解实现。包含引用类型和基本类型</p><ol><li><p>@Value(“${user.name}”)   @Value(“xiaoming”)     单个注入</p><ul><li>数组也可以直接注入，yml逗号隔开</li><li>maps: “{‘aa’:’你好’}”   #{${maps}}</li></ul></li><li><p>批量注入，用在类上， @ConfigurationProperties(“spring.datasource”)</p><p>自动找spring.datasource里面的属性，按名称注入到类的属性中，需要提供set方法</p></li></ol><p>@Autowired</p><h3 id="5-JSP集成"><a href="#5-JSP集成" class="headerlink" title="5.JSP集成"></a>5.JSP集成</h3><p>引入依赖 tomcat-embed-jasper ，解析jsp</p><p>java同级的webapp文件夹 </p><p>原来springmvc有视图解析器，现在是设置配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">view:</span><br>      <span class="hljs-attr">prefix:</span> <span class="hljs-string">/</span><br>      <span class="hljs-attr">suffix:</span> <span class="hljs-string">.jsp</span><br></code></pre></td></tr></table></figure><p>通过插件启动，以防idea找不到jsp</p><h3 id="6-整合Mybatis"><a href="#6-整合Mybatis" class="headerlink" title="6.整合Mybatis"></a>6.整合Mybatis</h3><p>0.引入依赖 </p><ul><li>spring-boot-starter-web</li><li>mysql驱动  druid数据源</li><li>mybatis-spring-boot-starter</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.配置数据源</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>  <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>  <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/challenge2?serverTimezon=UTC&amp;userUnicode=true&amp;characterEncoding=utf-8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <br><span class="hljs-string">等价</span><br><span class="hljs-string">&lt;!--使用spring数据源--&gt;</span><br><span class="hljs-string">&lt;bean</span> <span class="hljs-string">id=&quot;dataSource&quot;</span> <span class="hljs-string">class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;driverClassName&quot;</span> <span class="hljs-string">value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;url&quot;</span> <span class="hljs-string">value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;username&quot;</span> <span class="hljs-string">value=&quot;root&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;password&quot;</span> <span class="hljs-string">value=&quot;123456&quot;&gt;&lt;/property&gt;</span><br><span class="hljs-string">&lt;/bean&gt;</span><br></code></pre></td></tr></table></figure><p>2.创建Factory,指定mapper文件的位置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.dhu.yarn.entity</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:com.dhu.yarn/mapper/*.xml</span><br>  <span class="hljs-comment"># 下滑线转大写 </span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">等价</span><br><span class="hljs-string">&lt;bean</span> <span class="hljs-string">id=&quot;sqlSessionFactory&quot;</span> <span class="hljs-string">class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br>    <span class="hljs-string">&lt;!--数据源--&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;dataSource&quot;</span> <span class="hljs-string">ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;!--mapper--&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;mapperLocations&quot;</span> <span class="hljs-string">value=&quot;classpath:com/kuang/mapper/*.xml&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;!--绑定mybatis配置文件--&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;configLocation&quot;</span> <span class="hljs-string">value=&quot;classpath:mybatis-config.xml&quot;/&gt;</span> <span class="hljs-string">(可以不要)</span><br><span class="hljs-string">&lt;/bean&gt;</span><br></code></pre></td></tr></table></figure><p>3.@MapperScan(“com.xun.dao”)  扫描Dao接口所在的包，同时创建bean 。可能爆红但不影响</p><p>or  @Mapper一个一个创建添加，让mybatis找到，表示他是用来访问数据库的 ，对应Mapper接口。同时可以创建bean</p><p>​@Repository只可以创建普通bean，所以只起标识作用。单独使用bean of type BookMapper that could not be found.</p><p>等价</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.mybatis.spring.sample.mapper&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不用配置开启事务，直接在serviceImpl上@Transactional</p><h3 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot2ApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test 用在Spring Boot <span class="hljs-number">2.2</span>.X以后   JUnit <span class="hljs-number">5</span><br><span class="hljs-keyword">import</span> org.junit.Test用在<span class="hljs-number">2.2</span>.x之前     添加 <span class="hljs-meta">@RunWith(SpringRunner.class)</span> 否则注释将被忽略 <br></code></pre></td></tr></table></figure><p>@Autowired service 层 ，调试单个service函数很快</p><h3 id="8-热部署"><a href="#8-热部署" class="headerlink" title="8.热部署"></a>8.热部署</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--热部署--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--是否不能传递--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>2. 勾选Build project automatically     修改了就编译生成.class文件<br>3. ctrl+alt+s，进入设置，然后选择高级设置，在Compiler下勾选 Allow auto-make to restart even if developed application is currently running    自动加载新的class到jvm<br><br>ctrl s保存后，等待日志<br></code></pre></td></tr></table></figure><h3 id="9-日志"><a href="#9-日志" class="headerlink" title="9.日志"></a>9.日志</h3><p>默认集成logback，和log4j作用一样</p><p>日志级别：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050661.png" alt="image-20221219112645808" style="zoom: 80%;" /><p>rootLogger默认</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050662.png" alt="image-20221219113216242" style="zoom:80%;" /><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">info</span>  <span class="hljs-comment">#如果修改为debug， 信息变多了</span><br>    <span class="hljs-attr">com.baizhi.mapper:</span> <span class="hljs-string">debug</span> <span class="hljs-comment"># 把mapper层设置为debug，可以显示sql日志</span><br>  <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次都要生成</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(当前类.class);<br>logger.info(<span class="hljs-string">&quot;12312&quot;</span>) # 代替sout<br>logger.error(<span class="hljs-string">&quot;端口冲突,异常信息：&#123;&#125; &#123;&#125;&quot;</span>, <span class="hljs-string">&quot;第一个参数&quot;</span>, <span class="hljs-string">&quot;第二个参数&quot;</span>);<br><br>注解实现<br><span class="hljs-meta">@Slf4j</span><br>log.info(<span class="hljs-string">&quot;测试log-------------------------&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="10-小项目"><a href="#10-小项目" class="headerlink" title="10.小项目"></a>10.小项目</h3><p>密码要md5（不可逆）加密保存，登录时将将密码转换后进行对比。传统项目成功后存入session中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newpassword</span> <span class="hljs-operator">=</span> DigestUtils.md5DigestAsHex(password.getBytes(StandardCharsets.UTF_8))<br></code></pre></td></tr></table></figure><p>出现业务错误时，抛出异常</p><p>controller除了返回到页面，还包含跳转到别的controlle，注意使用forward还是redirect。</p><p>​如添加完成员工接口后redirect到查询接口，查询完成后forward到显示界面</p><h3 id="11-AOP"><a href="#11-AOP" class="headerlink" title="11.AOP"></a>11.AOP</h3><p><strong>spring</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">附加操作 继承接口<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>              System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">配置bean；配置切入点，组装切面<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aop.Log&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--   切入点   execution:执行的位置     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserserviceImpl.*(..))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:pointcut</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>springboot</strong></p><p>  无xml文件</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--aop日志--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写切面类</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">// spring配置类  spring.xml</span><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 这个类是切面类 aop:config</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspectConfig</span> &#123;<br>    <br>    <span class="hljs-comment">// 切入点</span><br>    <span class="hljs-meta">@within(&quot;execution(com.xun.springboot2.controller.*)&quot;)</span> <span class="hljs-comment">//类级别</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.xun.springboot2.controller.*.*(..))&quot;)</span> <span class="hljs-comment">//方法级别</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">controllerLog</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 切面 = 通知（Advice）+ 切入点（pointcut）</span><br>    <span class="hljs-meta">@Before(&quot;controllerLog()&quot;)</span>  <span class="hljs-meta">@After</span>    还可以针对注解生效<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Around(&quot;controllerLog()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;around start&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> proceedingJoinPoint.proceed(); <span class="hljs-comment">// 需要返回方法中的数据</span><br>        System.out.println(<span class="hljs-string">&quot;around end&quot;</span>);<br>        <span class="hljs-keyword">return</span> proceed;<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><h3 id="12-拦截器"><a href="#12-拦截器" class="headerlink" title="12.拦截器"></a>12.拦截器</h3><p><strong>spring</strong>：编写类，return true放行。然后注入bean并且配置拦截哪些请求</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--拦截器注入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--可以写多个拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.JWTInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  或者分开 <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span> = <span class="hljs-string">&quot;beanname&quot;</span>&gt;</span><br>    &lt;/mvc:interceptor &gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>springboot</strong></p><ol><li>编写类，return true放行。&#x2F;&#x2F; 多个拦截器是栈结构，pre1  pre2  do  post2  post1</li><li>编写配置类，implements WebMvcConfigurer    (原来写在springmvc.xml里，现在实现WebMvcConfigurer，WebMvcConfigurer里面包含很多mvc的配置方法，如addResourceHandlers)<ul><li>使用哪个拦截器</li><li>拦截哪些</li><li>排除哪些</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span>&#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JWTInterceptor</span>())<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/user/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/image/**&quot;</span>)<br>            .order(<span class="hljs-number">1</span>) <span class="hljs-comment">// 先执行</span><br>        ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-文件上传下载"><a href="#13-文件上传下载" class="headerlink" title="13.文件上传下载"></a>13.文件上传下载</h3><p>上传到服务器本地、阿里云oss  </p><p>打包成jar时，不能上传到项目内部的某个文件夹，因此直接上传到机器一个固定目录（配置文件注入）</p><p>本地和生产不同，使用多个配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">发送</span> <span class="hljs-string">multipart/form-data</span><br><span class="hljs-string">接受</span> <span class="hljs-string">MultipartFile</span> <span class="hljs-string">f</span><br><br><br><span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">multipart:</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">300MB</span> <span class="hljs-comment"># 单个文件大小</span><br>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">500MB</span> <span class="hljs-comment"># 设置总上传的数据大小</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#开启</span><br></code></pre></td></tr></table></figure><p><strong>下载</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050663.png" alt="image-20221225202709373"></p><h3 id="14-异常处理"><a href="#14-异常处理" class="headerlink" title="14.异常处理"></a>14.异常处理</h3><p>传统的：继承HandlerExceptionResolver，不同异常不同if处理</p><p><strong>springboot:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span>        <span class="hljs-comment">// 默认监控全部controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalException</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler(BusinessException.class)</span> <span class="hljs-comment">// 处理哪个异常</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">handleBusinessException</span><span class="hljs-params">(HttpServletRequest request, BusinessException ex)</span> &#123;<br>        log.error(<span class="hljs-built_in">this</span>.getClass()+<span class="hljs-string">&quot;业务异常：&quot;</span>+ex.getMessage()+<span class="hljs-string">&quot; 代码:&quot;</span>+ex.getCode());<br>        <span class="hljs-keyword">return</span> Result.error(ex.getCode(), ex.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-CORS"><a href="#15-CORS" class="headerlink" title="15.CORS"></a>15.CORS</h3><p> 跨域资源共享</p><p>源：协议 域名 端口。默认情况下，不同源不能互相访问。ajax  </p><p>controller类上@CrossOrigin 允许跨域访问</p><p>全局配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> CorsConfiguration <span class="hljs-title function_">buildConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>        <span class="hljs-comment">// 1允许服务端访问</span><br>        corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 2允许任何头</span><br>        corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 3允许任何方法（post、get等）</span><br>        corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        corsConfiguration.setMaxAge(<span class="hljs-number">600L</span>);<br>        <span class="hljs-comment">// 4 允许withCredentials报文头</span><br>        corsConfiguration.setAllowCredentials(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> corsConfiguration;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, buildConfig());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16-加密"><a href="#16-加密" class="headerlink" title="16.加密"></a>16.加密</h3><p>jasypt对密码进行加密。提供一个类进行加密和解密，需要配置密钥，没有密钥解密会失败。在运行时传参输入密钥</p><p>使用：ENC(加密后字符串)</p><h3 id="17-传参"><a href="#17-传参" class="headerlink" title="17.传参"></a>17.传参</h3><p> 参考sping里springmvc传参</p><h3 id="18-restful"><a href="#18-restful" class="headerlink" title="18.restful"></a>18.restful</h3><p>用访问方法指明操作，put要id和User，先查再改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserRepository userRepository;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getAllUsers</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;User&gt; <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long userId)</span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">createUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;User&gt; <span class="hljs-title function_">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long userId,</span><br><span class="hljs-params">                                                   <span class="hljs-meta">@RequestBody</span> User userDetails)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Boolean&gt; <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long userId)</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring笔记</title>
    <link href="/2022/12/20/spring/"/>
    <url>/2022/12/20/spring/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>1.IOC and DI</p><p>​将new的权力交给spring，由工厂提供对象，同时通过DI维护对象与对象之间的关系</p><p>2.AOP</p><p>​底层原理：动态代理的封装</p><p>​通过产生动态代理来实现附加操作，来减少代码冗余</p><p>​切面 &#x3D; 通知(额外功能) + 切入点(加在哪里，哪些service类的哪些方法)</p><p>​通知和切入点可以随意组合成切面</p><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>项目管理框架，不是替换别的框架，而是将框架进行<strong>整合</strong>管理</p><ul><li><p>众多设计模式：工程 代理 策略 单例…</p></li><li><p>开源</p></li><li><p>轻量级</p></li><li><p>SSH：Struct2 + Spring +Hibernate</p></li><li><p>SSM: SpringMvc + Spring + Mybatis</p></li></ul><p>对组件（controller service Dao ）进行对象管理（创建 使用 销毁），entity通常不交给spring</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">原来： <span class="hljs-keyword">new</span> 去创建，然后调用<br>userDao = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>userDao.save()<br>现在：xml配置bean，然后直接取出来<br></code></pre></td></tr></table></figure><ol><li><p>导入依赖</p></li><li><p>配置applicationContext.xml</p></li><li><p>bean来管理对象的创建，class指定类UserDaoImpl，id唯一<strong>标识</strong>在spring容器中取出来（最好首字母小写）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;init.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>启动工程，绑定xml文件,取出bean</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;init/applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">UserDao</span> <span class="hljs-variable">usertest</span> <span class="hljs-operator">=</span> (UserDao)context.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);<br>        usertest.save(<span class="hljs-string">&quot;小明&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. 核心思想</h3><ol><li><p><strong>IOC</strong>（Inversion of Control）控制反转        </p><p>由手动new变为配置文件配置，交给spring工厂。在tomcat中，也是该思想帮助我们创建了response对象</p><p>原理Class.forName(“UserDaoImpl”).newInstance()   反射调用构造方法</p></li><li><p><strong>AOP</strong>面向切面</p></li></ol><p><strong>DI</strong>：dependency Injection    IOC的补充</p><p>​存在嵌套service调用dao，也就是serviceImpl中需要拿到daoImpl。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(String name)</span> &#123;<br>        userDao.save(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​都要先声明一个成员对象，然后 </p><p>​<strong>原来</strong>：new UserDaoImpl()；</p><p>​<strong>现在</strong>：需要set方法，在配置中完成赋值操作（注入）      set注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">ref：工程里的标识 bean的id，name：注入哪个属性<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>IOC <strong>创建对象</strong>，DI <strong>维护对象与对象之间的关系</strong></p><h3 id="3-注入"><a href="#3-注入" class="headerlink" title="3. 注入"></a>3. 注入</h3><p>除了一个对象的注入，其他的用的很少</p><ol><li>set 注入    property标签</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml">1. 对象注入 ref<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span> /&gt;</span>        <br>2. String、日期、八种基本类型 value注入<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>   <br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2012/12/12 23:54:57&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  日期需要/ :格式<br>3. array list set<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbys&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span> 这里不同<br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>听歌<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  字符串用value<br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  类用ref<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>map<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key-ref</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">key-ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span> 类<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>properties  无序键值对集合<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;driver&quot;</span>&gt;</span>com.mysqljdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;姓名&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>构造注入       constructor-arg 标签</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">使用公开的有参构造方法  index代表参数的位置<br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明&quot;</span>/&gt;</span><br><br>如果想单独赋值某些元素，就要对应的构造方法，很麻烦！！<br></code></pre></td></tr></table></figure><ol start="3"><li>自动注入      autowire &#x3D; ”byType“  “byName”</li></ol><p>底层是set  需要在组件标签上开启</p><p><code>Autowired</code> 属于 Spring 内置的注解，<strong>默认</strong>的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （<strong>接口的实现类</strong>）。</p><p><strong>问题：</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了</p><p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。</p><p><code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><span class="hljs-comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-comment">// smsServiceImpl1 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><h3 id="4-工厂特征"><a href="#4-工厂特征" class="headerlink" title="4.  工厂特征"></a>4.  工厂特征</h3><p>默认单例，多次getBean还是同一个。 struct2用成员对象存储信息，所以这时要多例   bean中scope &#x3D; “prototype”</p><p>原理： <strong>反射</strong> + 构造方法</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>单例：工厂启动时创建，正常关闭工程时销毁 context.close()</p><p>多例：getBean时创建，创建完成后脱离spring的管理，jvm去销毁</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">自己写的方法<br>init-<span class="hljs-keyword">method</span>=&quot;&quot; <span class="hljs-title function_">destroy</span>-<span class="hljs-title function_">method</span>=&quot;&quot;<br></code></pre></td></tr></table></figure><p>好处：</p><ol><li>解耦合，更换类只需要修改配置文件</li><li>减少内存占用</li><li>建立对象与对象之间的关系   打开配置文件就可看到</li></ol><h3 id="5-代理"><a href="#5-代理" class="headerlink" title="5. 代理"></a>5. 代理</h3><p>代理对象：完成传化，也可以附加操作，同时也可以中断</p><p>​好处：原始业务逻辑不变，同时可以附加</p><ol><li>代理对象和原始逻辑对象实现相同的接口</li><li>代理对象 依赖 原始业务逻辑对象</li></ol><p>原始逻辑中，除了<strong>具体事务</strong>，还有开启事务、提交事务、回滚事务的方法。后面这部分是重复的</p><p>在代理中，负责处理这些额外的方法，同时需要调用原始对象。总体的处理逻辑不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>sout(<span class="hljs-string">&quot;开启事务&quot;</span>)<br>userService.save(name)<br>out(<span class="hljs-string">&quot;结束事务&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>每一个业务对象都开发一个代理对象，上面的逻辑</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在程序运行中自动生成</p><p>getSqlSession().getMapper(UserMapper.class).getUser(); 这一步也是通过代理实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader(); 类加载器<br><span class="hljs-number">2.</span> Class[] classes = &#123;UserService.class&#125; 目标对象的接口数组 <br><span class="hljs-number">3.</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandleer</span>() 附加操作 额外功能<br>proxy = (UserServic)Proxy.newProxyInstance(classLoader, classes, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandleer</span>()&#123;<br><span class="hljs-comment">// 代理过程 处理代理的实例  这里执行附加操作</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 附加 开启事务，打印信息等操作</span><br>        log(method.getName());<br>        <span class="hljs-comment">// 反射, 执行具体事务  哪个目标类的method </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>(), args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+msg);<br>    &#125;<br>&#125;);   生成动态对象<br>    <br>porxy.save();  直接调用<br></code></pre></td></tr></table></figure><p>封装成通用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-comment">// 被代理的接口， 一个动态代理 可以代理 多个类，只要是同一接口</span><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTarget</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回代理类</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 类加载器  被代理类接口  InvocationHandler</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-built_in">this</span>.getClass().getClassLoader(),<br>                target.getClass().getInterfaces(),<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 代理过程 处理代理的实例  这里执行附加操作</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//附加</span><br>        log(method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+msg);<br>    &#125;<br>&#125;<br><br>---------<br><span class="hljs-comment">// 真实角色</span><br><span class="hljs-type">ServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceImpl</span>();<br><br><span class="hljs-type">ProxyInvocationHandler</span> <span class="hljs-variable">phi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyInvocationHandler</span>();<br><span class="hljs-comment">// 设置要代理的对象</span><br>phi.setTarget(service);<br><span class="hljs-comment">// 得到代理对象 是一个接口</span><br><span class="hljs-type">Service</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Service) phi.getProxy();<br><br>proxy.add();<br></code></pre></td></tr></table></figure><h3 id="6-AOP"><a href="#6-AOP" class="headerlink" title="6.   AOP"></a>6.   AOP</h3><p>Aspect Oriented Programing    <strong>核心就是动态代理</strong></p><p>附加操作：如日志打印，每个controller都加的话<strong>代码冗余</strong></p><p>通过<strong>动态代理</strong>完成<strong>附加操作</strong>(通知、Advice)。开发通知类，配置切入点</p><p>通知（Advice）：前置通知、后置通知、环绕通知、异常通知</p><p>切入点（pointcut）：指定通知应用在哪里。一般用于业务层</p><p><strong>切面</strong>（Aspect）：<strong>通知</strong>（Advice）+ <strong>切入点</strong>（pointcut）</p><ol><li><p>导入依赖</p></li><li><p>开发通知   继承接口 MethodIntercept MethodBeforeAdvice  ..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置切面 .xml</p><ul><li><p>注册通知类bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aop.Log&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>组装切面，aop输入时会导入一些依赖。先定义切入点，切哪个类的哪个方法；再把通知类和切入点组装</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--   切入点   execution:执行的位置     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserserviceImpl.*(..))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:pointcut</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>被切的类都会创建代理对象，之后.getBean(“UserserviceImpl”)返回的是proxy，和5中动态代理一样，但每个被切的类不用单独创建</p></li></ol><h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><p>MethodInterceptor</p><p>计算运行时间 、处理异常</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046861.png" alt="image-20221206190215566"></p><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046862.png" alt="image-20221206190819126"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046863.png" alt="image-20221206190916792"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046864.png" alt="image-20221206191123649" style="zoom:67%;" /><h3 id="7-复杂对象"><a href="#7-复杂对象" class="headerlink" title="7.  复杂对象"></a>7.  复杂对象</h3><ul><li>简单对象：可以直接new的对象，因此可以直接通过&lt; bean &gt;交给spring</li><li>复杂对象：不能直接new，接口Connction、抽象类Calendar</li></ul><p>Implements FactoryBean&lt;类名&gt;</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046865.png" alt="image-20221207202622749"></p><h3 id="8-整合mybatis"><a href="#8-整合mybatis" class="headerlink" title="8.整合mybatis"></a>8.整合mybatis</h3><p>spring：项目管理</p><p>mybatis：持久层CRUD。把mybatis中的对象创建交给spring</p><p><strong>mybatis写法：</strong>  .xml包含 <strong>数据源</strong> 以及 <strong>mapper注册</strong> 。 sqlSessionFactory &#x3D;》sqlSession &#x3D;》 usermapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>配置文件mybatis.xml 包含数据源信息(数据库账号密码等)<br><span class="hljs-number">2.</span>从配置文件.xml得到SqlSessionFactory，再openSession生成SqlSession执行sql语句 (封装成工具类)<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// get factory</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// get SqlSession</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br><br><span class="hljs-number">3.</span>编写Dao接口，接口实现类（.xml）<br>    <br><span class="hljs-number">4.</span>注册Mapper.xml<br>    &lt;mappers&gt;<br>        &lt;mapper resource=<span class="hljs-string">&quot;com/kuang/dao/userMapper.xml&quot;</span>/&gt;<br>    &lt;/mappers&gt;<br>    <br><span class="hljs-number">5.</span>测试，调用工具类得到SqlSession，再调用getMapper，该mapper执行函数完成查询<br><span class="hljs-comment">// 获得对象</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><span class="hljs-comment">// getMapper</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>List&lt;User&gt; userList = mapper.getUserList();<br></code></pre></td></tr></table></figure><h4 id="8-1拿到sqlSessionFactory"><a href="#8-1拿到sqlSessionFactory" class="headerlink" title="8.1拿到sqlSessionFactory"></a>8.1拿到sqlSessionFactory</h4><p>SqlSessionFactoryBuilder 读配置文件，构建Factory</p><p>sqlSessionFactory <strong>核心对象</strong>, 因此整合的核心就是接管这个！！！</p><p>sqlSession</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml">sqlSessionFactory 是接口，因此利用第七节的方法完成配置，并把xml文件位置通过依赖注入到bean中<br><br>spring将这个类封装了，叫做SqlSessionFactoryBean<br>注入.xml，细粒度化，把dataSource分开了，同时配置mapperLocations；mybatis.xml中配置日志等其他对象(可以不要)<br><span class="hljs-comment">&lt;!--使用spring数据源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mapper--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/kuang/mapper/*.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--绑定mybatis配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span> (可以不要)<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>到这一步拿出sqlSessionFactory，就可以取出sqlSession.getmapper操作数据库<br>但我们的核心是在Dao部分，所以不想每次拿Dao时都先拿出sqlSessionFactory，想直接拿出Dao<br></code></pre></td></tr></table></figure><h4 id="8-2整和Dao"><a href="#8-2整和Dao" class="headerlink" title="8.2整和Dao"></a>8.2整和Dao</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">factory中指向mapper文件<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/kuang/mapper/*.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>进一步封装，就可以直接getBean(UserDao)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">sqlSessionFactory和userDao绑定，就可以直接getMapper，等价 @Mapper，每一个都要写。@Repository没有用<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperInterface&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.kuang.mapper.UserDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>这里每一个Dao都要配置，直接只写一个mapperscan可以解决  等价 @MapperScan<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.mybatis.spring.sample.mapper&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者将sqlsession作为一个成员放到UserDaoImpl中，间接调用，狂神的课程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserMapper</span>&#123;<br>    <span class="hljs-keyword">private</span> SqlSessionTemplate sqlSession;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSqlSession</span><span class="hljs-params">(SqlSessionTemplate sqlSession)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sqlSession = sqlSession;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-keyword">return</span> mapper.getUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sqlSession--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--实现类--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.mapper.UserMapperImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSession&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="9-Service事务"><a href="#9-Service事务" class="headerlink" title="9.Service事务"></a>9.Service事务</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">用DataSourceTransactionManager实现事务，自己写<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>  -&gt;  写环绕通知  -&gt;  用spring的环绕通知（细粒度）<br></code></pre></td></tr></table></figure><p>service直接注入Dao即可，但需要<strong>处理事务</strong></p><h4 id="9-1-编程式"><a href="#9-1-编程式" class="headerlink" title="9.1.编程式"></a>9.1.编程式</h4><p>每个impl中注入事务管理对象实现</p><p>JDBC中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">connection.setAutoCommit(<span class="hljs-literal">false</span>);<br>connection.commit();<br>connection.rollback();<br></code></pre></td></tr></table></figure><p>datasouce中可以取出connection,但是service中的connection和dao中的<strong>可能不是同一个</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046866.png" alt="image-20221208142531461" style="zoom:67%;" /><p><strong>DataSourceTransactionManager</strong>：全局事务管理，使得service和Dao连接对象相同，控制数据源的线程安全问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>serviceImpl中，添加transactionManager， .commit()   .rollback()。每一个serviceImpl都要写，<strong>用AOP解决冗余</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046867.png" alt="image-20221208143608607"></p><h4 id="9-2-声明式事务"><a href="#9-2-声明式事务" class="headerlink" title="9.2 声明式事务"></a>9.2 声明式事务</h4><p>aop实现事务处理</p><p>自己写：环绕通知，大家都一样的，所以spring封装了</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046868.png" alt="image-20221208145557943"></p><p>封装后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置事务通知，等价于自己写的环绕通知 tx:advice为特殊标签 对通知做细粒度管控--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--在什么情况下添加事务， 细粒度--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update*&quot;</span>/&gt;</span> 方法名需要对应上<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--配置切入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tranPointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.mapper.*.*(..))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:pointcut</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;tranPointCut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="9-3事务传播"><a href="#9-3事务传播" class="headerlink" title="9.3事务传播"></a>9.3事务传播</h4><p>业务层中调用别的业务，可以把事务传播过去。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">OrderService.save()&#123;<br>userService.update();<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> /&gt;</span> <br>  propagation=&quot;&quot;<br>    REQUIRED：外层没有则开启，有则融入             增删改  默认<br>    SUPPORTS：外层没有不开，有则融入；实现事务传播  查询<br>    REQUIRE_NEW: 自己开一个新的 隔开              银行日志，总是要个新的<br>    NOT_SUPPORTED: 不用事务<br>  isolation=&quot;&quot;<br>  read-only<br>  time-out: 事务超时 -1永不超时 秒<br></code></pre></td></tr></table></figure><p>行锁为一条数据，在同一事务中多次查询，不会受到别人update印象</p><p>表锁为表的数据，多一条少一条不受印象</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046869.png" alt="image-20221208161551569"></p><h3 id="10-日志"><a href="#10-日志" class="headerlink" title="10.日志"></a>10.日志</h3><p>log4j</p><p>ERROR WARN INFO DEBUG</p><p>配置文件在resource根目录下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">log4j<span class="hljs-selector-class">.logger</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-class">.baizhi</span>.dao=DEBUG 展示sql<br></code></pre></td></tr></table></figure><h3 id="11-注解"><a href="#11-注解" class="headerlink" title="11.注解"></a>11.注解</h3><h4 id="装配"><a href="#装配" class="headerlink" title="装配"></a>装配</h4><p>service太多了，每次都要添加</p><p><strong>前置条件：开启注解扫描</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定注解生效的包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>@component</strong>(value &#x3D; “指定id”)，装配到Spring中，等价与&lt; bean&gt;, 唯一标识为类名小写</p><ul><li>Dao  **@Repository (只是告诉spring要加这个bean，和mybatis无关)   ** @Mapper 和 @MapperScan结合使用为了结合spring和mybatis。如果不加@Repository可能爆红 但能正常运行</li><li>Service     <strong>@Service</strong></li><li>controller  <strong>@ Controller</strong></li></ul><p><strong>@Scope</strong>(value&#x3D;”singleton\prototype”)  单例多例</p><h4 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h4><p><strong>对象注入</strong> 属性或者set方法上。在属性上用时可以不用添加set方法，底层会自动提供set方法</p><p>​@<strong>Autowired</strong>  默认类型</p><p>​ @<strong>Qualifier</strong>(value &#x3D; “cat1”)  指定名称</p><p>JavaEE</p><p>​@<strong>Resource</strong>  默认名字，找不到再类型</p><p><strong>基本类型注入</strong></p><p>​@Value(“XX”)         @Value(“${spring.datasource.username}”)</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>@<strong>transactional</strong>(propagation &#x3D; , )  添加事务，加载类或者单个方法    <strong>serviceimpl</strong>上加</p><p>不需要事务通知对象以及添加切面，但还是添加开启注解事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span>&lt;/tx:annotation-driven &gt; <br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046870.png" alt="image-20221208170805881" style="zoom:67%;" /><p>Dao还是扫描进行装配的</p><p>P21整合SM</p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>MVC中的C层，控制器框架。代替struts2</p><h3 id="0-Struct2"><a href="#0-Struct2" class="headerlink" title="0.Struct2"></a>0.Struct2</h3><p>1.C层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ActionSupport</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Product&gt; productList; <span class="hljs-comment">// 成员变量传递结果 相当于model.add</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 处理获取商品列表的逻辑，这里直接模拟</span><br>        productList = ProductService.getProductList();<br>        <span class="hljs-keyword">return</span> SUCCESS;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Product&gt; <span class="hljs-title function_">getProductList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> productList;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.路由：封装servlet，Struts2的前端控制器DispatcherServlet接收并分发到对应的Action处理。</p><p>定义名为<code>productList</code>的Action，并将其关联到<code>ProductAction</code>类中的<code>list()</code>方法。当请求到达<code>/productList</code>时，Struts2会调用<code>list()</code>方法并将结果返回到<code>productList.jsp</code>页面中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">struts</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;product&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;struts-default&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;productList&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.ProductAction&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span>/WEB-INF/views/productList.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">struts</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.V层：配置Struts2的视图</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Product List<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>ID<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Description<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">s:iterator</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;productList&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;price&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;description&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">s:iterator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1.基本思想"></a>1.基本思想</h3><p>在servlet基本思想中，编写一个控制器，就要去web.xml中去注册，<strong>在SpringMVC中，使用dispatchservlet拦截所有</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>loginout<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.xiao.servlet.user.LogoutServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>loginout<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/jsp/logout.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置web.xml（拦截全部的请求）   配置springmvc.xml      编写controller(component-scan)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046871.png" alt="image-20221212145632004"></p><ol><li><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--1.注册DispatcherServlet--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span><br><span class="hljs-comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>springmvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--处理器映射器 定位到方法--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--处理器适配器  解析参数--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注解驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span>  包含映射器、适配器  实验发现是必须要<br></code></pre></td></tr></table></figure></li><li><p>编写controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">手动配置，这里的id就是访问的路径<br>&lt;bean id=<span class="hljs-string">&quot;/helloserv&quot;</span> class=<span class="hljs-string">&quot;com.kuang.controller.Helloservlet&quot;</span>&gt;&lt;/bean&gt;<br><br>或者 不可以同时配置<br><br>&lt;!-- 注解扫描 --&gt;<br>&lt;context:component-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.kuang.controller&quot;</span>/&gt;<br><br><span class="hljs-meta">@Controller</span> <span class="hljs-comment">// 注入bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/helloserv&quot;)</span> <span class="hljs-comment">// 访问路径</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(Model model)</span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello annotation&quot;</span>);   <span class="hljs-comment">//model</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//view</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>在 Controller 中，根据业务逻辑查询出需要显示的动态数据，并将其封装成一个 Model 对象。</li><li>将 Model 对象作为参数传递给模板引擎（根据返回值定位页面），通过 Thymeleaf 的表达式语言 ${} 将动态数据注入到 HTML 模板中。</li><li>Thymeleaf 模板引擎会根据 HTML 模板中定义的逻辑和数据，生成渲染后的 HTML 页面，并将其返回给客户端浏览器。</li><li>客户端浏览器接收到 HTML 页面后，根据 HTML 标签和 CSS 样式渲染页面，并显示给用户。</li></ul><p>想访问一个商品列表页面：</p><ol><li>controller定义toList接口，</li><li>加载数据到model里，return “toList”跳转到toList.html，thymeleaf会自动渲染数据进入页面对应的${}</li></ol><h3 id="2-跳转"><a href="#2-跳转" class="headerlink" title="2.跳转"></a>2.跳转</h3><p>servlet</p><ul><li>forward 请求转发 地址栏不变，获得商品列表后转发到商品界面</li><li>redirect 重定向</li></ul><p>controller -&gt; 页面       </p><ul><li>默认返回就是forward</li><li>重定向return “redirect:&#x2F;index.jsp”  不经过视图解析器</li></ul><p>controller -&gt; controller </p><ul><li>return “forward:&#x2F;path”</li><li>return “redirect:&#x2F;path”</li></ul><h3 id="3-参数接受"><a href="#3-参数接受" class="headerlink" title="3.参数接受"></a>3.参数接受</h3><p>vo：专门用来传值的对象</p><p>struts2：成员变量接收参数 多例</p><p>springmvc：</p><p>@RequestBody 反序列化 @ResponseBody 序列化成json </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">局部变量，无线程安全问题，单例<br><br><span class="hljs-comment">// restful风格</span><br><span class="hljs-meta">@RequestMapping(&quot;/test2/&#123;pageNo&#125;“)</span><br><span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> pageNo 将URL中的占位符参数绑定到控制器处理方法的入参<br>    <br><span class="hljs-meta">@RequestParam</span> String name  Url Form表<br>User user  url中自动对应<br><br><span class="hljs-meta">@RequestBody</span> User user  Body中raw格式下的json参数 <br></code></pre></td></tr></table></figure><p>前端可以混用，一个在params，一个在data</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@<span class="hljs-title class_">RequestParam</span> <span class="hljs-title class_">String</span> resourceId,<br>@<span class="hljs-title class_">RequestParam</span> <span class="hljs-title class_">String</span> examId,<br>@<span class="hljs-title class_">RequestBody</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">UpdateExamAnswer</span>&gt; examAnswerList,<br>@<span class="hljs-title class_">RequestParam</span>(value = <span class="hljs-string">&quot;writeType&quot;</span>, defaultValue = <span class="hljs-string">&quot;0&quot;</span>) int writeType<br><br><span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-variable constant_">BASE_URL</span> + <span class="hljs-string">&#x27;/submit_all_save&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      resourceId,   <span class="hljs-comment">// 普通字符 拼接到url      @RequestParam</span><br>      examId,<br>      writeType<br>    &#125;,<br>    <span class="hljs-attr">data</span>: questionRes <span class="hljs-comment">// json格式    @RequestBody</span><br>  &#125;)<br></code></pre></td></tr></table></figure><p>此外，以上默认post为<code>application/json</code>格式发送接受数据</p><ol start="2"><li><code>application/x-www-form-urlencoded</code> 前端URLSearchParams或Qs.Stringify(data)      后端@RequestParam或不加</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>数据格式：loginName=lst&amp;password=<span class="hljs-number">1</span><br><br>百分号编码：<br>丁 十六进制下是<span class="hljs-number">0</span>xE4B881占<span class="hljs-number">3</span>字节<br>转成字符串‘E4B881’，占六字节<br>每两个字节前加上百分号前缀，得到字符串“%E4%B8%<span class="hljs-number">81</span>”，占九个字节（十六进制下是<span class="hljs-number">0</span>x244534254238253831）<br>把这九个字节拼接到数据包里，这样就可以传输“非ascii字符的  utf8编码的 十六进制表示的 字符串的 百分号形式”<br></code></pre></td></tr></table></figure><p>3.<code>multipart/form-data</code>  前端FormData格式，后端@RequestParam或不加</p><h3 id="4-返回参数："><a href="#4-返回参数：" class="headerlink" title="4.返回参数："></a>4.返回参数：</h3><p>request（单次请求）  session(浏览器) application(全体用户共享)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">forward跳转<br>    Model model 对request的封装，作用一样<br>         model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello annotation&quot;</span>);   <br>取出：$&#123;requestScope.msg&#125;<br>redirect<br>    <span class="hljs-number">1.</span>地址栏拼接 <br>    <span class="hljs-number">2.</span>session  req.getSession.setAttribute<br></code></pre></td></tr></table></figure><h3 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5.拦截器"></a>5.拦截器</h3><p>javaweb：filter过滤器，可以拦截一切资源。springmvc只能拦截controller</p><p>编写拦截器类，再注册：注入bean，定义拦截的地方。（或者定义和拦截写在一起）</p><p>这里继承<strong>HandlerInterceptor</strong>，有<strong>处理前</strong>，（controller）处理后，清理后</p><p>AOP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 放行OPTIONS请求</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OPTIONS&quot;</span>.equals(request.getMethod())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(token == <span class="hljs-literal">null</span>)&#123;<br>            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;未携带token&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                JWTUtils.verity(token);<br>                <span class="hljs-comment">// 未出错 放行</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">catch</span> (SignatureVerificationException e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;无效签名&quot;</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (TokenExpiredException e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;token过期&quot;</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (AlgorithmMismatchException e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;token算法不一致&quot;</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;token无效&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        map.put(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-number">500</span>);<br>        map.put(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(map);<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>        response.getWriter().println(json);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--拦截器注入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--可以写多个拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.JWTInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  或者分开 <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span> = <span class="hljs-string">&quot;beanname&quot;</span>&gt;</span><br>    &lt;/mvc:interceptor &gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h3><p>编写异常处理类，<strong>注册bean</strong>就行。可以根据不同的异常if判断处理不同逻辑 </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046872.png" alt="image-20221216183658625"></p><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><p>这里7.a scan可以只扫描service下的，因为mapper和controller都扫描了；mapper可以不使用注解（mapperscanconfig是和spring整合的；等价在springboot中使用了@Mapper和@MapperScan）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046873.png" alt="image-20221215092403942"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046874.png" alt="image-20221216205759155"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--扫描service下的包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.service&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    这里使用注解实现--&gt;</span><br>    <span class="hljs-comment">&lt;!--将service层装入--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;bean id=&quot;bookServiceImpl&quot; class=&quot;com.kuang.service.BookServiceImpl&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;/bean&gt;--&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--开启注解事务生效--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 配置整合mybatis --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.关联数据库文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span></span><br><span class="hljs-tag">            <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:database.properties&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 2.数据库连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置连接池属性 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 关闭连接后不自动commit --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoCommitOnClose&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 获取连接超时时间 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireRetryAttempts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注入数据库连接池 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br>    <span class="hljs-comment">&lt;!--解释 ： https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注入sqlSessionFactory --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.kuang.dao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.ab 让mvc在服务器启动时创建工厂(提供service Dao)。</p><p>实际项目中，可以把所有的文件整合到一起applicationContext，在servlet中配置</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046875.png" alt="image-20221215093143429"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046876.png" alt="image-20221216210140557"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046877.png" alt="image-20221216210029653"></p><p>C:\Users\13000\Desktop\study\vue-spring\2.vue-spring\7.springmvc\0代码———————————-\ssmbuild</p><p>spring.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置整合mybatis --&gt;</span><br><span class="hljs-comment">&lt;!-- 1.关联数据库文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span></span><br><span class="hljs-tag">                              <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:database.properties&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="hljs-comment">&lt;!--数据库连接池</span><br><span class="hljs-comment">    dbcp 半自动化操作 不能自动连接</span><br><span class="hljs-comment">    c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置连接池属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 关闭连接后不自动commit --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoCommitOnClose&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 获取连接超时时间 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireRetryAttempts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入数据库连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br><span class="hljs-comment">&lt;!--解释 ： https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入sqlSessionFactory --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.kuang.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--service相关--&gt;</span><br><span class="hljs-comment">&lt;!--配置声明式事务，开启注解事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span>&lt;/tx:annotation-driven &gt; <br><br><span class="hljs-comment">&lt;!--扫描service下的包, 也可以手动写入bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.service&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--将service层装入--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;bean id=&quot;bookServiceImpl&quot; class=&quot;com.kuang.service.BookServiceImpl&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;/bean&gt;--&gt;</span><br></code></pre></td></tr></table></figure><p>springmvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注解扫描 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.controller&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><span class="hljs-comment">&lt;!--注解驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><br>web.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatchservlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatchservlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213652.png" alt="image-20210808133147935" style="zoom:67%;" /><p>MAC首部 + IP首部 + TCP首部 + TCP数据</p><p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213424.png" alt="image-20230408150044809"></p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>多台机器如何传输： 数据要有标识来源MAC地址(from to)</p><ul><li>HUB集线器：直接转发给全部机器，不能同时发送，需要CSMA&#x2F;CD，半双工</li><li>交换机：有一张MAC地址和端口的表（自学习），定向转发。通过网线可以实现全双工</li></ul><h4 id="CSMA-x2F-CD"><a href="#CSMA-x2F-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h4><p>​多址接入、载波监听、碰撞检测</p><p>​往返时间为2t，每个数据包要大于2t发送时间（最短有效帧长）。所有小于等于2t的都丢弃。</p><p>​1KM往返10us；10Mbit&#x2F;s ，512bit(64B)最短帧长，总线不能超过5120m。考虑衰减：2500m</p><p>​64<em>8&#x2F;10^7^  &gt;&#x3D;   5120 * 2 &#x2F; 2</em>10^8^</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">以太网的最小帧长是通过争用期计算出来的。一个站点开始发送数据后，最多经过时间 <span class="hljs-number">2</span>τ<span class="hljs-comment">(两倍的端-端时延)</span>就可知道是否发生了碰撞 即一端发送一个帧，在无限接近另一端的位置发生了碰撞，然后碰撞信息再从碰撞位置传递回来，刚好就是一个往返以太网的端到端往返时延<span class="hljs-number">2</span>τ称为争用期，或碰撞窗口 ，如果经过争用期还没有检测到碰撞，就可以肯定这次发送不会发生碰撞为什么最短帧的大小取决于争用期时长？因为如果最短帧的传输时间小于争用期（比如<span class="hljs-number">30</span>μs），那么就会导致发送完这个帧之后，在不知道帧有没有传送成功的情况下（至少需要<span class="hljs-number">51.2</span>μs来确定）又发送了下一个帧。反之，如果最短帧的传输时间大于争用期，由于碰撞信息一定可以在帧发送完之前传到，就可以保证只有在上一个帧没有发生碰撞，正确传输的情况下才会发送下一个帧。对于最大长度为<span class="hljs-number">2500</span>米的<span class="hljs-number">10</span>Mbps 网络和四个中继器（来自<span class="hljs-number">802.3</span>规范），在最坏的情况下，往返时间（包括通过四个中继器的传播时间）被确定为接近<span class="hljs-number">50</span>微秒。因此，允许的最短帧必须至少花费这么长的时间来传输。在<span class="hljs-number">10</span>Mbps时，一个比特需要<span class="hljs-number">100</span>纳秒，所以<span class="hljs-number">500</span>比特是保证工作的最小帧。为了增加一些安全边际，这个数字被四舍五入到<span class="hljs-number">512</span>比特即<span class="hljs-number">64</span>字节，相应的，以太网的争用期长度也被确定为<span class="hljs-number">51.2</span> μs  据此规定以太网帧长≥ <span class="hljs-number">64</span> 字节，长度小于<span class="hljs-number">64</span>字节的帧为无效帧<br></code></pre></td></tr></table></figure><p><strong>ARP</strong> ： IP-》MAC</p><p><strong>差错检验：</strong> CRC</p><p><strong>可靠传输：</strong>ARQ停止等待、回退N帧（可以发多个）、选择重传（可以不按序接收）</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>设备太多了交换机的表记录不下来。通过路由器构建多个网络间的连接，一个路由器有多个接口(ip)对应多个子网</p><p><strong>通信方式</strong></p><ul><li>子网间通信：发给默认网关。由某路由器根据路由表转发</li><li>同一子网通信：直接通过交换机</li></ul><p><strong>路由表：</strong>目的网络地址、子网掩码、下一跳(下一个路由表ip地址)、接口</p><p>​我想访问IP通过子网掩码后，如果于路由表的目的网络地址对应上了，则转发到下一跳</p><p><strong>路由表如何构建：</strong> 单个目标网络可能有多个路径，如何选取最优</p><ul><li><strong>RIP</strong>(小型网络)。额外维护一个<strong>距离信息</strong>。每30s邻居向自己发送（可达地址+距离），如果距离更短则更新下一条和距离。坏消息传得慢</li><li><strong>OSPF</strong>。每个路由搜集全部路由联络信息LSA，构建LSDB(Link State DataBase)掌握全网的拓扑结构，然后构建权重有向图，再计算最短路径</li></ul><p><strong>传输过程中，IP地址(4*8 )不变，但MAC地址一直在变</strong></p><p><strong>NAT</strong>：内网访问外网，分配临时IP</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>​<strong>应用间通信</strong></p><p>​端口区分应用：FTP 21、TELNET 23、 SMTP 25、 DNS 53、 HTTP 80、 HTTPS 443 </p><p>TCP<strong>可靠传输</strong>：发送需要确认 （滑动窗口）、超时重传</p><ol><li>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</li><li>对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失</li></ol><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p><strong>三次握手</strong>：防止假如a发了两次请求，第一次以为失败了，而b接受了两次请求，第二次一直在等a浪费时间。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213425.png" alt="image-20230419102228437"></p><p><strong>四次挥手</strong>：1 a发出关闭请求，2 b发出响应确认，并半关闭状态不断发送信息， 3 最后发送关闭请求。a确认关闭请求</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213426.png" alt="image-20230419102236858"></p><h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>可靠传输通过<strong>发送需要确认</strong>(确认序号)和<strong>超时重传</strong>来实现，为提高效率使用滑动窗口</p><ul><li><strong>滑动窗口</strong>：以发送但未确认的最大字节数。接收方接受窗口如果接受到无序的数据先缓存</li><li><strong>超时重传：</strong> 指数加权移动RTT，不考虑超时重传的报文</li></ul><h4 id="流量拥塞控制"><a href="#流量拥塞控制" class="headerlink" title="流量拥塞控制"></a>流量拥塞控制</h4><p><strong>流量控制:</strong> 不断回发<strong>接收方</strong>的窗口大小</p><p><strong>拥塞控制</strong>（拥塞窗口大小）：<strong>慢启动（指数）、拥塞避免（线性）、快重传 （3个ack后立即重发）、快恢复（对于快重传情况，拥塞后直接从新门限开始）</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213427.png" alt="image-20210808142023374" style="zoom: 80%;" /><p>发送窗口 &#x3D; min(接收窗口，拥塞窗口)</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>应用  应用层运输层</strong></p><p>电子邮箱SMTPTCP</p><p>远程访问 TELNETTCP</p><p>万维网HTTPTCP</p><p>文件传输FTPTCP</p><p>域名解析DNSUDP</p><p>IP电话专用协议UDP</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="ARP协议-Address-Resolution-Protocol"><a href="#ARP协议-Address-Resolution-Protocol" class="headerlink" title="ARP协议 (Address Resolution Protocol)"></a>ARP协议 (Address Resolution Protocol)</h3><p>封装成帧时，通过ARP将IP-&gt;MAC地址。ARP 高速缓存中有就拿，没有就广播询问</p><h3 id="RIP-Routing-Information-Protocol-距离矢量路由协议"><a href="#RIP-Routing-Information-Protocol-距离矢量路由协议" class="headerlink" title="RIP (Routing Information Protocol, 距离矢量路由协议)"></a>RIP (Routing Information Protocol, 距离矢量路由协议)</h3><p>维护路由器一张表：目的网络 、距离、下一跳     坏消息传得慢</p><h3 id="NAT-Network-Address-Translation-网络地址转换"><a href="#NAT-Network-Address-Translation-网络地址转换" class="headerlink" title="NAT (Network Address Translation, 网络地址转换)"></a>NAT (Network Address Translation, 网络地址转换)</h3><p>将内网IP地址转化为临时外网IP地址，保持到NAT转换表中。</p><h3 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h3><ol><li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li><li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li><li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li></ol><ul><li>服务器发公钥给浏览器，浏览器随机数（传输密钥）加密后传给浏览器，浏览器再私钥解密得到 传输密钥（<code>非对称+对称加密</code>  、如果只非对称加密，浏览器的数据会被窃取）</li><li>问题：如果中间人用窃取公钥并拦截，并生成自己的公钥发给浏览器，作为中间商，就会出问题</li><li>如何确定浏览器收到的公钥是服务器给的：（域名、第三方机构、服务器公钥）给CA，CA添加数字签名（内容-&gt;hash-&gt;私钥加密）后给浏览器。浏览器解密（CA的公钥，浏览器信任的CA机构）看是否和明文hash一致</li></ul><h3 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h3><p>Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案</p><p>保存Sessionid的方式可以采用Cookie，请求时携带。如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。</p><h3 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h3><ol><li>浏览器查询 DNS，获取IP</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>TCP&#x2F;IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ol><h3 id="HTTP请求有哪些常见状态码？"><a href="#HTTP请求有哪些常见状态码？" class="headerlink" title="HTTP请求有哪些常见状态码？"></a>HTTP请求有哪些常见状态码？</h3><ol><li>2xx状态码：操作成功。200 OK</li><li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li><li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li><li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2021/09/08/%E6%9C%BA%E7%BB%84/"/>
    <url>/2021/09/08/%E6%9C%BA%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304061952053.png" alt="image-20210531150601852"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062002396.png" alt="image-20210531111032467" style="zoom: 67%;" /><p>软件</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012811.png" alt="image-20210531111208860" style="zoom:67%;" /><p>硬件</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012813.png" alt="image-20210531112655239"></p><h3 id="1-冯诺依曼"><a href="#1-冯诺依曼" class="headerlink" title="1.冯诺依曼"></a>1.冯诺依曼</h3><p>ENIAC手动接线代表指令。冯诺依曼将指令存储起来</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012814.png" alt="image-20210531113110649" style="zoom: 80%;" /><p><strong>运算器</strong>为中心，数据要经过运算器。</p><p>现代的将<strong>存储器</strong>为中心</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012815.png" alt="image-20210531113528807"></p><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><p>取存数据的程，现代这两个寄存器继承到了cpu里面</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012816.png" alt="image-20210531113844906" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012817.png" alt="image-20210531113937808" style="zoom:50%;" /></p><p>通过<strong>译码器</strong>将地址转为one hot，1的那个为接通</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012818.png" alt="image-20210531153111051"></p><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012819.png" alt="image-20210531114435559"></p><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012820.png" alt="image-20210531114630517"></p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>a * b + c 的执行过程，高级语言转为指令存放到内存中。这里的指令是单地址指令</p><p>根据pc从内存取指令(初始0)   <strong>-&gt;</strong>   分析指令（操作码）    <strong>-&gt;</strong>   执行指令内容      <strong>指令和数据都是来自存储体</strong>   </p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012821.png" alt="image-20210531115304027"></p><p>将机器指令转换为多条微指令</p><p>高级语言  -&gt;（编译）  汇编语言    -&gt;  操作系统  -&gt;（汇编） 机器语言 01   -&gt;    微指令</p><p>或者直接将高级语言转为机器语言（python）逐句翻译</p><h4 id="主频"><a href="#主频" class="headerlink" title="主频"></a>主频</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012822.png" alt="image-20210531151536611"></p><h4 id="波特率比特率"><a href="#波特率比特率" class="headerlink" title="波特率比特率"></a>波特率比特率</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012823.png" alt="image-20210607222453605"></p><h3 id="2-基础"><a href="#2-基础" class="headerlink" title="2.基础"></a>2.基础</h3><h4 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1.进制转换"></a>1.进制转换</h4><p>十进制转其他</p><p>​整数除基取余</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012824.png" alt="image-20210601113732024"></p><p>​小数乘基取整</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012825.png" alt="image-20210601113850208"></p><p>二进制转其他（4、8、16）：多位一组，分组转换</p><h4 id="2-BCD码"><a href="#2-BCD码" class="headerlink" title="2.BCD码"></a>2.BCD码</h4><p>用二进制表达十进制数，当超过10时需要加6修正</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012826.png" alt="image-20210601114659976"></p><h4 id="3-ASCII"><a href="#3-ASCII" class="headerlink" title="3.ASCII"></a>3.ASCII</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012827.png" alt="image-20210601114946178" style="zoom: 50%;" /><p>汉字7445个，需要2B</p><h4 id="4-校验"><a href="#4-校验" class="headerlink" title="4.校验"></a>4.校验</h4><p><strong>奇校验</strong>：加完校验1的个数为<strong>奇数个</strong>，一般放前面</p><p><strong>海明校验</strong>：p的位置为2^n，标记出出错位置</p><p>d为数据，p为校验码<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012828.png" alt="image-20210601120945066"></p><p>pi为d为1的下标上第i为异或得到，共需要大约log2位用来校验<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012829.png" alt="image-20210601121114649"></p><p><strong>循环冗余校验CRC ：</strong></p><p>有一个给出的生成多项式，最高为x次<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012830.png" alt="image-20210601121801336">，转为二进制被除数1101有x+1位，将数据左移x位后除以该数（模二除），得到的余数就是校验位。发送   移位后的数  加上  余数。</p><p>校验：数据模二除多项式，余数为零</p><h4 id="5-数据表示"><a href="#5-数据表示" class="headerlink" title="5.数据表示"></a>5.数据表示</h4><p>无符号数： 0 ~ 2^n-1</p><p>有符号数：一位表示符号</p><p>定点小数：纯小数。0. x，再加一位表示符号<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012831.png" alt="image-20210601122710917" style="zoom:67%;" /></p><p>原码：有符号数<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012832.png" alt="image-20210601123056307">，加减计算需要讨论符号</p><p>反码：负数按位取反</p><p><strong>补码</strong>：负数按位取反，末尾加一（原理上是用溢出值减绝对值）。计算直接加</p><p>移码：加上128后，转为无符号机器数。比较大小</p><p><strong>移位：</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012833.png" alt="image-20210601131324554" style="zoom: 67%;" /><p><strong>溢出判断</strong></p><p>​1.通过符号判断</p><p>​2.进位判断法：V&#x3D; S异或C 其中S为符号位产生的进位,C为最高有效位产生的进位。 </p><p>​3.双符号位： V&#x3D;Sf1 Sf2 + 其中,Sf1和Sf2分别为最高符号位及第二符号位。</p><h4 id="求补电路："><a href="#求补电路：" class="headerlink" title="求补电路："></a>求补电路：</h4><p>将补码表示的<strong>带符号数</strong>转换成 <strong>无符号绝对值</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012834.png" alt="image-20210601171422268"></p><h4 id="绝对值乘法"><a href="#绝对值乘法" class="headerlink" title="绝对值乘法"></a>绝对值乘法</h4><p>acc中保存当前进位，MQ高位保存结果以及低位未计算的乘数，当乘数都移出去后，结果就是ACC MQ</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012835.png" alt="image-20210601154034355"></p><h4 id="绝对值除法"><a href="#绝对值除法" class="headerlink" title="绝对值除法"></a>绝对值除法</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012836.png" alt="image-20210601160052898"></p><p>ACC中放当前值，MQ中放结果</p><h4 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012837.png" alt="image-20210601161602994" style="zoom: 80%;" /><p>规格化，M左移使得最高位有效</p><p>溢出时，将M右移</p><p><strong>IEEE 754</strong>       <img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012838.png" alt="image-20210601163257381"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012839.png" alt="image-20210601165117606">)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012840.png" alt="image-20210601163002198"></p><p>浮点数运算：小阶向大阶看齐</p><h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4><p>Arithmetic and logic unit  算数、逻辑、移位</p><p>与非：<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012841.png" alt="image-20210601165845453">现实容易实现</p><p>异或：<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012842.png" alt="image-20210601165936688">和加法的逻辑类似</p><p>全加器：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012843.png" alt="image-20210601170821403" style="zoom:50%;" /><p>多位串行：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012844.png" alt="image-20210601171144274" style="zoom:80%;" /><p>并行</p><p>组内并行，组间串行</p><h3 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3.存储器"></a>3.存储器</h3><p>读取过程：地址线先传送地址数据到MAR，略微等待后<strong>片选线</strong>和<strong>读写控制线</strong>给出信号，将数据读入MDR中</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012845.png" alt="image-20210602131615023"></p><p>实际上，地址是有<strong>行选和列选</strong>（需要的线少一倍），刷新时是以行为单位。</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012846.png" alt="image-20210602133806204" style="zoom:50%;" /><p>地址线连接MAR（行列分别传入），数据线连接MDR</p><p><strong>寻址方式：</strong>按字、字节、半字、双字寻址</p><p><strong>存储方法：</strong></p><p>​小段方式：先放低位字节，低位在左</p><p>​大段方式：先放高位，高位在左</p><h4 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h4><p>辅存不和cpu直接通信，主存RAM+ROM</p><h5 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h5><p>Random Access Memory</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012847.png" alt="image-20210602133519525"></p><p>刷新时间：2ms要都刷新过一次。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012848.png" alt="image-20210602134144186"></p><h5 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h5><p>Read only Memory</p><p>保存必要信息，非易失。保存os在辅存中的位置，开机必要信息</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012849.png" alt="image-20210603102734100" style="zoom: 67%;" /><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="位扩展："><a href="#位扩展：" class="headerlink" title="位扩展："></a><strong>位扩展</strong>：</h5><p>​进行位数的扩充（加大字长） 一个存储器对应byte中的一位</p><p>​例:使用16K<em>1的存储器芯片组成16K</em>8位的存储器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012851.png" alt="image-20210603104237304"></p><h5 id="字扩展法"><a href="#字扩展法" class="headerlink" title="字扩展法:"></a><strong>字扩展法</strong>:</h5><p>​进行字向扩充(位数不变)  需要先选择取哪个存储器</p><p>​例如：用16K*8位的芯片组成64K *8位的存储器</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012852.png" alt="image-20210603104254082"> </p><p>​A0~A13为地址选择 A14 A15为芯片选择（2:4译码器）</p><h5 id="字位同时扩展法"><a href="#字位同时扩展法" class="headerlink" title="字位同时扩展法:"></a>字位同时扩展法:</h5><p>​一个存储器的容量为M<em>N位,若使用 l</em>k位的芯片(l&lt;M,K&lt;N),需要在字向和位向同时进行扩展. 此时共需(M&#x2F;l)*(N&#x2F;k)个存储器芯片</p><h4 id="多体并行存储体"><a href="#多体并行存储体" class="headerlink" title="多体并行存储体"></a>多体并行存储体</h4><p>低位交叉编址</p><p>（右图）将相邻的单元放到不同的存储体中，这样<strong>不需要等待恢复时间</strong>再去读取下一个（流水线）</p><p>需要满足当再一次读取到M0时，M0已经恢复</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012853.png" alt="image-20210603112354973" style="zoom: 67%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012854.png" alt="image-20210603111717030"></p><p>宏观上扩展了4倍</p><h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>空间局部性原理（访问的都是相近的元素）</p><p>cache和主存可以<strong>以块为单位</strong>交流</p><p>标记项：cache是从主存中<strong>哪里来的</strong>、cache<strong>是否有效</strong></p><h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>​随便放，查找时遍历查看</p><h5 id="直接映射："><a href="#直接映射：" class="headerlink" title="直接映射："></a><strong>直接映射：</strong></h5><p>​主存第j块和Cache第i块有如下函数关系:</p><p>​i&#x3D; j mod m (m为Cache中总块数)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012855.png" alt="image-20210604111316459"></p><p>​访问过程：依据cache块号直接去查找，看表中对应保存的<strong>组号</strong>与主存中组号是否一样。</p><p>​空间利用率低,命中率也低，硬件实现简单,成本低.</p><h5 id="组相联映射："><a href="#组相联映射：" class="headerlink" title="组相联映射："></a><strong>组相联映射：</strong></h5><p>​将cache分组，主存必须放入对应组中，但组内可以随意放置</p><h5 id="替换与修改"><a href="#替换与修改" class="headerlink" title="替换与修改"></a>替换与修改</h5><p>RAND FIFO  LRU（最近最少使用）  LFU(历史次数)</p><p>写回法：脏位决定是否需要写回</p><p>全写法：有一个缓冲同时修改</p><h4 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h4><p>将访问外存（逻辑地址）映射到主存（物理地址）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012856.png" alt="image-20210604115521773"></p><h3 id="4-指令"><a href="#4-指令" class="headerlink" title="4.指令"></a>4.指令</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012857.png" alt="image-20210604165949832" style="zoom:67%;" /><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012858.png" alt="image-20210604152403058"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012859.png" alt="image-20210604153414463" style="zoom: 80%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012860.png" alt="image-20210604153350576" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012861.png" alt="image-20210604160201175"></p><h4 id="指令的址方式"><a href="#指令的址方式" class="headerlink" title="指令的址方式"></a>指令的址方式</h4><p>1.顺序寻址方式 2.跳跃寻址方式</p><h4 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式"></a>数据寻址方式</h4><p>用寻址特征表明现在的寻址方式</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012862.png" alt="image-20210604161158449" style="zoom:67%;" /><p>立即寻址</p><p>寄存器寻址 </p><p>直接寻址</p><p>寄存器间接寻址</p><p>基址寻址（BR）面向操作系统，内容操作系统确定，有利于<strong>多道程序数据块</strong></p><p>变址寻址（IX）用于循环程序，<strong>数组</strong>的偏移</p><p>相对寻址（PC）  （PC）+A  <strong>跳转指令</strong></p><p>寄存器寻址：（SP）保存栈顶指针</p><p>间接寻址</p><h4 id="CISC、RISC"><a href="#CISC、RISC" class="headerlink" title="CISC、RISC"></a>CISC、RISC</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012863.png" alt="image-20210604165458037"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012864.png" alt="image-20210604165743389"></p><h3 id="5-CPU"><a href="#5-CPU" class="headerlink" title="5.CPU"></a>5.CPU</h3><p>ALU+CU+寄存器+中断系统</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012865.png" alt="image-20210605121433796" style="zoom:67%;" /><h4 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h4><p>cpu<strong>内部总线</strong>完成内部数据传输；MAR，MDR要和<strong>内外总线</strong>都要连接</p><p>还有一种结构为：寄存器之间通过<strong>专用线</strong>连接</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012866.png" alt="image-20210605122928712"></p><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>一个机器周期（CPU周期）是一次存取周期</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012867.png" alt="image-20210605123401431" style="zoom: 67%;" /><h4 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h4><p>取指、取数</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012868.png" alt="image-20210605132815242" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012869.png" alt="image-20210605132849850" style="zoom: 67%;" /></p><h4 id="控制器-1"><a href="#控制器-1" class="headerlink" title="控制器"></a>控制器</h4><p><strong>cpu控制方式：</strong></p><p>​同步控制方式、异步控制方式、联合控制方式</p><p>同步：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012867.png" alt="image-20210605123401431" style="zoom: 67%;" /><h5 id="硬布线：RISC"><a href="#硬布线：RISC" class="headerlink" title="硬布线：RISC"></a><strong>硬布线：</strong>RISC</h5><p><strong>节拍发生器</strong>：将时钟转为节拍</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012870.png" alt="image-20210605141903363" style="zoom:50%;" /><p><strong>安排微操作的时钟节拍</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012871.png" alt="image-20210605135938501"></p><p><strong>设计电路</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012872.png" alt="image-20210605141448990"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012873.png" alt="image-20210605141717000"></p><h5 id="微程序：CISC"><a href="#微程序：CISC" class="headerlink" title="微程序：CISC"></a>微程序：CISC</h5><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012874.png" alt="image-20210605154140727" style="zoom:50%;" /><p>​将微指令保存到控制存储器CM中（CPU内部，ROM实现，一条条已经写好的），类似于指令的保存执行</p><p>​水平型：可以同时执行。垂直型：类似机器指令</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012875.png" alt="image-20210605151805913"></p><p>​<strong>操作控制字段</strong>：标记一个个微操作，</p><p>​<strong>直接表示法</strong>：为1就执行 需要很长   <strong>快</strong></p><p>​<strong>编码表示法</strong></p><p>​<strong>混合</strong><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012876.png" alt="image-20210605152026694" style="zoom:50%;" />组内互斥</p><p>​<strong>顺序控制字段</strong>：下一条微指令是 跳转 还是 顺序 </p><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>将这几个过程重叠起来，并行运行</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012877.png" alt="image-20210605160344293" style="zoom: 67%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012878.png" alt="image-20210605160349615"></p><p><strong>问题：</strong></p><p>​时间不一样：全部统一为最长的时间</p><p><strong>冲突：</strong></p><p>​硬件：</p><p>​       结构相关（资源冲突）：硬件资源满足不了  <strong>同时需要访问内存</strong></p><p>​编程：</p><p>​   数据相关（数据冲突）：一条指令依赖前一条指令的执行结果(数据)却无法得到 c&#x3D;a+b； c++;</p><p>​ <strong>硬件直接暂停   添加空指令</strong>  <strong>数据旁路</strong>  <strong>编译优化</strong></p><p>​控制相关（控制冲突）：流水线遇到分支(if) 指令或其他改变PC值的指令</p><p>​（acm算法运行为非流水执行过程。）</p><h3 id="6-总线"><a href="#6-总线" class="headerlink" title="6.总线"></a>6.总线</h3><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012879.png" alt="image-20210607212721351" style="zoom:67%;" /><p>​<strong>分时  共享</strong></p><p>​机械特性、电器特性、功能特性、时间特性</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>​串行、并行（宽度高、频率低） </p><p>​(内部总线、系统总线（数据、地址、控制）、I&#x2F;O总线) <strong>轮询</strong></p><p>​单总线双总线（速度不同，进行分离）</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012880.png" alt="image-20210607213949316" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012881.png" alt="image-20210607213918796" style="zoom:50%;" /></p><p>​三总线（提高io速度）       <strong>DMA控制器</strong>控制高速传输（不用CPU），别的<strong>中断</strong>（鼠标键盘）实现</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012882.png" alt="image-20210607214207930" style="zoom: 67%;" /><p>4总线</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012883.png" alt="image-20210607225218682"></p><p>​地址总线(AB)—其宽度可表明地址空间范围  32位寻址范围2^32 4G</p><p>​数据总线(DB)—其宽度可表明一次读写的二进制位数  32位4B</p><p>​控制总线(CB)— 包括各种控制命令(如存储器读 写、I&#x2F;O读写)、请求信号与仲裁信号、中断请求与应答 等。</p><p>​<strong>复用AB和DB</strong></p><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>​时钟周期T：机器的时钟周期     时钟频率：1&#x2F;T</p><p>​传输周期：N个时钟周期：申请、寻址、传输、结束工作频率：1&#x2F;N</p><p>​总线宽度：DB宽度</p><p>​总线带宽：每秒传输的B ，工作频率 * 总线带宽 &#x2F; 8</p><h4 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h4><h5 id="集中总裁"><a href="#集中总裁" class="headerlink" title="集中总裁"></a>集中总裁</h5><p>​<strong>链式查询</strong>：BR BG BS ，  <strong>BG按顺序查询，距离近的优先级高</strong></p><p>​<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012884.png" alt="image-20210607220159388" style="zoom: 67%;" /></p><p>​<strong>计算器定时查询</strong>：独立的BG线，计数器每次加1代表访问下一个IO ， log n</p><p>​<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012885.png" alt="image-20210607220536152" style="zoom:67%;" /></p><p>​<strong>独立请求</strong>：需要排队、速度快。独立的BG线</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012886.png" alt="image-20210607220713828" style="zoom:67%;" /><h5 id="分布式仲裁："><a href="#分布式仲裁：" class="headerlink" title="分布式仲裁："></a><strong>分布式仲裁</strong>：</h5><p>​不需要中央仲裁器，每个潜在的主 方功能模块都有自己的仲裁号和仲裁器</p><p>​将总裁号发到总裁总线上去比较</p><h4 id="总线操作"><a href="#总线操作" class="headerlink" title="总线操作"></a>总线操作</h4><p>​申请分配（请求、仲裁）、寻址阶段、传输阶段、结束阶段</p><p>​<strong>同步定时方式</strong>：根据时钟的<strong>上升沿</strong>控制节奏</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012887.png" alt="image-20210607222304595" style="zoom:50%;" /><p>​<strong>异步定时方式</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012888.png" alt="image-20210607222129667" style="zoom: 50%;" /><p>​<strong>半同步通信</strong>：加控制信号，当数据没传到位时等待</p><p>​<strong>分离式通信：</strong>将准备数据时，总线控制权交出来</p><h4 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012889.png" alt="image-20210607224104543"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012890.png" alt="image-20210607224633259"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012891.png" alt="image-20210607224925037"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012892.png" alt="image-20210607225022641"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012893.png" alt="image-20210607225726363"></p><h3 id="7-IO"><a href="#7-IO" class="headerlink" title="7.IO"></a>7.IO</h3><p>CPU<strong>管理外围设备</strong>有几种方式：</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012894.png" alt="image-20210626104910735" style="zoom:67%;" /><p>IO指令由CPU产生，用来控制IO；通道指令为通道产生，具体执行</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012895.png" alt="image-20210626103906731" style="zoom:67%;" /><h4 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h4><p>​输入： 鼠标键盘    输出 ：显示器打印机</p><p>​外存</p><p><strong>磁表面存储</strong> </p><p>​串行读取</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012896.png" alt="image-20210626110114399" style="zoom:67%;" /><p>​</p><p><strong>磁盘</strong></p><p>​按照扇区读取，寻道-&gt;旋转-&gt;传输时间。利用便宜可以实现加速或者冗余</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012897.png" alt="image-20210626110421321"></p><p><strong>光盘</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012898.png" alt="image-20210626111615777" style="zoom:50%;" /><p><strong>固态硬盘</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012899.png" alt="image-20210626111746131" style="zoom:67%;" /><h4 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h4><p>控制、读取io其实就是访问响应寄存器</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012900.png" alt="image-20210626112849731" style="zoom:67%;" /><p>如何定位编址？统一编址、独立编址（主存的编址和IO的编址是否在一起）</p><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>​比如每秒查询鼠标30次，询问鼠标有没有数据。查到了还需要等待鼠标传输数据</p><h4 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012902.png" alt="image-20210626114555456" style="zoom: 67%;" /><p>在指令完成后，查看中断源寄存器是否有1，有1就进入中断</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012903.png" alt="image-20210626182320701" style="zoom:67%;" /><p>实现<strong>优先级</strong></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012904.png" alt="image-20210626184052004" style="zoom:67%;" /><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012905.png" alt="image-20210626184644527"></p><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>​接收IO请求，向CPU发出占用总线的请求</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手学深度学习CV</title>
    <link href="/2021/08/20/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0CV/"/>
    <url>/2021/08/20/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0CV/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html">https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html</a></p><p><a href="https://course.d2l.ai/zh-v2/">课程安排 - 动手学深度学习课程 (d2l.ai)</a></p><h1 id="动手学深度学习"><a href="#动手学深度学习" class="headerlink" title="动手学深度学习"></a>动手学深度学习</h1><p>AI map</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151329785.png" alt="image-20230515132921268" style="zoom:67%;" /><h3 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.arange(<span class="hljs-number">12</span>, dtype=torch.float32).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>torch.cat((X, Y), dim=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 合并</span><br>a.T <span class="hljs-comment"># 转置</span><br>a.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) a.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>) <br>a.mean() a.numel()<br><br>torch.dot(x,y) <span class="hljs-comment"># 向量点积</span><br>torch.mv(A,x)  <span class="hljs-comment"># 矩阵*向量</span><br>torch.mm(A,A)  <span class="hljs-comment"># 矩阵乘</span><br>torch.norm(A)  <span class="hljs-comment"># 二范数</span><br><br><span class="hljs-comment"># 广播机制自动扩展</span><br>a = torch.arange(<span class="hljs-number">3</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">1</span>))<br>b = torch.arange(<span class="hljs-number">2</span>).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>a+b<br><br><span class="hljs-comment"># 内存机制</span><br>X = Y<span class="hljs-comment"># id相同</span><br>Y += X     <span class="hljs-comment"># id(Y)不变</span><br><br>X = Y.clone() <span class="hljs-comment">#id 变了</span><br>Y = Y + X  <span class="hljs-comment"># id(Y)变了</span><br><br><span class="hljs-comment"># numpy 相互转换</span><br>A = torch.tensor(A)<br>A = A.numpy()<br></code></pre></td></tr></table></figure><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建数据csv文件</span><br>os.makedirs(os.path.join(<span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>), exist_ok=<span class="hljs-literal">True</span>)<br>data_file = os.path.join(<span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;house_tiny.csv&#x27;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_file, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="hljs-comment"># 列名</span><br>    f.write(<span class="hljs-string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="hljs-comment"># 每行表示一个数据样本</span><br>    f.write(<span class="hljs-string">&#x27;2,NA,106000\n&#x27;</span>)<br><br><span class="hljs-comment"># 读取csv</span><br>data = pd.read_csv(data_file)<br>data = data.fillna(data.mean())  <span class="hljs-comment"># 处理数值中的NA</span><br><span class="hljs-built_in">print</span>(data)<br>data = pd.get_dummies(data, dummy_na=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将数据转为0 1，添加新的列</span><br>torch.tensor(data.values)<br></code></pre></td></tr></table></figure><h4 id="向量求导"><a href="#向量求导" class="headerlink" title="向量求导"></a>向量求导</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151334475.png" alt="image-20210729204049868" style="zoom:50%;" /><h4 id="正向累积与反向求导"><a href="#正向累积与反向求导" class="headerlink" title="正向累积与反向求导"></a>正向累积与反向求导</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335071.png" alt="image-20210715122123643"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335072.png" alt="image-20210715122132742" style="zoom:50%;" /><h4 id="自动求导"><a href="#自动求导" class="headerlink" title="自动求导"></a>自动求导</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">x =  torch.arange(<span class="hljs-number">4.0</span>)<br>x.requires_grad_(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 等价于 `x = torch.arange(4.0, requires_grad=True)`</span><br>y = <span class="hljs-number">2</span> * torch.dot(x, x) <span class="hljs-comment"># loss一般为标量</span><br>y.backward() <span class="hljs-comment"># 反向传播</span><br>x.grad<br>tensor([ <span class="hljs-number">0.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">8.</span>, <span class="hljs-number">12.</span>])<br><br><span class="hljs-comment"># 梯度分离计算</span><br>x.grad.zero_()<br>y = x * x<br>u = y.detach()      <span class="hljs-comment"># u不计算梯度,相当于常数，从计算图剥离</span><br>z = u * x<br>z.<span class="hljs-built_in">sum</span>().backward()  <span class="hljs-comment">#非标量求sum，使得标量</span><br>x.grad == u<br></code></pre></td></tr></table></figure><p>sinx 和 sinx的求导</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x=torch.arange(<span class="hljs-number">0.</span>,<span class="hljs-number">10.</span>,<span class="hljs-number">0.1</span>)x.requires_grad_(<span class="hljs-literal">True</span>)y=torch.sin(x)y.<span class="hljs-built_in">sum</span>().backward()plt.plot(x.detach(), y.detach())plt.plot(x.detach(), x.grad)<br></code></pre></td></tr></table></figure><p>帮助文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">help</span>(torch.ones)<br></code></pre></td></tr></table></figure><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>模型：y &#x3D; &lt;x,w&gt; + b</p><p>损失：（y-y)^2^ </p><p>关于w求导，有显示解</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335073.png" alt="image-20210729210215127" style="zoom:50%;" /><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335074.png" alt="image-20210729210517365" style="zoom: 50%;" /><h5 id="BGD"><a href="#BGD" class="headerlink" title="BGD"></a><strong>BGD</strong></h5><p>(Batch Gradient Descent)</p><p>​使用全部数据集</p><h5 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a><strong>SGD</strong></h5><p>（stochastic gradient descent）</p><p>​使用1个数据</p><h5 id="MBGD"><a href="#MBGD" class="headerlink" title="MBGD"></a>MBGD</h5><p>（mini-batch Gradient Descent）</p><p>​使用batchsize</p><h5 id="动量法："><a href="#动量法：" class="headerlink" title="动量法："></a><strong>动量法：</strong></h5><p>梯度更新 &#x3D; 当前的梯度方向*0.1  +  之前的累加 (v) *0.9  (u) ，还可以逃出局部最优解   <strong>0.9</strong></p><h5 id="自适应梯度法"><a href="#自适应梯度法" class="headerlink" title="自适应梯度法"></a><strong>自适应梯度法</strong></h5><p><strong>RMSProp：</strong>调整学习率  <strong>0.999</strong></p><p>​对震荡方向减小变化，非震荡方向增大变化，变化值保存到r中,用梯度的平方表示震荡</p><h5 id="adam："><a href="#adam：" class="headerlink" title="adam："></a><strong>adam</strong>：</h5><p>​动量法+自适应+修正解决冷启动</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335075.png" alt="image-20210801153746463" style="zoom: 80%;" /><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>1.生成数据</p><p>2.生成batchsize迭代器</p><p>3.参数与模型定义 net &#x3D; nn.Sequential(nn.Linear(2, 1))</p><p>4.损失函数与优化 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 损失函数默认是batch中 平均</span><br>nn.MSELoss() <br>torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<br><span class="hljs-keyword">or</span> <br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>param -= lr * param.grad / batch_size<br></code></pre></td></tr></table></figure><ul><li>初始化参数</li><li>重复，直到完成<ul><li>计算损失                                           <strong>l&#x3D;loss(net(X), y)</strong></li><li>计算梯度 g←∂(w,b)1|B|∑i∈Bl(x(i),y(i),w,b)g←∂(w,b)1|B|∑i∈Bl(x(i),y(i),w,b)   <strong>l.backward()</strong></li><li>更新参数 (w,b)←(w,b)−ηg               <strong>trainer.step()</strong></li></ul></li></ul><h4 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h4><p>softmax转为概率，交叉熵来衡量概率区别</p><h4 id="图片分类"><a href="#图片分类" class="headerlink" title="图片分类"></a>图片分类</h4><p>784输入 ， 10输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mnist_train = torchvision.datasets.FashionMNIST(root=<span class="hljs-string">&quot;../data&quot;</span>, train=<span class="hljs-literal">True</span>,                                                transform=trans,                                                download=<span class="hljs-literal">True</span>)train_iter = data.DataLoader(mnist_train, batch_size, shuffle=<span class="hljs-literal">True</span>,                             num_workers=get_dataloader_workers())<br></code></pre></td></tr></table></figure><p>自定义croos_entropy需要先softmax，后面还需要sum；torch的都不用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">X</span>):    <br>    X_exp = torch.exp(X)    <br>    partition = X_exp.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)    <br>    <span class="hljs-keyword">return</span> X_exp / partition  <br><span class="hljs-comment"># 这里应用了广播机制</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">net</span>(<span class="hljs-params">X</span>):    <br>    <span class="hljs-keyword">return</span> softmax(np.dot(X.reshape((-<span class="hljs-number">1</span>, W.shape[<span class="hljs-number">0</span>])), W) + b)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy</span>(<span class="hljs-params">y_hat, y</span>):    <br>    <span class="hljs-keyword">return</span> -np.log(y_hat[<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_hat)), y])<br>y_hat[<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_hat)), y] <span class="hljs-comment"># 取出每个实际标签的得分</span><br></code></pre></td></tr></table></figure><p>net</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">net = nn.Sequential(nn.Flatten(), nn.Linear(<span class="hljs-number">784</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p>一次epoch训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_epoch_ch3</span>(<span class="hljs-params">net, train_iter, loss, updater</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;训练模型一个迭代周期（定义见第3章）。&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 将模型设置为训练模式</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(net, torch.nn.Module):<br>        net.train()<br>    <span class="hljs-comment"># 训练损失总和、训练准确度总和、样本数</span><br>    metric = Accumulator(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> train_iter:<br>        <span class="hljs-comment"># 计算梯度并更新参数</span><br>        y_hat = net(X)<br>        l = loss(y_hat, y)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(updater, torch.optim.Optimizer):<br>            <span class="hljs-comment"># 使用PyTorch内置的优化器和损失函数</span><br>            updater.zero_grad()<br>            l.backward()<br>            updater.step()<br>            metric.add(<br>                <span class="hljs-built_in">float</span>(l) * <span class="hljs-built_in">len</span>(y), accuracy(y_hat, y),<br>                y.size().numel())<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 使用定制的优化器和损失函数</span><br>            l.<span class="hljs-built_in">sum</span>().backward()<br>            updater(X.shape[<span class="hljs-number">0</span>])<br>            metric.add(<span class="hljs-built_in">float</span>(l.<span class="hljs-built_in">sum</span>()), accuracy(y_hat, y), y.numel())<br>    <span class="hljs-comment"># 返回训练损失和训练准确率</span><br>    <span class="hljs-keyword">return</span> metric[<span class="hljs-number">0</span>] / metric[<span class="hljs-number">2</span>], metric[<span class="hljs-number">1</span>] / metric[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>多次epoch，传入网络，训练数据，测试数据，loss，迭代次数，优化器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_ch3</span>(<span class="hljs-params">net, train_iter, test_iter, loss, num_epochs, updater</span>):<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):        train_metrics = train_epoch_ch3(net, train_iter, loss, updater)        <span class="hljs-comment"># 每次epoch后进行一次评估        test_acc = evaluate_accuracy(net, test_iter)</span><br></code></pre></td></tr></table></figure><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><p>Multilayer Perceptro</p><p>线性分类器只能产生线性分类器，XOR函数不能拟合</p><p>多层线性＋激活函数 sigmoid tanh relu</p><p>SVM多超参数不敏感，用起来更简单</p><p>深层比浅层更好训练</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335076.png" alt="image-20210802172049923" style="zoom:50%;" /><h4 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h4><p>训练误差，泛化误差</p><p>训练集 、验证集、 测试集</p><p>训练集训练参数，验证集来选择模型超参数</p><h5 id="k折交叉验证"><a href="#k折交叉验证" class="headerlink" title="k折交叉验证"></a>k折交叉验证</h5><p>​小数据集：K次模型训练和验证，每次在K−1个子集上进行训练，并在剩余的一个子集验证，K次实验的结果取平均来估计训练和验证误差。k&#x3D;5、10</p><h5 id="过拟合欠拟合"><a href="#过拟合欠拟合" class="headerlink" title="过拟合欠拟合"></a>过拟合欠拟合</h5><p>过拟合：模型相比于数据过于复杂</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335077.png" alt="image-20210803135322068"></p><p>模型输入为x^0  x^1  x^2 ….</p><p>当模型给到了x^20次方时，会过拟合</p><h4 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h4><p><strong>手动实现</strong>：loss中加上一个损失，lambd&#x3D;8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">l = loss(net(X), y) + lambd *  torch.<span class="hljs-built_in">sum</span>(w.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>)) / <span class="hljs-number">2</span><br>l.<span class="hljs-built_in">sum</span>().backward()<br>d2l.sgd([w, b], lr, batch_size)<br></code></pre></td></tr></table></figure><p><strong>迭代器</strong>：weight_decay &#x3D; 0.001</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 都有衰减</span><br>trainer = torch.optim.SGD(net.parameters(),weight_decay = wd, lr=lr)<br><span class="hljs-comment"># 偏置参数没有衰减。</span><br>trainer = torch.optim.SGD([&#123;<br>    <span class="hljs-string">&quot;params&quot;</span>: net[<span class="hljs-number">0</span>].weight,<span class="hljs-string">&#x27;weight_decay&#x27;</span>: wd&#125;, &#123;<br>    <span class="hljs-string">&quot;params&quot;</span>: net[<span class="hljs-number">0</span>].bias&#125;], <br>    lr=lr)<br><br>trainer.zero_grad()<br>l = loss(net(X), y)<br>l.backward()<br>    trainer.step()<br></code></pre></td></tr></table></figure><p>L1: torch.sum( torch.abs(w) )</p><h4 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h4><p>全连接上，比L2好一点</p><p>随机中间层变成0，p概率。总体期望不能变，需要除以(1-p) ;       p&#x3D;0.5  0.1  0.9</p><p><strong>自己实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dropout_layer</span>(<span class="hljs-params">X, dropout</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> &lt;= dropout &lt;= <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 在本情况中，所有元素都被丢弃。</span><br>    <span class="hljs-keyword">if</span> dropout == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> torch.zeros_like(X)<br>    <span class="hljs-comment"># 在本情况中，所有元素都被保留。</span><br>    <span class="hljs-keyword">if</span> dropout == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> X<br>    mask = (torch.Tensor(X.shape).uniform_(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &gt; dropout).<span class="hljs-built_in">float</span>()<br>    <span class="hljs-keyword">return</span> mask * X / (<span class="hljs-number">1.0</span> - dropout)<br><br>H1 = self.relu(self.lin1(X.reshape((-<span class="hljs-number">1</span>, self.num_inputs))))<br><span class="hljs-comment"># 只有在训练模型时才使用dropout，测试时直接跳过</span><br><span class="hljs-keyword">if</span> self.training == <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 在第一个全连接层之后添加一个dropout层</span><br>    H1 = dropout_layer(H1, dropout1)<br></code></pre></td></tr></table></figure><p><strong>torch</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nn.Dropout(p=<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><h4 id="数据稳定性"><a href="#数据稳定性" class="headerlink" title="数据稳定性"></a>数据稳定性</h4><p>梯度消失和梯度爆炸：sigmoid导数 ： y(1-y)      当多个相乘后就可能很小；</p><p>乘法变加法：ResNet LSTM</p><p>权重初始化、激活函数选择</p><h4 id="房价预测"><a href="#房价预测" class="headerlink" title="房价预测"></a>房价预测</h4><p>数据量较少，k折交叉验证</p><p>1.数据列标准化，并填空值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">numeric_features = all_features.dtypes[all_features.dtypes != <span class="hljs-string">&#x27;object&#x27;</span>].index<br>all_features[numeric_features] = all_features[numeric_features].apply(    <span class="hljs-keyword">lambda</span> x: (x - x.mean()) / (x.std()))<br><span class="hljs-comment"># 在标准化数据之后，所有数据都意味着消失，因此我们可以将缺失值设置为0</span><br>all_features[numeric_features] = all_features[numeric_features].fillna(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>2.非数据onehot，NAN也算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">all_features = pd.get_dummies(all_features, dummy_na=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>3.损失函数mse、评价指标如下、迭代器adam(学习率不敏感)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335078.png" alt="image-20210809134630261"></p><p>对于少量数据k验证，使用多层感知机后发现过拟合了</p><h3 id="房价预测-1"><a href="#房价预测-1" class="headerlink" title="房价预测"></a>房价预测</h3><p>数组大：对大数值log</p><p>文本特征：onehot是不行的，需要将文本求特征</p><p>训练数据前6月，公榜后3个月，私榜再后3个月</p><p>只取数字-&gt;取文本unique较少的部分</p><p>3层线性加L2，lr0.02，损失函数越来越多<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335079.png" alt="image-20210809191439398" style="zoom:50%;" /></p><p>4层线性，lr&#x3D;0.05,测试集误差在0.3左右<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335080.png" alt="image-20210809191904988" style="zoom:50%;" /></p><p>lr&#x3D;0.02 L2&#x3D;0.001<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335081.png" alt="image-20210809192441435" style="zoom:50%;" />L2&#x3D;0<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335082.png" alt="image-20210809192626754" style="zoom:50%;" /></p><p>5层 lr&#x3D;0.02<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335083.png" alt="image-20210809192835180" style="zoom: 33%;" />batchsize128<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335084.png" alt="image-20210809193317967" style="zoom:50%;" /></p><p>4层 0.05, 0, 128<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335085.png" alt="image-20210809193927803" style="zoom:50%;" /></p><h3 id="卷积网络"><a href="#卷积网络" class="headerlink" title="卷积网络"></a>卷积网络</h3><h4 id="卷积核"><a href="#卷积核" class="headerlink" title="卷积核"></a>卷积核</h4><p>二维全连接加限制</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335086.png" alt="image-20210810114817749" style="zoom:67%;" /><p>平移不变性：卷积核不依赖于位置<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335087.png" alt="image-20210810111608989" style="zoom:50%;" /></p><p>局部性：只由周围一定范围影响，限制ab范围</p><p><strong>二维互相关运算：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">corr2d</span>(<span class="hljs-params">X, K</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;计算二维互相关运算。&quot;&quot;&quot;</span><br>    h, w = K.shape<br>    Y = torch.zeros((X.shape[<span class="hljs-number">0</span>] - h + <span class="hljs-number">1</span>, X.shape[<span class="hljs-number">1</span>] - w + <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Y.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Y.shape[<span class="hljs-number">1</span>]):<br>            Y[i, j] = (X[i:i + h, j:j + w] * K).<span class="hljs-built_in">sum</span>()<br>    <span class="hljs-keyword">return</span> Y<br></code></pre></td></tr></table></figure><p><strong>卷积层</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Conv2D</span>(nn.Module):    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, kernel_size,bias=<span class="hljs-literal">False</span></span>):        <br>        <span class="hljs-built_in">super</span>().__init__()        <br>        self.weight = nn.Parameter(torch.rand(kernel_size))        <br>        self.bias = nn.Parameter(torch.zeros(<span class="hljs-number">1</span>))        <br>        self.is_bias = bias    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):        <br>        <span class="hljs-keyword">if</span> self.is_bias:            <br>            <span class="hljs-keyword">return</span> corr2d(x, self.weight) + self.bias        <br>        <span class="hljs-keyword">else</span>:            <br>            <span class="hljs-keyword">return</span> corr2d(x, self.weight)<br></code></pre></td></tr></table></figure><p><strong>实验：</strong>训练一个边缘卷积核，包括使用自己的卷积层</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335088.png" alt="image-20210810131342542"></p><p>一般2p &#x3D; k - 1，在这种情况下且原来大小w能被s整除，w &#x3D; w&#x2F;s ,  s影响计算量</p><p><strong>多输入通道</strong>：ci每一个输入通道一个核，求和后得到一个输出  ( ci * h * w) * ( ci * h * w)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">corr2d_multi_in</span>(<span class="hljs-params">X, K</span>):<br>    <span class="hljs-comment"># 先遍历 “X” 和 “K” 的第0个维度（通道维度），再把它们加在一起</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(d2l.corr2d(x, k) <span class="hljs-keyword">for</span> x, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(X, K))<br></code></pre></td></tr></table></figure><p><strong>多输出通道</strong>：c0每个输出多次求多输入通道     ( ci * h * w)    *  ( c0 * ci * h * w)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">corr2d_multi_in_out</span>(<span class="hljs-params">X, K</span>):<br>    <span class="hljs-comment"># 迭代“K”的第0个维度，每次都对输入“X”执行互相关运算。</span><br>    <span class="hljs-comment"># 最后将所有结果都叠加在一起</span><br>    <span class="hljs-keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> K], <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335089.png" alt="image-20210810134504645"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335090.png" alt="image-20210810134730194" style="zoom:50%;" /><p>参数量：C * C * H * W</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>使用经典网络还是自己设计：使用经典，微调         resnet</p><p>3 * 3可以提取空间信息； 1 * 1可以做通道融合   ，二者结合当卷积可以节约计算量</p><p>1d卷积可以处理文本</p><p>3d卷积处理视频或深度图片</p><h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><p>对于每一个输出通道进行，最大、平均。通常步长等于核大小</p><p><strong>减小运算量、增大感受野、非极大抑制</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="hljs-built_in">max</span>()<br></code></pre></td></tr></table></figure><p>池化现在用的越来越少，卷积中可以加stride。数据加了增强，不需要池化来消除便宜</p><p>缩小两倍，尺寸不变：nn.MaxPool2d(kernel_size&#x3D;2,stride&#x3D;2)   vgg</p><p>​nn.MaxPool2d(kernel_size&#x3D;3, stride&#x3D;2, padding&#x3D;1)         googlenet</p><h3 id="经典网络"><a href="#经典网络" class="headerlink" title="经典网络"></a>经典网络</h3><p>机器学习：<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335091.png" alt="image-20210810155949246" style="zoom:50%;" /></p><p>关键是特征提取，然后SVM等</p><h4 id="0-LeNet"><a href="#0-LeNet" class="headerlink" title="0.LeNet"></a>0.LeNet</h4><p>和MLP比起来，模型量小了，overfitting小了</p><p>​conv -&gt; subsampling-&gt;conv-&gt;subsampling-&gt;FC-&gt;FC-&gt;FC     2conv+3FC</p><p>lr 0.9-&gt;0.5  sigmoid-&gt;ReLU     acc上升0.876</p><h4 id="1-AlexNet"><a href="#1-AlexNet" class="headerlink" title="1.AlexNet"></a>1.AlexNet</h4><p><strong>dropout   ReLU  MaxPooling   数据增强</strong></p><p>10倍参数，250倍计算量LeNet</p><p>​5个conv + 3个FCN（Dropout）</p><p>acc 0.883</p><h4 id="2-VGG"><a href="#2-VGG" class="headerlink" title="2.VGG"></a>2.VGG</h4><p>vgg块：多个3*3卷积 + 池化            每次宽高减半，通道加倍</p><p>最后同样3个FCN（Dropout）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">conv_arch11 = ((<span class="hljs-number">1</span>, <span class="hljs-number">64</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">512</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">512</span>))<br>conv_arch16 = ((<span class="hljs-number">2</span>, <span class="hljs-number">64</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">512</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">512</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">vgg_block</span>(<span class="hljs-params">num_convs, in_channels, out_channels</span>):<br>    layers = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_convs):<br>        layers.append(nn.Conv2d(in_channels, out_channels,<br>                                kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>))<br>        layers.append(nn.ReLU())<br>        in_channels = out_channels<br>    layers.append(nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br></code></pre></td></tr></table></figure><p>这里降低vgg11通道数进行训练，batchsize&#x3D;16，训练了1h，过拟合明显</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">train</span> acc <span class="hljs-number">0</span>.<span class="hljs-number">964</span>, test acc <span class="hljs-number">0</span>.<span class="hljs-number">928</span><br></code></pre></td></tr></table></figure><h4 id="3-NIN"><a href="#3-NIN" class="headerlink" title="3.NIN"></a>3.NIN</h4><p>第一个FC的参数量太大了，很容易<strong>过拟合</strong>。NIN完全<strong>放弃全连接</strong></p><p>NIN块：卷积+2个1*1卷积，然后加maxpool。</p><p>最后留10通道<strong>每个通道</strong>全局最大池化<strong>nn.AdaptiveAvgPool2d(1)</strong>, 全局池化也可以用来中间降低复杂度，但收敛更慢</p><h4 id="4-GoogleNet"><a href="#4-GoogleNet" class="headerlink" title="4.GoogleNet"></a>4.GoogleNet</h4><p>inception输入输出大小不变,步长都是1。block：多个Inception后加一个maxpool</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335092.png" alt="image-20210810200812388" style="zoom: 50%;" /><p>大量使用1 * 1 ，最后1024通道GlobalAvgPool后传入FC。并行通道提升网络复杂度</p><p>前两大段卷积提取，降低8倍大小。</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335093.png" alt="image-20210810202558830" style="zoom:50%;" /><p>v2使用batch normalization</p><p>v3修改inception，使用3*3级联代替5 *5，和使用1 * 3、3 * 1卷积</p><p>v4使用残差</p><h4 id="5-归一化"><a href="#5-归一化" class="headerlink" title="5.归一化"></a>5.归一化</h4><p>通过一个batch中的均值和方差来提高<strong>数值稳定性</strong>。固定小批量中的均值和方差，加速收敛速度但不改变准确率。</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335094.png" alt="image-20210811130833324"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335095.png" alt="image-20210811135140140" style="zoom:67%;" /><p>全连接对batch求     mean &#x3D; X.mean(dim&#x3D;0)         预测时就只有一个，所以用全局的</p><p>卷积层对某一通道所有元素所有batch求   mean &#x3D; X.mean(dim&#x3D;(0, 2, 3), keepdim&#x3D;True)</p><p>u σ在<strong>推理</strong>时使用<strong>全局</strong>的，在训练中不断动量更新。<strong>训练</strong>时为当前数据的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 训练模式下，用当前的均值和方差做标准化</span><br><span class="hljs-attr">X_hat</span> = (X - mean) / torch.sqrt(var + eps)<br><span class="hljs-comment"># 更新移动平均的均值和方差</span><br><span class="hljs-attr">moving_mean</span> = momentum * moving_mean + (<span class="hljs-number">1.0</span> - momentum) * mean<br><span class="hljs-attr">moving_var</span> = momentum * moving_var + (<span class="hljs-number">1.0</span> - momentum) * var<br></code></pre></td></tr></table></figure><p>γ β是归一化层参数，不断训练</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">Y = <span class="hljs-built_in">gamma</span> * X_hat + <span class="hljs-built_in">beta</span>  <span class="hljs-meta"># 缩放和移位</span><br><span class="hljs-keyword">return</span> Y<br></code></pre></td></tr></table></figure><p>参数：输入维度、全连接还是卷积</p><p>原论文：<strong>梯度爆炸和梯度消失在引入bn层之后基本解决</strong></p><p>用在LeNet上 原来50epoch现在只需要10epoch来达到0.875</p><h4 id="6-RestNet"><a href="#6-RestNet" class="headerlink" title="6.RestNet"></a>6.RestNet</h4><p><strong>函数角度：</strong>不断加大模型的复杂度，并且包括原来的内容</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335096.png" alt="image-20210811140847581" style="zoom: 67%;" /><p><strong>梯度角度：</strong>前面的w还是能更新，处了乘法边还有一条边。</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335097.png" alt="image-20210811152206875" style="zoom: 50%;" /><p>Residual块：主干2个卷积；如果加通道，分支1*1卷积改变通道和大小。有原大小 和 大小减半通道加倍两种</p><p>​卷积 归一  激活 卷积 归一  +x   激活</p><p>resnet_block：多个Residual（2个），第一个进行通道加倍大小减半，别的为普通的</p><p><strong>res18</strong>：单次卷积 + 4个block（第一个不改通道） + AdaptiveAvgPool2d FC</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335098.png" alt="image-20210811150840115"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">res18：<br>train acc <span class="hljs-number">0.996</span>, test acc <span class="hljs-number">0.918</span> 明显过拟合，但精度特别高<br><span class="hljs-number">658.9</span> examples/sec<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">res34</span>:<br><span class="hljs-attribute">train</span> acc <span class="hljs-number">0</span>.<span class="hljs-number">983</span>, test acc <span class="hljs-number">0</span>.<span class="hljs-number">903</span><br><span class="hljs-attribute">369</span>.<span class="hljs-number">8</span> examples/sec<br></code></pre></td></tr></table></figure><p> 改良版：“批量归一化、激活和卷积”结构</p><p><strong>Res50</strong>：Bottleneck：先卷积缩小通道，再用3*3卷积（stride在这一层），最后再扩大通道</p><p>in_places：输入通道数</p><p>places：中转小通道数，输出通道为expansion  * places</p><p>stride&#x3D;1：是否缩小</p><p>downsampling&#x3D;False：级联Bottleneck的第一个需要，表示通道是否变化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_layer</span>(<span class="hljs-params">self, in_places, places, block, stride</span>):<br>        layers = []<br>        <span class="hljs-comment"># 进去in_places，出来places * expansion。所以downsampling</span><br>        <span class="hljs-comment"># stride第一个layer时=1 </span><br>        layers.append(Bottleneck(in_places, places,stride, downsampling =<span class="hljs-literal">True</span>))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, block):<br>            layers.append(Bottleneck(places*self.expansion, places))<br><br>        <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br>    <br>ResNet50([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>])  ResNet101([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">23</span>, <span class="hljs-number">3</span>])  ResNet512([<span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">36</span>, <span class="hljs-number">3</span>])<br>self.layer1 = self.make_layer(in_places = <span class="hljs-number">64</span>, places= <span class="hljs-number">64</span>, block=blocks[<span class="hljs-number">0</span>], stride=<span class="hljs-number">1</span>)<br>self.layer2 = self.make_layer(in_places = <span class="hljs-number">256</span>,places=<span class="hljs-number">128</span>, block=blocks[<span class="hljs-number">1</span>], stride=<span class="hljs-number">2</span>)<br>self.layer3 = self.make_layer(in_places=<span class="hljs-number">512</span>,places=<span class="hljs-number">256</span>, block=blocks[<span class="hljs-number">2</span>], stride=<span class="hljs-number">2</span>)<br>self.layer4 = self.make_layer(in_places=<span class="hljs-number">1024</span>,places=<span class="hljs-number">512</span>, block=blocks[<span class="hljs-number">3</span>], stride=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="7-DenseNet"><a href="#7-DenseNet" class="headerlink" title="7.DenseNet"></a>7.DenseNet</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335099.png" alt="image-20210811154128250" style="zoom:67%;" /><p>DenseBlock：卷积后和卷积前进行堆叠 ，num_convs(堆叠次数), input_channels, growth_rate(每次成长通道数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_convs):<br>        layer.append(conv_block(<br>            num_channels * i + input_channels, num_channels))<br>    self.net = nn.Sequential(*layer)<br><span class="hljs-keyword">for</span> blk <span class="hljs-keyword">in</span> self.net:<br>    Y = blk(X)<br>    <span class="hljs-comment"># 连接通道维度上每个块的输入和输出</span><br>    X = torch.cat((X, Y), dim=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="kaggle"><a href="#kaggle" class="headerlink" title="kaggle"></a>kaggle</h4><p><a href="https://www.kaggle.com/competitions/classify-leaves">https://www.kaggle.com/competitions/classify-leaves</a></p><p><a href="https://www.kaggle.com/sheepwang/leaf-classification-eda-model">https://www.kaggle.com/sheepwang/leaf-classification-eda-model</a></p><p>类型处理：转为集合再转列表再排序，最后放入字典中class2idx</p><p>timm模型库</p><p><strong>模型融合：</strong>softmax融合或者3模型投票</p><p><strong>tta</strong>：自动将测试图片进行变换</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335100.png" alt="image-20210822223718937"></p><p><a href="https://blog.csdn.net/weixin_38208912/article/details/104976458">图像分类竞赛——Test Time Augmentation（TTA）_再困也得吃的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install ttach <span class="hljs-comment">#Test Time Augmentation</span><br>tta_model = tta.ClassificationTTAWrapper(model, tta.aliases.five_crop_transform(),  merge_mode=<span class="hljs-string">&#x27;mean&#x27;</span>)<br>y_hat = tta_model(x)<br></code></pre></td></tr></table></figure><p>lr &#x3D; 0.1 波动很大，lr太大了</p><p>resnet34预训练   lr &#x3D; 0.01  SGD<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335101.png" alt="image-20210811205844447" style="zoom: 80%;" /></p><p>resnet34无预训练  lr &#x3D; 0.01<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335102.png" alt="image-20210811212948245" style="zoom:50%;" /></p><p>自己的resnet34 lr &#x3D; 0.01<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335103.png" alt="image-20210811215448723" style="zoom:50%;" /></p><p>自己的resnet50  lr &#x3D; 0.01<img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335104.png" alt="image-20210811221815881" style="zoom: 50%;" /></p><p>网络：efficientnet_pytorch , seresnext50_32x4d,  resnet50,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">!pip install timm<br>model_1 = timm.create_model(<span class="hljs-string">&#x27;seresnext50_32x4d&#x27;</span>, pretrained=<span class="hljs-literal">True</span>)<br>model_1.fc = nn.Linear(model_1.fc.in_features, <span class="hljs-number">176</span>)<br></code></pre></td></tr></table></figure><p>renet34       1e-4     64</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335105.png" alt="image-20210812015137028" style="zoom:67%;" /><h5 id="resnet50"><a href="#resnet50" class="headerlink" title="resnet50"></a>resnet50</h5><p>​b&#x3D;128（最大）  3.5mins       b&#x3D;16 6mins               b&#x3D;16 7mins 本地</p><p>​本地的5轮达到最佳0.884，云端大约0.94</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">k折 train:<span class="hljs-number">0.9831</span>  test：<span class="hljs-number">0.9082</span> 最好的有<span class="hljs-number">0.93</span>        score:<span class="hljs-number">0.92204</span><br></code></pre></td></tr></table></figure><h5 id="efficientb5"><a href="#efficientb5" class="headerlink" title="efficientb5"></a>efficientb5</h5><p>​             b&#x3D;32          epo&#x3D;5:     </p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335106.png" alt="image-20210812112126130" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">k折  train:<span class="hljs-number">0.9727</span>  test:<span class="hljs-number">0.9418</span>   Score: <span class="hljs-number">0.93613</span><br></code></pre></td></tr></table></figure><p>数据增广+ 标准化  + cos （主要效果）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train acc:<span class="hljs-number">0.9988</span>, test acc:<span class="hljs-number">0.9548</span>            score：<span class="hljs-number">0.96386</span><br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335107.png" alt="image-20210813231542618" style="zoom: 67%;" /><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">工业实际与打比赛的要求确实不一样，工业更多专注数据质量（数据每天都在变化），打比赛是调模型（因为是死数据），工业是<span class="hljs-number">85</span><span class="hljs-meta">%</span>精度可以部署测试，然后不断增强数据质量，不断喂大量数据，基本<span class="hljs-number">3</span>个月-半年后，模型基本可以达到<span class="hljs-number">95</span><span class="hljs-meta">%</span>以上是没问题的，然后部署生产环境，闭环落地！<br>工业界<span class="hljs-number">80</span><span class="hljs-meta">%</span>时间在和数据打交道<br></code></pre></td></tr></table></figure><h4 id="多GPU"><a href="#多GPU" class="headerlink" title="多GPU"></a>多GPU</h4><p>GPU batchsize越大，越能发挥性能。但需要的epoch更多</p><p>数据并行性：batchsize分到不同gpu上，最后梯度一起求和求平均</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335108.png" alt="image-20210813133655919" style="zoom: 67%;" /><p>模型并行性：一个模型太大了放不下</p><h5 id="all-reduce"><a href="#all-reduce" class="headerlink" title="all_reduce"></a>all_reduce</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将梯度信息累加起来</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">allreduce</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):<br>        data[<span class="hljs-number">0</span>][:] += data[i].to(data[<span class="hljs-number">0</span>].device)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):<br>        data[i] = data[<span class="hljs-number">0</span>].to(data[i].device)<br></code></pre></td></tr></table></figure><p>训练：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_batch</span>(<span class="hljs-params">X, y, device_params, devices, lr</span>):<br>    X_shards, y_shards = split_batch(X, y, devices)<br>    <span class="hljs-comment"># 在每个GPU上分别计算损失</span><br>    ls = [loss(lenet(X_shard, device_W), y_shard).<span class="hljs-built_in">sum</span>()<br>          <span class="hljs-keyword">for</span> X_shard, y_shard, device_W <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>              X_shards, y_shards, device_params)]<br>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> ls:  <span class="hljs-comment"># 反向传播在每个GPU上分别执行</span><br>        l.backward()<br>    <span class="hljs-comment"># 将每个GPU的所有梯度相加，并将其广播到所有GPU</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(device_params[<span class="hljs-number">0</span>])):<br>            allreduce([device_params[c][i].grad <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(devices))])<br>    <span class="hljs-comment"># 在每个GPU上分别更新模型参数</span><br>    <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> device_params:<br>        d2l.sgd(param, lr, X.shape[<span class="hljs-number">0</span>]) <span class="hljs-comment"># 在这里，我们使用全尺寸的小批量</span><br></code></pre></td></tr></table></figure><p>简洁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net = nn.DataParallel(net, device_ids=devices)<br>X, y = X.to(devices[<span class="hljs-number">0</span>]), y.to(devices[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h4 id="分布式训练"><a href="#分布式训练" class="headerlink" title="分布式训练"></a>分布式训练</h4><p>需要网络通信：先本地all_reduce，网络通信再all_reduce</p><p>t  &#x3D;  max( 计算时间， 通信时间 )。但增加batchsize需要更多epoch</p><p>读取速度也可能慢：多进程</p><h3 id="视觉"><a href="#视觉" class="headerlink" title="视觉"></a>视觉</h3><h4 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">需要PIL.Image.<span class="hljs-built_in">open</span>()读入RGB图像<br><br>transform = transforms.Compose([<br>    <span class="hljs-comment">#transforms.Resize(256),      短边到256，长边跟着变</span><br>    <span class="hljs-comment">#transforms.CenterCrop(224),  取出正方形</span><br>    transforms.Resize(<span class="hljs-number">224</span>),<br>    transforms.CenterCrop(<span class="hljs-number">224</span>),  <span class="hljs-comment"># 取出正方形</span><br>    transforms.RandomHorizontalFlip(p=<span class="hljs-number">0.5</span>),   <span class="hljs-comment">#随机水平翻转</span><br>    transforms.RandomVerticalFlip(p=<span class="hljs-number">0.5</span>),     <span class="hljs-comment">#除了水平竖直反转之外其他的处理方法貌似都会降低acc</span><br>    <span class="hljs-comment">#transforms.RandomResizedCrop((224, 224), scale=(0.7, 1),ratio(0.75,1.25)),  随机裁剪为不同的大小scale和宽高比ratio，然后缩放所裁剪得到的图像为制定的大小</span><br>    <span class="hljs-comment">#transforms.RandomCrop((60, 120)), # 随机剪裁</span><br>    <span class="hljs-comment"># transforms.ColorJitter(0.3, 0.3, 0.2), # 修改亮度、对比度和饱和度</span><br>    <span class="hljs-comment">#transforms.RandomRotation(180), # 依degrees 随机旋转一定角度   10</span><br>    transforms.ToTensor(),<br>    transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>])<br><br>test_augs = torchvision.transforms.Compose([<br>    torchvision.transforms.Resize(<span class="hljs-number">256</span>),<br>    torchvision.transforms.CenterCrop(<span class="hljs-number">224</span>),<br>    torchvision.transforms.ToTensor(),<br>    transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>])<br></code></pre></td></tr></table></figure><h4 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h4><p>神经网络前面卷积网络是<strong>特征提取</strong>，利用已经训练好的网络来训练我们的数据。</p><p>底层的信息为更好的特征，可以固定住</p><p>微调前面的参数，重点fc参数  ，learning_rate &#x3D; 5e-5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_trainer</span>(<span class="hljs-params">net, learning_rate, param_group = <span class="hljs-literal">True</span></span>)<br><span class="hljs-keyword">if</span> param_group:<br>        params_1x = [param <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> net.named_parameters()<br>             <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;fc.weight&quot;</span>, <span class="hljs-string">&quot;fc.bias&quot;</span>]]<br>        <br>        trainer = torch.optim.SGD([&#123;<span class="hljs-string">&#x27;params&#x27;</span>: params_1x&#125;,<br>                                   &#123;<span class="hljs-string">&#x27;params&#x27;</span>: net.fc.parameters(),<br>                                    <span class="hljs-string">&#x27;lr&#x27;</span>: learning_rate * <span class="hljs-number">10</span>&#125;],<br>                                lr=learning_rate, weight_decay=<span class="hljs-number">0.001</span>)<br>    <span class="hljs-keyword">else</span>:<br>        trainer = torch.optim.SGD(net.parameters(), lr=learning_rate,<br>                                  weight_decay=<span class="hljs-number">0.001</span>)<br>    <span class="hljs-keyword">return</span> trainer<br></code></pre></td></tr></table></figure><h4 id="detect"><a href="#detect" class="headerlink" title="detect"></a>detect</h4><p>COCO数据集：80类，330k张，1.5M个物体</p><p><strong>画框</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment">#@save</span><br>dog_bbox = [<span class="hljs-number">60.0</span>, <span class="hljs-number">45.0</span>, <span class="hljs-number">90.0</span>, <span class="hljs-number">100.0</span>]<br><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment">#@save  # 将边界框 (左上x, 左上y, 右下x, 右下y) 格式转换成 matplotlib 格式：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bbox_to_rect</span>(<span class="hljs-params">bbox, color</span>):<br>    <span class="hljs-comment"># ((左上x, 左上y), 宽, 高)</span><br>    <span class="hljs-keyword">return</span> plt.Rectangle(<br>        xy=(bbox[<span class="hljs-number">0</span>], bbox[<span class="hljs-number">1</span>]), width=bbox[<span class="hljs-number">2</span>]-bbox[<span class="hljs-number">0</span>], height=bbox[<span class="hljs-number">3</span>]-bbox[<span class="hljs-number">1</span>],<br>        fill=<span class="hljs-literal">False</span>, edgecolor=color, linewidth=<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 显示一个边框</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_bbox</span>(<span class="hljs-params">ax, img, box</span>):<br>    ax.imshow(img)<span class="hljs-comment"># 图片</span><br>    ax.axes.add_patch(bbox_to_rect(box, <span class="hljs-string">&#x27;blue&#x27;</span>))<span class="hljs-comment"># 框</span><br><br>img = plt.imread(<span class="hljs-string">&#x27;../img/catdog.jpg&#x27;</span>)<br>fig = plt.figure() <span class="hljs-comment"># 画布</span><br>ax1 = fig.add_subplot(<span class="hljs-number">111</span>) <span class="hljs-comment"># 画1行1列个图形的第1个</span><br>show_bbox(ax1, img, dog_bbox)<br></code></pre></td></tr></table></figure><p>香蕉：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">    最多物体数量   标号，框<br>(torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[32, 3, 256, 256]</span>), torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[32, 1,           5]</span>))<br></code></pre></td></tr></table></figure><p>13 * 13 * 3*（20+1+4）<br>    3个框 20个种类  1是否有物体  4调整框</p><p>IoU：交集比上并集</p><p>锚框和边缘框对应</p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335109.png" alt="image-20210814193726246" style="zoom:50%;" /><p>生成锚框</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># (1, 3, h, w) [0.75, 0.5, 0.25], [1, 2, 0.5]      s√r  和 s /√r  每像素点</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multibox_prior</span>(<span class="hljs-params">data, sizes, ratios</span>):<br>    <span class="hljs-keyword">return</span> [x,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(x,<span class="hljs-number">4</span>)  (y,<span class="hljs-number">4</span>)   返回(x, y) IoU 矩阵<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">box_iou</span>(<span class="hljs-params">boxes1, boxes2</span>):<br></code></pre></td></tr></table></figure><p>将anchors根据iou分配到真实框上，小于阈值分配-1。注意分配顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save 一个数组a[i]=j 对于每个锚框i，分配的真实边界框j,分配阈值iou_threshold</span><br>(x,<span class="hljs-number">4</span>)  (y,<span class="hljs-number">4</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">assign_anchor_to_bbox</span>(<span class="hljs-params">ground_truth, anchors, device, iou_threshold=<span class="hljs-number">0.5</span></span>):<br></code></pre></td></tr></table></figure><p>两组对应框之间的偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save  (x,4)  (x,4)   -&gt;  (x, 4)  中心、wh的偏移</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">offset_boxes</span>(<span class="hljs-params">anchors, assigned_bb, eps=<span class="hljs-number">1e-6</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;对锚框偏移量的转换。&quot;&quot;&quot;</span><br>    c_anc = box_corner_to_center(anchors)<br>    c_assigned_bb = box_corner_to_center(assigned_bb)<br>    offset_xy = <span class="hljs-number">10</span> * (c_assigned_bb[:, :<span class="hljs-number">2</span>] - c_anc[:, :<span class="hljs-number">2</span>]) / c_anc[:, <span class="hljs-number">2</span>:]<br>    offset_wh = <span class="hljs-number">5</span> * torch.log(eps + c_assigned_bb[:, <span class="hljs-number">2</span>:] / c_anc[:, <span class="hljs-number">2</span>:])<br>    offset = torch.cat([offset_xy, offset_wh], axis=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> offset<br></code></pre></td></tr></table></figure><p>将网络中锚框与真实框对应，求出偏移值、mask和 真实类别+1（0为背景，iou小于阈值）</p><p>​一个真实框可以有多个anchor</p><p>​未分配的则是assign_anchor_to_bbox阈值不达标的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-comment"># (b, num_anchors, 4)        (b, num_labels, 5)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multibox_target</span>(<span class="hljs-params">anchors, labels</span>):<br>    <span class="hljs-keyword">return</span> 偏移，mask，类别<br>(b,num_anchors*<span class="hljs-number">4</span>)   (b,num_anchors*<span class="hljs-number">4</span>)    (n,num_anchors)<br>其中负类（小于阈值的anchor）的偏移被mask消除了<br></code></pre></td></tr></table></figure><p>nms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-comment"># 传入(nums,4) (nums) 返回留下的预测框下标数组  [x]</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">nms</span>(<span class="hljs-params">boxes, scores, iou_threshold</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;对预测边界框的置信度进行排序。&quot;&quot;&quot;</span><br>    B = torch.argsort(scores, dim=-<span class="hljs-number">1</span>, descending=<span class="hljs-literal">True</span>)<br>    keep = []  <span class="hljs-comment"># 保留预测边界框的指标</span><br>    <span class="hljs-keyword">while</span> B.numel() &gt; <span class="hljs-number">0</span>:<br>        i = B[<span class="hljs-number">0</span>]<br>        keep.append(i)<br>        <span class="hljs-keyword">if</span> B.numel() == <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span><br>        iou = box_iou(boxes[i, :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>),<br>                      boxes[B[<span class="hljs-number">1</span>:], :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)).reshape(-<span class="hljs-number">1</span>)<br>        inds = torch.nonzero(iou &lt;= iou_threshold).reshape(-<span class="hljs-number">1</span>)<br>        B = B[inds + <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> torch.tensor(keep, device=boxes.device)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#                     (b,classes+1,n)  (b,n*4)   (b,n,4)     (NMS阈值)    (背景阈值)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multibox_detection</span>(<span class="hljs-params">cls_probs, offset_preds, anchors, nms_threshold=<span class="hljs-number">0.5</span>,</span><br><span class="hljs-params">                       pos_threshold=<span class="hljs-number">0.009999999</span></span>):<br>    这里将背景的conf设为<span class="hljs-number">1</span>-conf，类别设为-<span class="hljs-number">1</span><br>    返回 (b, outn, classes+conf+4pos)<br></code></pre></td></tr></table></figure><h4 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h4><p>RCNN&#x2F;  FastR-CNN&#x2F;  FasterR-CNN   精度高速度慢。</p><p>SSD</p><p>YOLO</p><p>CenterNet</p><p>高精度图片中小物体的分类。卫星图片。需要特殊处理，有一套成熟方法</p><h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><p>per &#x3D; len(sizes) + len(ratios) - 1  每个像素点的anchor个数</p><p>每一次blk后，生成num_an (h * w * per)个锚框，同时输入到卷积网络每个像素点输出per*(classes+1)个类别预测和per * 4位置预测。所以每个blk有1个主网络blk，2个分支pred。低层框比较小 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">blk_forward</span>(<span class="hljs-params">X, blk, size, ratio, cls_predictor, bbox_predictor</span>):<br>    Y = blk(X)<br>    anchors = d2l.multibox_prior(Y, sizes=size, ratios=ratio) <span class="hljs-comment"># 生成anchors框 不同层不一样</span><br>    cls_preds = cls_predictor(Y)   <span class="hljs-comment"># 框的类别预测</span><br>    bbox_preds = bbox_predictor(Y) <span class="hljs-comment"># 框的位置偏移</span><br>    <span class="hljs-keyword">return</span> (Y, anchors, cls_preds, bbox_preds)<br></code></pre></td></tr></table></figure><p>(Y,   anchors,                 cls_preds,                                        bbox_preds) </p><p>Y，[1, num_anchors,  4],   [b,  per* (classes+1),  h,  w],    [b,  per * 4,  h,  w]</p><p><strong>总体网络</strong>：由于不同维度h，w不一样，所以将后面的打平堆叠，打平前permute(0, 2, 3, 1)  将c放到最后一维度。将blk返回值堆叠；类别还需要reshape出c+1用来预测；anchors 直接在dim&#x3D;1cat，返回</p><p><strong>anchors</strong>  [1, num_an, 4],   <strong>cls_preds</strong>  [b, num_an, classes+1],    <strong>bbox_preds</strong>  [b, num_an*4]</p><p>(32^2^+16^2^+8^2^4^2^+1^2^)×4&#x3D;5444   ，4是per，底数是特征图宽</p><p>得到全部anchors后与预测Y对应 **multibox_target(anchors, Y)**，返回 bbox_offset, bbox_mask, class_labels。代表着真实的标签</p><p>（这里anchors每张图<strong>都一样</strong>，但留下来算loss的需要满足和label大于阈值） Y：[b, 5]</p><p>bbox_offset与bbox_preds  计算L1损失函数     需要mask去除背景的偏移损失</p><p>class_labels与cls_preds       计算分类损失</p><h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><p>类别损失：交叉熵 由于有多个框，直接reshape到batch维度上。最后dim&#x3D;1取mean求出每张图平均损失值 [b]</p><p>偏移损失：L1loss。乘上mask后传入，最后取mean</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">cls_loss = nn.CrossEntropyLoss(reduction=<span class="hljs-string">&#x27;none&#x27;</span>)<br>bbox_loss = nn.L1Loss(reduction=<span class="hljs-string">&#x27;none&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_loss</span>(<span class="hljs-params">cls_preds, cls_labels, bbox_preds, bbox_labels, bbox_masks</span>):<br>    batch_size, num_classes = cls_preds.shape[<span class="hljs-number">0</span>], cls_preds.shape[<span class="hljs-number">2</span>]<br>    cls = cls_loss(cls_preds.reshape(-<span class="hljs-number">1</span>, num_classes),<br>                   cls_labels.reshape(-<span class="hljs-number">1</span>)).reshape(batch_size, -<span class="hljs-number">1</span>).mean(dim=<span class="hljs-number">1</span>)<br>    bbox = bbox_loss(bbox_preds * bbox_masks,<br>                     bbox_labels * bbox_masks).mean(dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> cls + bbox<br></code></pre></td></tr></table></figure><h5 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">X</span>):<br>    net.<span class="hljs-built_in">eval</span>()<br>    anchors, cls_preds, bbox_preds = net(X.to(device))<br>    cls_probs = F.softmax(cls_preds, dim=<span class="hljs-number">2</span>).permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)        <span class="hljs-comment"># 计算出概率 移到dim=1</span><br>    <span class="hljs-comment"># 把框加上偏移，非极大抑制，背景抑制后返回[b,x,classes+conf+4pos]</span><br>    output = d2l.multibox_detection(cls_probs, bbox_preds, anchors)<br>    <span class="hljs-comment"># 只留下框</span><br>    idx = [i <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(output[<span class="hljs-number">0</span>]) <span class="hljs-keyword">if</span> row[<span class="hljs-number">0</span>] != -<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> output[<span class="hljs-number">0</span>, idx]<br><span class="hljs-number">5444</span>  -nms&gt;   <span class="hljs-number">449</span>  -背景抑制&gt;  <span class="hljs-number">51</span>   -输出再次抑制&gt;    <span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure><h5 id="改进："><a href="#改进：" class="headerlink" title="改进："></a><strong>改进：</strong></h5><p>平滑l1：</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335110.png" alt="image-20210816153354419"></p><p>focal 损失函数：重点在正样本但预测概率小的损失</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335111.png" alt="image-20210816153128924"></p><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>​特别长的物体：设置<strong>ratio</strong></p><p>​怕L2loss特别大，超出范围</p><p>​多个<strong>loss</strong>相加，需要<strong>加权重</strong>使得loss数量级差不多</p><p>​NMS的计算量特别大，需要特殊技巧</p><p>​backbone还是预训练的图片分类模型</p><p>​树莓派上跑detect用yolo</p><p>​没有固定现状的物体检测（土壤）：语义分割</p><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><p>数据集VOC2012        自动驾驶车辆和医疗图像诊断</p><p>color2label数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">voc_colormap2label</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;构建从RGB到VOC类别索引的映射。&quot;&quot;&quot;</span><br>    colormap2label = torch.zeros(<span class="hljs-number">256</span> ** <span class="hljs-number">3</span>, dtype=torch.long)<br>    <span class="hljs-keyword">for</span> i, colormap <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(VOC_COLORMAP):<br>        colormap2label[<br>            (colormap[<span class="hljs-number">0</span>] * <span class="hljs-number">256</span> + colormap[<span class="hljs-number">1</span>]) * <span class="hljs-number">256</span> + colormap[<span class="hljs-number">2</span>]] = i<br>    <span class="hljs-keyword">return</span> colormap2label<br><br><span class="hljs-comment">#@save  传入的是tensor 0~255 (c, h, w)   传出id</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">voc_label_indices</span>(<span class="hljs-params">colormap, colormap2label</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;将VOC标签中的RGB值映射到它们的类别索引。&quot;&quot;&quot;</span><br>    colormap = colormap.permute(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>).numpy().astype(<span class="hljs-string">&#x27;int32&#x27;</span>)<br>    idx = ((colormap[:, :, <span class="hljs-number">0</span>] * <span class="hljs-number">256</span> + colormap[:, :, <span class="hljs-number">1</span>]) * <span class="hljs-number">256</span><br>           + colormap[:, :, <span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> colormap2label[idx]<br></code></pre></td></tr></table></figure><p>随机剪裁： feature和label放到一起进行，(c,h,w)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">voc_rand_crop</span>(<span class="hljs-params">feature, label, height, width</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;随机裁剪特征和标签图像。&quot;&quot;&quot;</span><br>    rect = torchvision.transforms.RandomCrop.get_params(<br>        feature, (height, width))<br>    feature = torchvision.transforms.functional.crop(feature, *rect)<br>    label = torchvision.transforms.functional.crop(label, *rect)<br>    <span class="hljs-keyword">return</span> feature, label<br></code></pre></td></tr></table></figure><p>过滤：滤去小于剪裁大小的图片，在dataset init时就需要去除样本id数组</p><p>人的语义分割比较容易，但是光线影响很大。应该比较成熟了 </p><p>在3d语义分割的情况下，存在深度图，理论上分割更容易</p><p>自动驾驶：距离       速度、加速度      十几二十个摄像头 模型融合。特斯拉纯视觉， google、国内激光雷达</p><h4 id="FCN"><a href="#FCN" class="headerlink" title="FCN"></a>FCN</h4><p>转置卷积实现尺寸变大，也有最近邻插值，双线性插值（初始化核）</p><p><strong>卷积</strong>：一群值转化为一个值的关系</p><p><a href="https://blog.csdn.net/lanadeus/article/details/82534425">轻松理解转置卷积(transposed convolution)或反卷积(deconvolution)_lanadeus-CSDN博客_转置卷积</a></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335112.png" alt="image-20210816214009010"></p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335113.png" alt="image-20210816213950481" style="zoom:67%;" /><p><strong>转置卷积：</strong>原来一个值转化为一群值的对应关系，值上与原来无关（<strong>从信息论的角度看,卷积是不可逆的.所以这里说的并不是从output矩阵和kernel矩阵计算出原始的input矩阵.而是计算出一个保持了位置性关系的矩阵.</strong>)</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335114.png" alt="image-20210816215400555"></p><p>超参数相同时，形状为逆变换</p><p>理解：填充k-p-1后， stride为将原矩阵在行列之间插s-1零行，再做传统卷积</p><p>转置卷积的等价乘法矩阵 &#x3D; 卷积核的乘法矩阵.T</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">d2l.corr2d(X, K) == torch.matmul(W, X.reshape(-<span class="hljs-number">1</span>)).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>trans_conv(Y, K) == torch.matmul(W.T, Y.reshape(-<span class="hljs-number">1</span>)).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>计算方法：1.相乘相加  2.倒转 扩充 正常卷积</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335116.png" alt="image-20210817141016427" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335117.png" alt="image-20210817140913096" style="zoom: 50%;" /></p><p>FCN转置卷积： k-2p-s&#x3D;0  双线性插值初始化</p><p>损失函数：直接cross_entropy ,分类维度在x的第二维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.rand((<span class="hljs-number">32</span>, <span class="hljs-number">21</span>, <span class="hljs-number">320</span>,<span class="hljs-number">480</span>))<br>y = torch.ones((<span class="hljs-number">32</span>, <span class="hljs-number">320</span>, <span class="hljs-number">480</span>)).long()<br>F.cross_entropy(x, y)  <span class="hljs-comment"># nn.CrossEntropyLoss()(x, y)</span><br></code></pre></td></tr></table></figure><p>训练时，由于loss在一个batch上取平均值，比d2l小，所以要调大lr，否者会陷入<strong>局部最优</strong>，输出全黑</p><h4 id="样式迁移"><a href="#样式迁移" class="headerlink" title="样式迁移"></a>样式迁移</h4><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335118.png" alt="image-20210817141542897" style="zoom: 80%;" /><p>网络提取特征后，某些层上的<strong>特征相似</strong>：gram矩阵       内容相似：直接对应位置MSE</p><p>内容特征深层次越好（忽略细节） [25]   风格特征多层结合[0, 5, 10, 19, 28]</p><p><strong>风格矩阵：</strong></p><p>​对角线元素提供了不同特征图（a1，a2 … ，an）各自的信息，其余元素提供了不同特征图之间的相关信息。</p><p>contents_Y,  styles_Y是提前准备好的。X为输入也是调整的对象，初始化为内容图img.weight.data.copy_(X.data)</p><p><strong>迭代：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将X输入到网络中提取特征</span><br>contents_Y_hat, styles_Y_hat = extract_features(X, content_layers, style_layers)<br><span class="hljs-comment"># 根据特征与提前准备好的特征相比较，计算出损失</span><br>contents_l, styles_l, tv_l, l = compute_loss(<br>    X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram)<br></code></pre></td></tr></table></figure><p><strong>loss：</strong>分为3部分, 内容（均方差）、风格（风格矩阵W *W.T的均方差)、平滑度损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">content_weight, style_weight, tv_weight = <span class="hljs-number">1</span>, <span class="hljs-number">1e3</span>, <span class="hljs-number">10</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_loss</span>(<span class="hljs-params">X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram</span>):<br>    <span class="hljs-comment"># 分别计算内容损失、样式损失和总变差损失</span><br>    contents_l = [content_loss(Y_hat, Y) * content_weight <span class="hljs-keyword">for</span> Y_hat, Y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>        contents_Y_hat, contents_Y)]<br>    styles_l = [style_loss(Y_hat, Y) * style_weight <span class="hljs-keyword">for</span> Y_hat, Y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>        styles_Y_hat, styles_Y_gram)]<br>    tv_l = tv_loss(X) * tv_weight<br>    <span class="hljs-comment"># 对所有损失求和</span><br>    l = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span> * styles_l + contents_l + [tv_l]) <span class="hljs-comment"># 一个长列表</span><br>    <span class="hljs-keyword">return</span> contents_l, styles_l, tv_l, l<br></code></pre></td></tr></table></figure><p>大图片迁移：用小图迁移后，放大然后作为起始</p><h3 id="牛仔行头检测"><a href="#牛仔行头检测" class="headerlink" title="牛仔行头检测"></a>牛仔行头检测</h3><p>样本不平衡</p>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
      <category>动手学深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>控制硬件软件资源</li><li>合理组织调度资源</li><li>为软件提供接口和环境</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218610.png" alt="image-20230407133023066"></p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>并发：宏观上同时运行</li><li>共享：并发进程共同享用资源 </li><li>虚拟：一个物理实体对应多个逻辑</li><li>异步：进程走走停停</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218611.png" alt="image-20230407132853257"></p><h4 id="os不同时期发展"><a href="#os不同时期发展" class="headerlink" title="os不同时期发展"></a><strong>os不同时期发展</strong></h4><p>​人工、单道、多道、分时（时间片多用户）、实时</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218612.png" alt="image-20230407132654765"></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>​用户接口；联机（cmd）、脱机（程序）、图形化</p><p>​程序接口：系统调用组成。程序调用相应功能系统调用</p><p>​大内核（模块集中）、微内核</p><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218614.png" alt="image-20230407133249113"></p><h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h2><p>作业比程序更广泛，包含程序、数据和作业说明书</p><p><strong>程序</strong>是个静态的概念，<strong>进程</strong>是程序的一次执行</p><p><strong>进程</strong>：对并发执行的程序的控制和描述，资源分配调度的基本单位，动态性、并发性、独立性、异步</p><p><strong>拥有资源</strong>（代码段 数据段  IO），<strong>唯一</strong>PCB</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218615.png" alt="image-20230407133644813"></p><p><strong>状态</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218616.png" alt="image-20210807140817329"></p><p><strong>编译</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218617.png" alt="image-20210807141320862"></p><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218618.png" alt="image-20230407133959202"></p><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218619.png" alt="image-20230407134144875"></p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>​进程：处理机资源最小单位        创建、撤销和切换代价大</p><p>​线程：处理机调度单位         轻量级进程    TCB          QQ中与不同好友聊天</p><p>​临界资源与临界区</p><h4 id="调度层次分类"><a href="#调度层次分类" class="headerlink" title="调度层次分类"></a>调度层次分类</h4><ul><li>​高级调度（作业调度）：外存到内存 并分配资源   根据JCB  (CPU、磁盘、内存等资源)</li><li>​中级调度（内存调度）：阻塞程序调入外存，提高利用率和吞吐量     </li><li>​低级调度（进程调度）：分配<strong>cpu</strong>          （抢占、非抢占）</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218620.png" alt="image-20230407134438270"></p><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218621.png" alt="image-20230407134721361"></p><h5 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h5><ul><li>​先来先服务FCFS</li><li>​短作业优先SJF</li><li>​高响应比HRRN    (等待+服务时间)&#x2F;服务时间</li><li>​优先级调度PSA</li></ul><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><ul><li>​轮转RR</li><li>​优先级（抢占、非抢占）</li><li>​多级反馈队列：高优先级时间片短，未完成则降级</li></ul><h5 id="实时"><a href="#实时" class="headerlink" title="实时"></a>实时</h5><ul><li>​最早截止EDF（抢占、非抢占）</li><li>​最低松弛度优先LLF（不得不开始时抢占）</li><li>​优先倒置（1.不让抢占临界区  2.优先度继承）</li></ul><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>只允许一个进程使用的资源，硬件实现方法</p><p>​1.关中断</p><p>​2.bool变量标识，while等待 ；    swap对换 原理一样         <strong>忙碌等待</strong></p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>​<strong>PV操作</strong></p><p>​S表示资源数目，当多个资源时，AND机制</p><p>​wait：  s–     if s &lt; 0，线程加入等待队列  </p><p>​signal：s++  if  s&lt;&#x3D;0, 唤醒等待队列</p><p>​    <strong>常见问题</strong>：生产者消费者、进餐、读写     （互斥加紧范围小）</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>​<strong>条件</strong>：互斥、请求和保持、不可抢占、循环等待</p><p>​<strong>处理方法</strong>：</p><ul><li><strong>预防死锁</strong>（一次性分配资源、允许抢占）</li><li><strong>避免死锁</strong>（银行家：在一次分配完后检查是否有安全序列能实现全部运行）</li><li><strong>监测死锁</strong>（资源分配图，分配完有没有环）</li><li><strong>解除死锁</strong>（资源剥夺、回滚进程、终止进程）</li></ul><p><strong>银行家</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218622.png" alt="image-20230407100403822"></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218623.png" alt="image-20230407100418486"></p><p><strong>资源分配图</strong></p><p>去掉所有已经出边（申请了的资源），查看某个进程P是否所有的出边（need）都能满足，能满足则该进程运行，释放所有资源。最后是否能都运行。其实就是判断是否存在<strong>安全序列</strong>。否则就会产生环</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218624.png" alt="image-20230407100722191"><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218625.png" style="zoom:80%;" /></p><h2 id="3-内存"><a href="#3-内存" class="headerlink" title="3.内存"></a>3.内存</h2><h4 id="内存分配（连续）"><a href="#内存分配（连续）" class="headerlink" title="内存分配（连续）"></a>内存分配（连续）</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218626.png" alt="image-20230407103230820"></p><ul><li><p><strong>单一连续分配</strong>（单程序）</p></li><li><p><strong>固定分区分配</strong>（区域固定但大小不等，一个程序一个区） 分区表维护状态  存在<strong>内部碎片</strong>  不能共享</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218627.png" alt="image-20230407101903055" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218628.png" alt="image-20230407101958427" style="zoom: 67%;" /></p></li><li><p><strong>动态分区分配</strong>（根据进程大小分配，空闲表，空闲区由一个双向指针连接起来），存在<strong>外部碎片</strong>（太小没人用）  回收直接合并前后空闲区</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218629.png" alt="image-20230407102352685"></p><p>紧凑：各个进程挪位，挪出一个连续空闲区域。把蓝色部分合并</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218630.png" alt="image-20230407103058745"></p></li></ul><h5 id="顺序方法"><a href="#顺序方法" class="headerlink" title="顺序方法"></a>顺序方法</h5><p>​首次适应FF：开头开始找到就用   循环首次适应NF：从上一次开始</p><p>​最佳适应BF：分配最小的能用的           最坏适应WF：分配最大的区域</p><h5 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h5><ul><li>​快速适应：多个按大小划分的链表（2kb，5kb..）</li><li>​伙伴系统：多个链表大小为2^i^ ，不存在该大小区域则拆分2^i+1^链表</li></ul><p>​用哈希来寻找表头指针</p><h4 id="分页管理（离散）"><a href="#分页管理（离散）" class="headerlink" title="分页管理（离散）"></a>分页管理（离散）</h4><p><strong>优点：</strong></p><ol><li>解决外部碎片</li><li>非连续分配，且不用的可以先不分配，解决程序大小受限问题</li></ol><p>​内存以页面为单位，地址&#x3D;页号+页内地址   ， 页面大小1kb~8kb</p><p>​所以程序的<strong>逻辑地址</strong>都转为<strong>分页地址</strong>。</p><p>​<strong>页表</strong>：程序中页号（逻辑地址 连续）与内存页号（物理地址 不连续）<strong>对应关系</strong>，存放在内存中。PCB中的PTR保持页表起始地址。 页表在<strong>内存管理单元</strong>（MMU）中，每个进程都有</p><p>​每次访问需要访问两次内存，引入<strong>快表</strong>（高速缓冲寄存器） ；查询时间  <strong>2t + λ - t*a</strong> </p><p>​<strong>多级列表</strong>：将页表空间离散，2^20^  &#x3D;  2^10^  * 2^10^</p><p>​4GB内存空间 每个页4kb，共2^20^条； 每一个条目需要4B 则需要2^20^ * 4 B &#x3D; 4 MB 的页表空间</p><p>​转为二级后：2^10^ * 4B  + 2^10^ * 2^10^ * 4B  &#x3D; 4KB + 4MB。但二级页表是可以不存在，所以<strong>节约</strong>并且<strong>离散化</strong>了空间</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218631.png" alt="image-20230407120032813"></p><p>​</p><h4 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h4><p>​满足编程上要求，主程序、子程序、数据段。需要段表实现虚拟到物理</p><p>​当用户共享一段内存时，只需要一个段表，而分页需要多个</p><p><strong>对比：</strong></p><p>打个比方，比如说你去听课，带了一个纸质笔记本做笔记。笔记本有100张纸，课程有语文、数学、英语三门，对于这个笔记本的使用，为了便于以后复习方便，你可以有两种选择。</p><p>第一种是，你从本子的第一张纸开始用，并且事先在本子上做划分：第2张到第30张纸记语文笔记，第31到60张纸记数学笔记，第61到100张纸记英语笔记，最后在第一张纸做个列表，记录着三门笔记各自的范围。这就是分段管理，第一张纸叫段表。</p><p>第二种是，你从第二张纸开始做笔记，各种课的笔记是连在一起的：第2张纸是数学，第3张是语文，第4张英语……最后呢，你在第一张纸做了一个目录，记录着语文笔记在第3、7、14、15张纸……，数学笔记在第2、6、8、9、11……，英语笔记在第4、5、12……。这就是分页管理，第一张纸叫页表。你要复习哪一门课，就到页表里查寻相关的纸的编号，然后翻到那一页去复习</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>​页表中的标志位标记是否在内存中</p><p>​时间、空间<strong>局部性</strong></p><p>​作业的页面可能不在内存中，需要从外存调入，产生一个缺页中断</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218632.png" alt="image-20230407104638679"></p><p>​分配规则：规定分配局部置换（单程序内换）、可变分配局部置换（一起换）、可变分配局部置换（动态加页）</p><h5 id="置换算法"><a href="#置换算法" class="headerlink" title="置换算法!"></a>置换算法!</h5><ul><li>​最佳置换算法 （理论算法、无法实现）</li><li>​先进先出</li><li>​最久未使用LRU   链表头尾</li><li>​最少使用LFU（页面访问表 +1）   </li><li>​    Clock算法  （第一次置为零不换出，第二次&#x3D;0则 换出）</li></ul><h2 id="4-文件"><a href="#4-文件" class="headerlink" title="4.文件"></a>4.文件</h2><p>文件：一系列记录</p><p>记录：一系列数据，有key</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>​顺序文件：顺序存储记录，读取N&#x2F;2</p><p>​索引文件：按键排序建立索引表，logN复杂度</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>单级目录、多级目录、树形目录</p><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>连续组织方式</p><p>链接组织方式：隐式（只存首地址，下一个盘块在当前盘块中），显式（全存到FCB中）FAT表 </p><h2 id="5-io"><a href="#5-io" class="headerlink" title="5.io"></a>5.io</h2><h4 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218633.png" alt="image-20230407131713071"></p><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218634.png"></p><h4 id="磁盘-1"><a href="#磁盘-1" class="headerlink" title="磁盘"></a>磁盘</h4><p>​盘面 磁道 扇区</p><p>寻道+旋转+传输</p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218635.png" alt="image-20230407131437644"></p><h5 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h5><ul><li>先来先服务FCFS</li><li>最短寻道时间SSTF</li><li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li><li>CSCAN：单方向电梯</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218636.png" alt="image-20230407131552116"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>1.什么是操作系统？操作系统的主要功能是什么？</strong></p><p>操作系统位于计算机硬件和应用软件之间，负责协调和管理硬件资源的分配、控制和调度，提供对硬件的抽象和访问接口，以便应用程序能够运行并与硬件交互。</p><p>进程管理、内存管理、文件系统、输入输出</p><p><strong>2.请大致描述操作系统的启动过程。</strong></p><p>操作系统的启动过程包括硬件自检、引导加载程序加载、内核初始化、用户空间初始化、用户应用程序加载和运行等阶段。</p><ol><li>上电自检（Power-On Self-Test, POST）：当计算机电源被打开时，计算机硬件会进行自我检测，包括检测内存、CPU、硬盘、显示器等硬件设备，以确保它们正常工作。</li><li>BIOS&#x2F;UEFI初始化：计算机硬件自检完成后，BIOS（基本输入&#x2F;输出系统）或UEFI（统一可扩展固件接口）会被加载并初始化，它们是计算机的固件，负责初始化硬件设备、设置启动选项等。</li><li>引导加载程序（Boot Loader）：BIOS&#x2F;UEFI会从预定义的引导设备（通常是硬盘、光盘或网络）中加载引导加载程序，例如GRUB、LILO等，它负责加载操作系统的核心模块到内存中。</li><li>操作系统内核加载：引导加载程序会加载操作系统的内核模块到内存中，并将控制权交给操作系统的内核。</li><li>内核初始化：操作系统内核被加载后，会进行初始化，包括初始化设备驱动程序、建立进程管理、内存管理、文件系统等子系统。</li><li>用户空间初始化：操作系统内核初始化完成后，会创建一个或多个用户空间的进程，这些进程负责提供用户界面和用户应用程序的运行环境。</li><li>用户应用程序加载：用户空间的进程会加载用户应用程序到内存中，并开始执行用户应用程序。</li><li>用户应用程序运行：用户应用程序开始在操作系统的运行环境下执行，通过系统调用和内核交互来请求操作系统提供的服务和资源。</li></ol><p><strong>3.什么是系统调用？系统调用的作用是什么？</strong></p><p>系统调用（System Call）是操作系统提供给用户态程序访问内核态功能和资源的<strong>接口</strong>。它允许用户态程序通过调用特定的系统调用函数来请求操作系统的服务和资源，例如文件操作、网络通信、进程管理、内存管理等。</p><p>当需要执行系统调用时，用户通过中断或异常从用户态切换到内核态，从而执行系统调用</p><p><strong>4.多道程序设计、分时操作系统、实时操作系统是什么</strong></p><ul><li>多道程序：通过进程之间的相互切换，同时运行多个进程</li><li>分时操作系统：通过时间片轮转实现<strong>多用户多程序</strong>并发执行，用户之间的隔离和资源的共享。</li><li>实时操作系统：用于处理实时任务，硬实时（航空、医疗工业）、软实时</li></ul><p><strong>5.什么是中断？如何工作？</strong></p><p>中断（Interrupt）是计算机系统中的一种事件，暂停当前指令，转向执行特定的中断程序</p><p>过程：</p><ol><li>中断请求(外部IO、定时器、出现错误) </li><li>暂停当前保留进程现场 </li><li>根据中断向量表定位中断处理程序入口，移交控制权  </li><li>执行中断处理程序，清除中断标志位</li><li>恢复现场，继续执行原来程序</li></ol><p>作用：中断的存在使得程序支持多任务处理、提高响应，控制硬件设备</p><p><strong>6.什么是守护进程（Daemon Process），它在操作系统中的作用是什么？</strong></p><p>守护进程是一种一直在后台运行的特殊类型的进程，用于提供服务和执行系统管理任务。维护系统的正常运行</p><hr><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p><strong>7.什么是进程控制块（PCB）？其主要作用是什么？</strong></p><p>CB保存了进程的基本信息，如进程ID（PID）、进程状态（如就绪、运行、阻塞等）、进程优先级、内存指针、CPU寄存器内容、进程的内存分配信息等，用于对进程进行管理和控制。</p><p><strong>8.操作系统中进程和线程的区别</strong></p><p>进程是指在操作系统中正在运行的一个程序的实例，它包括了程序的代码、数据和运行时的资源。每个进程都有独立的内存空间和系统资源，例如文件句柄、网络连接等。进程之间相互隔离，彼此独立运行，互不干扰。进程之间通过进程间通信（IPC）机制来进行数据交换和通信。</p><p>而线程是进程内的一个独立执行流，也是程序执行的最小单元。同一进程中的多个线程共享进程的内存空间和系统资源，包括文件句柄、网络连接等。线程之间可以通过共享内存来进行通信，因此线程间的通信更加高效。线程的切换开销较小，因此线程可以更快地响应用户请求。</p><p>总结：进程是独立的程序执行实体，拥有独立的内存空间和系统资源；而线程是进程内的执行流，共享进程的内存空间和系统资源，可以更快地进行通信和切换。</p><p>进程：独立、稳定；线程：资源共享(需要手动实现互斥)、响应快</p><p><strong>9.什么是进程通信？进程通信的方式有哪些？</strong></p><table><thead><tr><th align="left">通信方式</th><th align="left">优点</th><th align="left">缺点</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left">管道</td><td align="left">简单易用，无需考虑同步问题。半双工，如果空了或者满了就会阻塞</td><td align="left">只能用于具有亲缘关系的进程间通信</td><td align="left">父子进程间通信</td></tr><tr><td align="left">信号</td><td align="left">传递简单信息，可靠性高，响应速度快。一个进程可以发送一个信号给另一个进程</td><td align="left">只能传递整数值，不能传递复杂数据结构</td><td align="left">进程间异步通信</td></tr><tr><td align="left">信号量</td><td align="left">一个计数器，可以用于同步和互斥，可靠性高</td><td align="left">只能用于具有亲缘关系的进程间通信</td><td align="left">进程间同步和互斥</td></tr><tr><td align="left">消息队列</td><td align="left">可以传递复杂数据结构，可靠性高，支持多对多通信</td><td align="left">性能较差，需要内核支持</td><td align="left">进程间异步通信</td></tr><tr><td align="left">共享内存</td><td align="left">传输速度快，可以直接访问共享内存区域，支持多对多通信</td><td align="left">需要考虑同步和互斥问题，可能会出现死锁等问题</td><td align="left">进程间大量数据交换</td></tr><tr><td align="left">套接字</td><td align="left">网络通信，支持不同主机之间的进程通信，支持多种协议和数据格式</td><td align="left">实现较为复杂，性能较差</td><td align="left">不同主机之间的进程通信</td></tr></tbody></table><p><strong>10.细说信号量：</strong></p><p>信号量可以解决资源间的共享和同步问题</p><p>资源共享：</p><p>​S表示资源数目，当多个资源时，AND机制</p><p>​wait：  s–     if s &lt; 0，线程加入等待队列  </p><p>​signal：s++  if  s&lt;&#x3D;0, 唤醒等待队列</p><p>生产者消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义两个信号量，用于控制缓冲区的空闲空间和数据项数量</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semEmpty</span> <span class="hljs-operator">=</span> n; <span class="hljs-comment">// 初始值为缓冲区的大小，表示空闲空间的数量</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semFull</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始值为 0，表示数据项的数量</span><br><br><span class="hljs-comment">// 生产者进程</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 生成一个数据项</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 等待空闲空间，如果没有空闲空间则阻塞</span><br>    wait(semEmpty);<br>    <span class="hljs-comment">// 将数据项放入缓冲区</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 增加数据项数量</span><br>    signal(semFull);<br>&#125;<br><br><span class="hljs-comment">// 消费者进程</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 等待数据项，如果没有数据项则阻塞</span><br>    wait(semFull);<br>    <span class="hljs-comment">// 从缓冲区取出一个数据项</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 增加空闲空间数量</span><br>    signal(semEmpty);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>11.为什么操作系统需要进行进程调度，有哪些常见的进程调度算法？</strong></p><p>为了充分利用 CPU 资源</p><ul><li><p>先来先服务（First-Come, First-Served, FCFS）：按照进程到达的先后顺序进行调度，即先到达的进程先被执行。</p></li><li><p>最短作业优先（Shortest Job Next, SJN）：选择下一个执行的进程时，选择估计运行时间最短的进程。</p></li><li><p>优先级调度（Priority Scheduling）：为每个进程分配一个优先级，优先级高的进程优先被调度执行。</p></li><li><p>时间片轮转法（Round Robin, RR）：每个进程被分配一个固定的时间片（时间量），当时间片用完时，进程被挂起，下一个进程开始执行，被挂起的进程排队等待下一轮调度。</p></li><li><p>高响应比：1 + 等待时间&#x2F;服务时间  </p></li><li><p>多级反馈队列调度（Multilevel Feedback Queue Scheduling）：多级队列，优先级高的时间短，进程在规定时间未完成则降到下一级</p></li><li><p>实时：</p><ul><li>​最早截止EDF（抢占、非抢占）</li><li>​最低松弛度优先LLF（不得不开始时抢占CPU）</li></ul></li></ul><p><strong>12.什么是死锁？如何避免和检测死锁？</strong></p><p>各个进程或线程因争夺系统资源（如共享资源）而导致相互等待</p><p>互斥条件 请求与保持条件 不可剥夺条件 循环等待条件</p><p>​<strong>处理方法</strong>：</p><ul><li><strong>预防死锁</strong>（一次性分配资源、允许抢占）</li><li><strong>避免死锁</strong>（银行家：在一次分配完后检查是否有安全序列能实现全部运行）</li><li><strong>监测死锁</strong>（资源分配图，分配完有没有环）</li><li><strong>解除死锁</strong>（资源剥夺、回滚进程、终止进程）</li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><strong>13.内存管理的几个阶段？</strong></p><ul><li><strong>单一连续分配</strong>（单程序）</li><li><strong>固定分区分配</strong>（区域固定但大小不等，一个程序一个区） 分区表维护状态  存在<strong>内部碎片</strong>  不能共享</li><li><strong>动态分区分配</strong>（根据进程大小分配，空闲表，空闲区由一个双向指针连接起来），存在<strong>外部碎片</strong>（太小没人用）  回收直接合并前后空闲区</li><li><strong>分页管理</strong>（离散）  1页1~8KB</li><li><strong>分段管理</strong>  逻辑上</li></ul><p><strong>14.二级分页管理中，如何实现逻辑地址到物理地址的映射</strong></p><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218637.png" alt="image-20230411175730569"></p><p><strong>15.什么是虚拟内存，概念及其实现原理，虚拟内存与物理内存的映射是怎么实现的？</strong></p><p>概念：</p><ul><li>虚拟内存：每个进程拥有自己的虚拟地址空间，包括代码段、数据段和堆栈段等，进程访问的地址都是虚拟地址，由进程的逻辑地址空间组成。</li><li>物理内存：实际的物理内存模块，用于存储正在执行的进程的数据和指令。</li></ul><p>实现原理：</p><ul><li>分页机制：将进程的虚拟地址空间划分为固定大小的页，同时将物理内存划分为对应大小的页框。每个页框可以存放一个页的数据或指令。</li><li>页表映射：每个进程都有自己的页表，用于记录其虚拟地址空间中每个页与物理内存中页框的映射关系。通过页表，操作系统可以实现虚拟地址到物理地址的映射。</li><li>页面置换：当物理内存不足以容纳所有进程所需的页时，操作系统会使用页面置换算法，将一些不活跃的页面置换到磁盘上，从而释放物理内存空间，用于加载其他进程的页面。</li><li>页面调度：当发生缺页时，抛出缺页中断，操作系统根据进程的访问模式和页的访问频率等信息，通过页面置换算法来决定将哪些页面调入物理内存，从而提高系统的性能。</li></ul><p><strong>16.操作系统中的页面置换算法有哪些</strong></p><ul><li>​最佳置换算法 （理论算法、无法实现）</li><li>​先进先出</li><li>​最久未使用LRU   链表头尾</li><li>​最少使用LFU（页面访问表 +1）   </li><li>​    Clock算法  （第一次置为零不换出，第二次&#x3D;0则 换出）</li></ul><h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><p><strong>17.文件系统是什么？请讲解文件系统的常见类型及其特点</strong></p><p>文件系统是操作系统中负责管理和组织文件的一部分，它提供了一种逻辑结构，用于在存储介质（如硬盘、闪存等）上存储和组织文件，以便用户可以方便地创建、读取、写入、删除、移动、复制和管理文件。</p><p><strong>18.什么是磁盘调度算法？常见的磁盘调度算法有哪些？</strong></p><ul><li>先来先服务FCFS</li><li>最短寻道时间SSTF</li><li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li><li>CSCAN：单方向电梯</li></ul><p><img src="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218636.png" alt="image-20230407131552116"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>19.请解释什么是死机和蓝屏，并解释它们在操作系统中的原因和处理方法。</strong></p><ul><li>死机：死机是指计算机在运行时突然停止响应，无法继续执行任何操作，屏幕上的图像和界面也无法更新。死机可能是由于<strong>软件或硬件</strong>故障引起的，例如程序错误、设备驱动问题、内存错误等。死机时，屏幕上的内容通常会被冻结在当前状态，无法进行任何操作。</li><li>蓝屏：蓝屏是指在Windows操作系统中出现严重错误时，屏幕会显示蓝色的错误信息界面，通常包含错误代码和错误信息。蓝屏通常由于<strong>操作系统的关键组件</strong>出现故障或冲突引起，例如驱动程序问题、硬件故障、系统文件损坏等。蓝屏时，计算机会自动崩溃并重启，屏幕上会显示蓝屏错误信息。</li></ul><p>死机无提示信息，而蓝屏有；死机会冻结在当且页面，蓝屏会自动崩溃并重启；</p><p><strong>20.介绍下常见的操作系统</strong></p><p>常见的操作系统类型包括Windows、Linux和macOS。</p><ol><li>Windows：Windows是由微软公司开发的操作系统，广泛应用于个人计算机和企业环境。Windows操作系统以图形用户界面（GUI）为特点，提供了丰富的应用程序生态系统和广泛的硬件兼容性。Windows操作系统版本众多，包括Windows 10、Windows 8、Windows 7等，每个版本都有不同的特点和功能。</li><li>Linux：Linux是一种自由和开放源代码的操作系统，基于UNIX的设计原则和哲学。Linux操作系统以稳定、安全和高度可定制性为特点，被广泛用于服务器、嵌入式系统、移动设备和超级计算机等领域。Linux有众多的发行版，如Ubuntu、CentOS、Debian等，每个发行版有其独特的特点和用途。</li><li>macOS：macOS是由苹果公司开发的操作系统，专门设计用于苹果的Mac计算机。macOS以稳定、安全和用户友好的界面为特点，与苹果的硬件和软件紧密集成，提供了独特的用户体验和生产力工具。macOS有多个版本，如macOS Monterey、Big Sur、Catalina等，每个版本都有新的功能和改进。</li></ol><p>这些操作系统之间的主要区别包括：</p><ul><li>用户界面：Windows以图形用户界面（GUI）为主，macOS也是如此，而Linux则可以有多种用户界面选择，例如GNOME、KDE、XFCE等。</li><li>开放性：Linux是自由和开放源代码的操作系统，可以自由定制和修改，而Windows和macOS都是商业操作系统，不开放源代码。</li><li>应用程序生态系统：Windows和macOS拥有丰富的商业软件和应用程序生态系统，而Linux则以开源软件为主，应用程序生态系统相对较小。</li><li>硬件兼容性：Windows通常具有广泛的硬件兼容性，因为它是市场份额最大的操作系统之一，而macOS只能在苹果硬件上运行，Linux的硬件兼容性则因发行版和驱动支持而异。</li><li>安全性：Linux和macOS在安全性方面通常被认为较高，因为它们基于UNIX的安全设计原则，而Windows在过去一直面临着安全威胁和攻击的挑战。</li><li>社区支持：Linux拥有庞大的开源社区和支持系统，而Windows和macOS则主要依赖于厂商的官方支持。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
