

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#B1A58E">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="效率提升：  异步，防止阻塞IO 充分发挥多核CPU  Java 线程线程创建 重写thread的run方法 创建runnable 抽象出来任务 FutureTask 带返回值  线程间通信  extends Thread 并重写run方法 123456789&#x2F;&#x2F; 创建线程对象Thread t &#x3D; new Thread() &amp;#123; public void run() &amp;#123; &#x2F;&#x2F; 要执">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发">
<meta property="og:url" content="http://example.com/2023/06/12/java%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Xun&#39;s Blog">
<meta property="og:description" content="效率提升：  异步，防止阻塞IO 充分发挥多核CPU  Java 线程线程创建 重写thread的run方法 创建runnable 抽象出来任务 FutureTask 带返回值  线程间通信  extends Thread 并重写run方法 123456789&#x2F;&#x2F; 创建线程对象Thread t &#x3D; new Thread() &amp;#123; public void run() &amp;#123; &#x2F;&#x2F; 要执">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230607100221439.png">
<meta property="og:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230607112856036.png">
<meta property="og:image" content="http://example.com/2023/06/12/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%91.assets/image-20230609132432143.png">
<meta property="og:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230609132408757.png">
<meta property="og:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230609133445269.png">
<meta property="og:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230609134409660.png">
<meta property="og:image" content="http://example.com/2023/06/12/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%91.assets/image-20230610113617600.png">
<meta property="og:image" content="http://example.com/2023/06/12/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%91.assets/image-20230610114230079.png">
<meta property="og:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230610123937238.png">
<meta property="og:image" content="http://example.com/2023/06/12/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%91.assets/image-20230610124244401.png">
<meta property="og:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230610133052012.png">
<meta property="og:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230610155101901.png">
<meta property="og:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230610155149434.png">
<meta property="og:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230612163339523.png">
<meta property="og:image" content="http://example.com/2023/06/12/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%91.assets/image-20230612172143500.png">
<meta property="article:published_time" content="2023-06-12T12:00:00.000Z">
<meta property="article:modified_time" content="2023-06-12T12:05:32.272Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/java%E5%B9%B6%E5%8F%91.assets/image-20230607100221439.png">
  
  
  
  <title>java并发 - Xun&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"GEluhFhlvVVyi1wC9RzB0vSk-MdYXbMMI","app_key":"9ng4wvU8n0568liU440awYcT","server_url":null,"path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong> </strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/pink.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">java并发</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-12 20:00" pubdate>
          2023年6月12日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          201 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">java并发</h1>
            
            
              <div class="markdown-body">
                
                <p>效率提升：</p>
<ul>
<li>异步，防止阻塞IO</li>
<li>充分发挥多核CPU</li>
</ul>
<h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ol>
<li>重写thread的run方法</li>
<li>创建runnable 抽象出来任务</li>
<li>FutureTask 带返回值  线程间通信</li>
</ol>
<p>extends Thread 并重写run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// 要执行的任务</span><br> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure>

<p>Runnable :当成参数传给thread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的任务逻辑</span><br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// lambda:单个抽象方法的接口</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的任务逻辑</span><br>    &#125;<br>&#125;);<br><br>thread.start();<br></code></pre></td></tr></table></figure>

<p>FutureTask</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Callable</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<span class="hljs-comment">// 继承Runnable</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        t.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> task.get(); <span class="hljs-comment">// 阻塞等待返回结果</span><br>            System.out.println(s);<br>        &#125;  <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//重写线程任务类方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>tasklist    jps</code>   <code>taskkill</code></p>
<p><code>top -H -p pid           jstack</code>  查看进程中线程信息</p>
<p>每一个线程都有一个独立的栈，栈内每个函数都会有栈帧。main线程中的三个函数：</p>
<p><img src="/java%E5%B9%B6%E5%8F%91.assets/image-20230607100221439.png" srcset="/img/loading.gif" lazyload alt="image-20230607100221439"></p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>切换当前执行的线程</p>
<ul>
<li>CPU时间片</li>
<li>垃圾回收</li>
<li>更高优先权</li>
<li>线程主动调用sleep、yield、wait、 join、 park、 synchronized、 lock</li>
</ul>
<p>如何保存上下文信息？</p>
<ul>
<li>线程内程序计数器 记录运行到哪里</li>
<li>栈帧记录变量信息</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void <strong>start</strong>()</td>
<td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td>
</tr>
<tr>
<td>public void <strong>run</strong>()</td>
<td>线程启动后调用该方法</td>
</tr>
<tr>
<td>public void setName(String name)</td>
<td>给当前线程取名字</td>
</tr>
<tr>
<td>public void getName()</td>
<td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td>
</tr>
<tr>
<td>public static Thread currentThread()</td>
<td>获取当前线程对象，代码在哪个线程中执行</td>
</tr>
<tr>
<td>public static void <strong>sleep</strong>(long time)</td>
<td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td>
</tr>
<tr>
<td>public static native void <strong>yield</strong>()</td>
<td>提示线程调度器让出当前线程对 CPU 的使用</td>
</tr>
<tr>
<td>public final int getPriority()</td>
<td>返回此线程的优先级</td>
</tr>
<tr>
<td>public final void <strong>setPriority</strong>(int priority)</td>
<td>更改此线程的优先级，常用 1 5 10</td>
</tr>
<tr>
<td>public void interrupt()</td>
<td>中断这个线程，异常处理机制</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td>判断当前线程是否被打断，清除打断标记</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td>判断当前线程是否被打断，不清除打断标记</td>
</tr>
<tr>
<td>public final void <strong>join</strong>()</td>
<td>等待这个线程结束</td>
</tr>
<tr>
<td>public final void join(long millis)</td>
<td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td>
</tr>
<tr>
<td>public final native boolean isAlive()</td>
<td>线程是否存活（还没有运行完毕）</td>
</tr>
<tr>
<td>public final void setDaemon(boolean on)</td>
<td>将此线程标记为守护线程或用户线程</td>
</tr>
</tbody></table>
<h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><ul>
<li><strong>操作系统层面</strong>：新建 就绪 运行 阻塞(io) 终止</li>
<li><strong>java层面</strong>：其中Runnable包含 就绪 运行 阻塞(io)</li>
</ul>
<p><img src="/java%E5%B9%B6%E5%8F%91.assets/image-20230607112856036.png" srcset="/img/loading.gif" lazyload alt="image-20230607112856036"></p>
<table>
<thead>
<tr>
<th>程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>NEW（新建）</td>
<td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td>
</tr>
<tr>
<td>Runnable（可运行）</td>
<td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td>
</tr>
<tr>
<td>Blocked（阻塞）</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态 <code>synchronized</code>      <strong>EntryList</strong></td>
</tr>
<tr>
<td>Waiting（无限等待）</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态. <code>wait</code>(WaitSet) <code>join</code>(原理wait) <code>park</code></td>
</tr>
<tr>
<td>Timed Waiting （限期等待）</td>
<td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。常用方法有 <code>Thread.sleep(time) 、wait(time)  </code> <code>join(time)</code> <code>parkUntil(time)</code></td>
</tr>
<tr>
<td>Teminated（结束）</td>
<td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">     */</span><br>    NEW,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">     * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">     * be waiting for other resources from the operating system</span><br><span class="hljs-comment">     * such as processor.</span><br><span class="hljs-comment">     */</span><br>    RUNNABLE,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">     * to enter a synchronized block/method or</span><br><span class="hljs-comment">     * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">     */</span><br>    BLOCKED,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread.</span><br><span class="hljs-comment">     * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">     * following methods:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">     * perform a particular action.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">     * on an object is waiting for another thread to call</span><br><span class="hljs-comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">     * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">     */</span><br>    WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">     * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">     * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     */</span><br>    TIMED_WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a terminated thread.</span><br><span class="hljs-comment">     * The thread has completed execution.</span><br><span class="hljs-comment">     */</span><br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><ul>
<li><code>public void interrupt()</code>：打断这个线程，异常处理机制</li>
<li><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong></li>
<li><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</li>
</ul>
<ol>
<li><p>线程处于<strong>阻塞</strong>状态：如果线程当前处于阻塞状态，如调用了 <code>Thread.sleep()</code>、<code>Object.wait()</code>、<code>join</code> <code>BlockingQueue.take()</code> 等阻塞方法，调用 <code>interrupt()</code> 方法会中断线程的阻塞状态，抛出 <code>InterruptedException</code> 异常，打断标记。因为线程都不在运行，所以需要抛异常来处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    t1.interrupt();<br>    System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>线程处于<strong>非阻塞</strong>状态：如果线程当前处于非阻塞状态，调用 <code>interrupt()</code> 方法会将线程的中断状态设置为 <code>true</code>，但不会中断线程的执行。可以通过检查中断状态来决定是否终止线程的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 主线程休眠 2 秒后中断子线程</span><br>Thread.sleep(<span class="hljs-number">2000</span>);<br>myThread.interrupt();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>            <span class="hljs-comment">// 线程执行的逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;Thread is running.&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Thread interrupted. Exiting...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="两阶段终止"><a href="#两阶段终止" class="headerlink" title="两阶段终止"></a>两阶段终止</h5><p>记录系统的利用率，但需要能停止下来。如果在sleep时被打断，则手动标记一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTInterrupt</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(current.isInterrupted()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    current.interrupt();<br>                &#125;<br>                <span class="hljs-comment">// 执行监控操作 </span><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="打断park"><a href="#打断park" class="headerlink" title="打断park"></a>打断park</h5><p>park阻塞线程类似于一直sleep，但被打断不会清空标记。需要标记为假时才生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);<br>        LockSupport.park();<br>        System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="hljs-comment">//打断状态：true</span><br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    t1.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><ul>
<li><code>public final void join()</code>等待该线程执行完成，原理上可以使用信号量PV</li>
<li><code>join(long millis)</code> 最大等待时间</li>
</ul>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>当其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
<p><code>t1.setDaemon(true);</code></p>
<ul>
<li>垃圾回收器线程就是一种守护线程 </li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>
</ul>
<h2 id="共享模型"><a href="#共享模型" class="headerlink" title="共享模型"></a>共享模型</h2><p>访问共享变量时，代码的原子性（互斥）以及并发协调（同步）</p>
<ul>
<li>共享问题</li>
<li>synchronized</li>
<li>线程安全分析 </li>
<li>Monitor </li>
<li>wait&#x2F;notify </li>
<li>线程状态转换 </li>
<li>活跃性 </li>
<li>Lock 加以改进</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 共享资源</span><br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>        counter++;<br>     &#125;<br> &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br> <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>        counter--;<br>     &#125;<br> &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br></code></pre></td></tr></table></figure>

<ul>
<li>阻塞：synchronized、lock</li>
<li>非阻塞：原子变量</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>对象锁，同一时刻只有一个线程获取到针对该对象的锁，获取失败进入等待队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) <span class="hljs-comment">// 线程1， 线程2(blocked)</span><br>&#123;<br>	临界区<br>&#125;<br><br>大括号相当于 获取锁 + 释放锁。  对象相当于locked<br>    没有获取到时会阻塞释放资源 相当于Futex <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span> (xchg(&amp;locked, <span class="hljs-number">1</span>)) ; &#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; xchg(&amp;locked, <span class="hljs-number">0</span>); &#125;<br></code></pre></td></tr></table></figure>

<p>加在成员方法上，锁<strong>对象</strong>  <code>synchronized(this)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步的代码块</span><br>&#125;<br><br>同一类中的多个函数，如果<span class="hljs-keyword">synchronized</span>了 也不能并行，因为对象被锁了而不是函数被锁了<br></code></pre></td></tr></table></figure>

<p>加在静态方法上，锁<strong>类对象</strong>  <code>synchronized(MyClass.class)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 同步的静态方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>局部变量理论是线程安全的（每个栈都有栈帧），成员变量和静态变量不是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>但如果方法是public并且在子类中被修改了，就可能出错，所以private 或者 final的修饰符是有必要的，满足开<strong>闭</strong>原则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadSafe</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h4><p>线程安全的类： 单一方法是安全的，组合不一定（想要安全还要额外上锁）</p>
<ul>
<li>java.lang.String、 java.lang.Integer  不可变对象</li>
<li>java.lang.StringBuffer</li>
<li>java.lang.Float</li>
<li>java.lang.Boolean</li>
<li>java.util.Vector</li>
<li>java.util.Hashtable</li>
<li>java.util.concurrent.ConcurrentHashMap</li>
</ul>
<p>非线程安全的类：</p>
<ul>
<li>java.lang.StringBuilder</li>
<li>java.util.ArrayList</li>
<li>java.util.LinkedList</li>
<li>java.util.HashMap</li>
<li>java.util.HashSet</li>
</ul>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>MyServlet只有一个，共享的。所以userService也是一个共享的。count不是安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>     <span class="hljs-comment">// 是否安全？</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>     userService.update(...);<br>     &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>     <span class="hljs-comment">// 记录调用次数</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>     	<span class="hljs-comment">// ...</span><br>     	count++;<br> 	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>单例中的成员变量都是共享的。  改成环绕通知中的局部变量就解决了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>     <span class="hljs-comment">// 是否安全？</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br><br>     <span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>         start = System.nanoTime();<br>     &#125;<br><br>     <span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>         System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start));<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>dao中的数据库连接，不能共享否则被别人close了，所以每个查询都要在局部变量中获取一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>	 <span class="hljs-comment">// 是否安全</span><br> 	<span class="hljs-keyword">private</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br> 	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>         conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>         <span class="hljs-comment">// ...</span><br>         conn.close();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转账 锁住类对象，简单的解决办法但效率不高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Account.class)&#123;  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.money &gt; amount) &#123;<br>                <span class="hljs-built_in">this</span>.setMoney(<span class="hljs-built_in">this</span>.getMoney() - amount);<br>                target.setMoney(target.getMoney() + amount);<br>        	&#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><img src="java并发.assets/image-20230609132432143.png" srcset="/img/loading.gif" lazyload alt="image-20230609132432143" style="zoom: 80%;" />

<p>Mark Word</p>
<p><img src="/java%E5%B9%B6%E5%8F%91.assets/image-20230609132408757.png" srcset="/img/loading.gif" lazyload alt="image-20230609132408757"></p>
<h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor是JVM中提供的一个对象，负责管理某个对象的锁。我们的对象通过MarkWord中的指针指向monitor对象（一对一）  c++实现的</p>
<ul>
<li>获取成功为Owner</li>
<li>失败加入EntryList（还可以先进行<strong>自旋</strong>几次，如果还失败才加入，减少上下文切换   自适应）；</li>
<li>在thread-2释放时唤醒一个（线程的阻塞和唤醒操作是在<strong>Java虚拟机内部</strong>进行的，而不涉及到底层操作系统的系统调用）</li>
</ul>
<p><img src="/java%E5%B9%B6%E5%8F%91.assets/image-20230609133445269.png" srcset="/img/loading.gif" lazyload alt="image-20230609133445269"></p>
<h4 id="字节码角度"><a href="#字节码角度" class="headerlink" title="字节码角度"></a>字节码角度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) <br>&#123;<br>	count++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了正常处理外，19~23为异常处理，也会释放锁</p>
<p><img src="/java%E5%B9%B6%E5%8F%91.assets/image-20230609134409660.png" srcset="/img/loading.gif" lazyload alt="image-20230609134409660"></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>优化：轻量级、偏向锁</p>
<ul>
<li><strong>轻量级锁</strong>：在竞争比较少的情况下，每次上锁太麻烦了；房门上挂书包  <strong>对使用者透明</strong></li>
<li><strong>偏向锁</strong>：直接在房门上课上名字，专属于谁</li>
</ul>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p><strong>锁记录</strong>：线程中负责记录锁住了谁的</p>
<ul>
<li><p>加锁：如果对象没被锁(01)，通过<strong>CAS</strong>让对线头保留锁记录地址，锁记录保存原对线头信息</p>
<img src="java并发.assets/image-20230610113617600.png" srcset="/img/loading.gif" lazyload alt="image-20230610113617600" style="zoom:67%;" />
</li>
<li><p>加锁失败：如果对象已经被锁了(00)，<strong>锁膨胀</strong>：申请一个monitor，对象头指向monitor，加入entrylist</p>
</li>
<li><p>解锁：CAS再交换回来，如果发现对象被重量级锁锁住了，就进入重量级锁解锁流程</p>
</li>
</ul>
<img src="java并发.assets/image-20230610114230079.png" srcset="/img/loading.gif" lazyload alt="image-20230610114230079" style="zoom:67%;" />

<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>轻量级锁问题：自己调用时，还需要指向<strong>CAS</strong>操作（这次一定会失败），偏向锁优化掉这个操作</p>
<p><img src="/java%E5%B9%B6%E5%8F%91.assets/image-20230610123937238.png" srcset="/img/loading.gif" lazyload alt="image-20230610123937238"></p>
<ul>
<li><p>把线程的ID放入MarkWord，以后轻量级锁前先查看线程ID是否是自己，自己就不用CAS了</p>
</li>
<li><p>如果threadID不是自己，升级为轻量级锁，解锁后变成normal</p>
<ul>
<li>（如果超过20次，会发生批量重新偏向，全部直接偏向t2）</li>
<li>（如果超过40次，直接所有新建对象不可偏向）</li>
</ul>
</li>
<li><p>偏向锁释放时，并不会清空threadID</p>
</li>
</ul>
<img src="java并发.assets/image-20230610124244401.png" srcset="/img/loading.gif" lazyload alt="image-20230610124244401" style="zoom: 80%;" />

<ul>
<li>初始时默认状态就是该状态，但程序加载会有延时</li>
<li>可以手动禁用，或者hashCode()时会禁用（因为放不下，而轻量级锁记录 重量级monitor会记录hash）</li>
</ul>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁压根不会发生冲突，则直接被优化掉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>     <span class="hljs-keyword">synchronized</span> (o) &#123;<br>     	x++;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>



<h3 id="wait-x2F-notify"><a href="#wait-x2F-notify" class="headerlink" title="wait &#x2F; notify"></a>wait &#x2F; notify</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>等价于万能条件变量法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread A is waiting&quot;</span>);<br>        lock.wait();  <span class="hljs-comment">// 线程A等待</span><br>        System.out.println(<span class="hljs-string">&quot;Thread A is resumed&quot;</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread B is performing some task&quot;</span>);<br>        lock.notify();  <span class="hljs-comment">// 唤醒等待的线程A</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><img src="/java%E5%B9%B6%E5%8F%91.assets/image-20230610133052012.png" srcset="/img/loading.gif" lazyload alt="image-20230610133052012"></p>
<ul>
<li><p>在获取锁后，发现不满足情况，<code>lock.wait()</code>释放锁并进入<code>WaitSet</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex_lock(&amp;lk);<br><span class="hljs-keyword">if</span> (!cond) cond_wait(&amp;cv, &amp;lk); <span class="hljs-comment">// 睡眠前释放锁；在唤醒后，会重新尝试获取锁</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在被Owner <code>lock.notify</code>后，重新进入<code>EntryList</code>。<code>notifyAll()</code>唤醒全部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cond_signal(&amp;cv);<br>broadcast(&amp;cv);<br></code></pre></td></tr></table></figure>
</li>
<li><p>和<strong>操作系统不同点</strong>就是这里锁lk和唤醒信号cv都是lock对象</p>
</li>
</ul>
<p>同样可能会存在错误叫醒的情况，while + 广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>     <span class="hljs-keyword">while</span>(!cond) &#123;<br>     	lock.wait();<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>	lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="wait-sleep区别"><a href="#wait-sleep区别" class="headerlink" title="wait sleep区别"></a>wait sleep区别</h4><ul>
<li>wait 是Object方法；sleep是Thread方法</li>
<li>wait必须要先获取锁并且再释放锁，sleep不用且不会释放锁</li>
</ul>
<h4 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h4><ul>
<li>一个线程等待另外一个线程结果</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>但如果是一直产生：消息队列（见生产者&#x2F;消费者）</li>
</ul>
<p>如果用join实现，必须要下载线程结束，并且变量要设置为全局的</p>
<h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>     <span class="hljs-keyword">private</span> Object response;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件不满足则等待</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                	lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                	e.printStackTrace();<br>            	&#125;<br>        	&#125;<br>        	<span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件满足，通知等待线程</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            lock.notifyAll();<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 子线程执行下载 耗时</span><br>        List&lt;String&gt; response = download();<br>        log.debug(<span class="hljs-string">&quot;download complete...&quot;</span>);<br>        guardedObject.complete(response);<br>        <br>    &#125;).start();<br><br>    <span class="hljs-comment">// 主线程阻塞等待</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> guardedObject.get();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="带超时"><a href="#带超时" class="headerlink" title="带超时"></a><strong>带超时</strong></h5><p>直接wait(time) break不行，因为存在虚假唤醒。记录等待时间防止多等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 1) 记录最初时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 2) 已经经历的时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">timePassed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> millis - timePassed;<br>            log.debug(<span class="hljs-string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);<br>            <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                log.debug(<span class="hljs-string">&quot;break...&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.wait(waitTime);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span><br>            timePassed = System.currentTimeMillis() - begin;<br>            log.debug(<span class="hljs-string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>, timePassed, response == <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="扩展多个"><a href="#扩展多个" class="headerlink" title="扩展多个"></a>扩展多个</h5><p>多加一个中间者，实现多对多，但其中每一对还是一一对应的。解耦产生和消费；  PRC框架</p>
<p><img src="/java%E5%B9%B6%E5%8F%91.assets/image-20230610155101901.png" srcset="/img/loading.gif" lazyload alt="image-20230610155101901"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mailboxes</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 产生唯一 id</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.remove(id);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(generateId());<br>        boxes.put(go.getId(), go);<br>        <span class="hljs-keyword">return</span> go;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.keySet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Join原理"><a href="#Join原理" class="headerlink" title="Join原理"></a>Join原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">线程对象也是对象<br>A线程调用B.join()时，会先获取锁<span class="hljs-keyword">synchronized</span> 然后执行B.wait(delay);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span>&#123;<br>    wait(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="异步模式之生产者-x2F-消费者"><a href="#异步模式之生产者-x2F-消费者" class="headerlink" title="异步模式之生产者&#x2F;消费者"></a>异步模式之生产者&#x2F;消费者</h4><ul>
<li>生产者消费者不需要一一对应</li>
<li>JDK中的阻塞队列原理</li>
</ul>
<p><img src="/java%E5%B9%B6%E5%8F%91.assets/image-20230610155149434.png" srcset="/img/loading.gif" lazyload alt="image-20230610155149434"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(queue)&#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.notifyAll();<br>            <span class="hljs-keyword">return</span> queue.getFirst();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Message m)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(queue)&#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.notifyAll();<br>            queue.add(m);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h3><p>wait状态，有点像<strong>值最大为1的信号量</strong>  但是是以<strong>线程</strong>为单位   不需要获取锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>    LockSupport.park(); <span class="hljs-comment">// 暂停自己</span><br>    log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>sleep(<span class="hljs-number">2</span>);<br>log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>LockSupport.unpark(t1); <span class="hljs-comment">// 恢复某个线程运行，可以在线程暂停前使用</span><br></code></pre></td></tr></table></figure>



<ul>
<li>不需要monitor，唤醒比较精确</li>
<li>可以先恢复再暂停</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>每个线程一个parker对象</p>
<p>其中有一个_counter(干粮数量)&#x3D;0或者1</p>
<ul>
<li>unpark：<code>_counter++  if(线程在等待) &#123;唤醒， _counter=0&#125;</code></li>
<li>park：<code>_counter--   if ( _counter&lt;0)  &#123;wait , _counter=0&#125;</code></li>
</ul>
<h3 id="细粒度锁"><a href="#细粒度锁" class="headerlink" title="细粒度锁"></a>细粒度锁</h3><p>睡觉和学习应该能并发，所以需要将锁细粒度化，而不是直接锁住this</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>            log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>            log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>在一个线程需要获取多把锁时就可能导致</p>
<h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">jps <span class="hljs-comment">// 输出java进程 pid</span><br><br>jconsole <span class="hljs-comment">// 切换到线程，然后检测死锁</span><br>jstack pid  <span class="hljs-comment">// 显示进程运行信息  可以检测死锁  但只能检测java自己的  imple-db项目中锁是用map定义的就无法检测</span><br><br>Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br> waiting to lock monitor <span class="hljs-number">0x000000000361d378</span> (object <span class="hljs-number">0x000000076b5bf1c0</span>, a java.lang.Object),<br> which is held by <span class="hljs-string">&quot;Thread-0&quot;</span><br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br> waiting to lock monitor <span class="hljs-number">0x000000000361e768</span> (object <span class="hljs-number">0x000000076b5bf1d0</span>, a java.lang.Object),<br> which is held by <span class="hljs-string">&quot;Thread-1&quot;</span><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br> at thread.TestDeadLock.lambda$main$<span class="hljs-number">1</span>(TestDeadLock.java:<span class="hljs-number">28</span>)<br> - waiting to lock &lt;<span class="hljs-number">0x000000076b5bf1c0</span>&gt; (a java.lang.Object)<br> - locked &lt;<span class="hljs-number">0x000000076b5bf1d0</span>&gt; (a java.lang.Object)<br> at thread.TestDeadLock$$Lambda$<span class="hljs-number">2</span>/<span class="hljs-number">883049899.</span>run(Unknown Source)<br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br> at thread.TestDeadLock.lambda$main$<span class="hljs-number">0</span>(TestDeadLock.java:<span class="hljs-number">15</span>)<br> - waiting to lock &lt;<span class="hljs-number">0x000000076b5bf1d0</span>&gt; (a java.lang.Object)<br> - locked &lt;<span class="hljs-number">0x000000076b5bf1c0</span>&gt; (a java.lang.Object)<br> at thread.TestDeadLock$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">495053715.</span>run(Unknown Source)<br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure>



<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。开发中可以增加随机时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 期望减到 0 退出循环</span><br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        sleep(<span class="hljs-number">0.2</span>);<br>        count--;<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 期望超过 20 退出循环</span><br>    <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>        sleep(<span class="hljs-number">0.2</span>);<br>        count++;<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure>



<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>某个线程始终不能运行，如设置了线程优先级，优先级低的可能难以运行</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul>
<li>可中断</li>
<li>可以设置超时时间     </li>
<li>可以设置为公平锁     先到先得而不是随机</li>
<li>支持多个条件变量     相当于不同条件变量进入不同<code>WaitSet</code>    现在就完全相当于万能条件变量法 等价于synchronized+wait notifyall 升级</li>
</ul>
<p>都可以重入</p>
<p>java实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h4><p>等待锁的过程中可以被叫醒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    lock.lockInterruptibly();  <span class="hljs-comment">// 如果别人获取了锁，我在等待过程可以被打断</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>    log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br>lock.lock();<br>t1.start();<br>sleep(<span class="hljs-number">1</span>);<br>t1.interrupt();<br></code></pre></td></tr></table></figure>

<h4 id="可超时"><a href="#可超时" class="headerlink" title="可超时"></a>可超时</h4><p>避免无限制的等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!lock.tryLock()) &#123; <span class="hljs-comment">// 查看当前状态下是否能够获取锁 立即返回true false</span><br>    log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br><br>lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS) <span class="hljs-comment">// 尝试1s</span><br></code></pre></td></tr></table></figure>

<h5 id="解决哲学家"><a href="#解决哲学家" class="headerlink" title="解决哲学家"></a>解决哲学家</h5><p>获取锁时，如果右手获取不到，需要立马不等并且左手要解锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 尝试获得左手筷子</span><br><span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 尝试获得右手筷子</span><br>        <span class="hljs-keyword">if</span> (right.tryLock()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                eat();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                right.unlock();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        left.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>会降低并发度 默认为false   <code>lock = new ReentrantLock(true);</code></p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>之前等待队列只有一个，直接是lock对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Thread A is waiting&quot;</span>);<br>    lock.wait();  <span class="hljs-comment">// 线程A等待</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在lock基础上，创建一个condition</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">// 创建一个condition</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionMet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (!conditionMet) &#123;<br>            condition.await(); <span class="hljs-comment">// 在该condition上等待 进入该队列</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Condition is met. Resuming execution.&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        conditionMet = <span class="hljs-literal">true</span>;<br>        condition.signal(); <span class="hljs-comment">// signalAll()</span><br>        System.out.println(<span class="hljs-string">&quot;Condition is signaled.&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h3><h4 id="线程执行顺序"><a href="#线程执行顺序" class="headerlink" title="线程执行顺序"></a>线程执行顺序</h4><ul>
<li>wait notify：  还需要一个额外变量标记代表cond</li>
<li>park unpark  非常简洁</li>
</ul>
<h4 id="打印指定形状"><a href="#打印指定形状" class="headerlink" title="打印指定形状"></a>打印指定形状</h4><p>例如打印abcabc   和打印🐟一个原理</p>
<ol>
<li><p>直接万能条件变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> waitFlag, <span class="hljs-type">int</span> nextFlag, String str)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.flag != waitFlag) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.print(str);<br>        flag = nextFlag;<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>ReentrantLock + condition  每个线程都有等待的cond以及唤醒的cond 感觉没有必要 不如直接上面whlie+notifyAll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> &#123;<br>    <span class="hljs-built_in">this</span>.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        current.await();<br>        log.debug(str);<br>        next.signal();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.unlock();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


</li>
<li><p>park unpark：每次unpark下一个想打印的线程，需要一个数组以获得下一个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LockSupport.park();<br>System.out.print(str);<br>LockSupport.unpark(nextThread());<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>分析多线程访问共享资源时，哪些代码片段属于临界区 </p>
<p>使用 synchronized 互斥解决临界区的线程安全问题 </p>
<ul>
<li>掌握 synchronized 锁对象语法 </li>
<li>掌握 synchronzied 加载成员方法this 和静态方法语法 this.getClass()</li>
<li>掌握 wait&#x2F;notify 同步方法</li>
</ul>
<p>使用 lock 互斥解决临界区的线程安全问题 </p>
<ul>
<li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量   </li>
<li>相当于synchronzied 的<strong>升级</strong></li>
</ul>
<p>学会分析变量的线程安全性、掌握常见<strong>线程安全类</strong>的使用</p>
<p> 了解线程活跃性问题：死锁、活锁、饥饿 </p>
<p><strong>应用方面</strong> </p>
<ul>
<li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果</li>
<li>同步：使用 wait&#x2F;notify 或 Lock 的条件变量来达到线程间通信效果</li>
</ul>
<p><strong>原理方面</strong> </p>
<ul>
<li>monitor、synchronized 、wait&#x2F;notify 原理 </li>
<li>synchronized 进阶原理   轻量级  偏向锁  锁消除</li>
<li>park &amp; unpark 原理</li>
</ul>
<p><strong>模式方面</strong> </p>
<ul>
<li>同步模式之保护性暂停 </li>
<li>异步模式之生产者消费者 </li>
<li>同步模式之顺序控制</li>
</ul>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>JMM java memory model</p>
<ul>
<li>原子性</li>
<li>可见性  不受缓存影响</li>
<li>有序性  不受cpu指令并行优化影响</li>
</ul>
<p>JMM的主要内容包括：</p>
<ol>
<li>主内存（Main Memory）：主内存是所有线程共享的内存区域，用于存储共享变量。主内存中的数据对所有线程可见。</li>
<li>工作内存（Working Memory）：每个线程都有自己的工作内存，用于存储线程执行时需要使用的数据。工作内存中包含了主内存中的部分数据副本。</li>
<li>内存间交互操作：JMM定义了一组规则，用于线程在主内存和工作内存之间进行数据交互。这些操作包括读取、写入和同步操作。</li>
<li>顺序一致性（Sequential Consistency）：JMM保证线程的执行结果与顺序一致的执行结果相同。即，对于一个线程来说，它的操作将按照程序中的顺序执行，并且对其他线程可见。</li>
<li>可见性（Visibility）：JMM保证一个线程对共享变量的修改对其他线程是可见的。这意味着一个线程对变量的修改，将会在之后的操作中对其他线程可见。</li>
<li>原子性（Atomicity）：JMM提供了一些原子性的保证。例如，对<code>volatile</code>变量的读写具有原子性，单个读写操作不会被线程中断。</li>
<li>重排序（Reordering）：JMM允许编译器和处理器对指令进行优化和重排序，但要求保持程序的顺序一致性和线程的可见性。</li>
</ol>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>实际上停不下来，为什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (run) &#123;<br>            <span class="hljs-comment">// ....</span><br>        &#125;<br>    &#125;);<br>    t.start();<br>    Thread.sleep(<span class="hljs-number">1</span>);<br>    run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t会在下一次循环中停下来</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>线程中存储了<code>run = true;</code> 的副本</p>
<p><img src="/java%E5%B9%B6%E5%8F%91.assets/image-20230612163339523.png" srcset="/img/loading.gif" lazyload alt="image-20230612163339523"></p>
<ul>
<li>volatile：强制到主存中读取，修饰成员变量和静态成员变量。不能保证原子性，一个i++ 一个i– 还是会错，适合一个写其他读的情况</li>
<li>synchronized：也可以实现必须去主存读取，但复杂度高点。可以实现原子性（也可能重排序）</li>
</ul>
<h4 id="改进两阶段"><a href="#改进两阶段" class="headerlink" title="改进两阶段"></a>改进两阶段</h4><p>使用volatile标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTVolatile</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(stop) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>                <span class="hljs-comment">// 执行监控操作</span><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        stop = <span class="hljs-literal">true</span>;<br>        thread.interrupt(); <span class="hljs-comment">// 立即打断 不用等待sleep</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="balking"><a href="#balking" class="headerlink" title="balking"></a>balking</h4><p>监控线程只有一个，多次start()其实会调用多个。balking<strong>避免重复执行某个操作</strong>  任务调度</p>
<ul>
<li>加一个volatile变量if判断 ？   不行 不能保证原子</li>
<li>加synchronized  可以实现，但每次都要synchronized同步比较慢（如用这个实现单例）</li>
<li>缩小synchronized 范围。  为什么不直接用单例 单例是保证只有一个实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorService</span> &#123;<br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> starting; <span class="hljs-comment">// 如果只在synchronized修改可以不加volatile</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 真正启动监控线程...</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><img src="java并发.assets/image-20230612172143500.png" srcset="/img/loading.gif" lazyload alt="image-20230612172143500" style="zoom:67%;" />

<p>在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 指令1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; <span class="hljs-comment">// 指令2</span><br>System.out.println( a + b );<br><span class="hljs-comment">// 不能重排的例子</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 指令1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">5</span>; <span class="hljs-comment">// 指令2</span><br></code></pre></td></tr></table></figure>

<h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>1 4为正常输出 但可能出现0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123; <br>    num = <span class="hljs-number">2</span>; <span class="hljs-comment">// 这两条可能被交换位置  或者num = 2并没有被写入主存中</span><br>    ready = <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>对变量ready添加volatile会禁用重排序</p>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障 </li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br>    <span class="hljs-comment">// 写屏障</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-comment">// 读屏障</span><br>    <span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>可见性：<ul>
<li>遇到写屏障（sfence），对所有共享变量的改动，都同步到主存当中</li>
<li>遇到读屏障（lfence），去主存加载最新数据</li>
</ul>
</li>
<li>有序性：<ul>
<li>写屏障 前的代码不会到 写屏障  后面去</li>
<li>读屏障 后的代码不会到 读屏障 前面去</li>
</ul>
</li>
</ul>
<h3 id="double-check-locking"><a href="#double-check-locking" class="headerlink" title="double-check-locking"></a>double-check-locking</h3><p>普通写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125; <br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>double</p>
<ul>
<li><p>需要把同步的范围缩小，只在第一次加锁</p>
</li>
<li><p>并且通过volatile保证读取最新值保证可见性，并且有序性防止指令重排导致 还没初始化完毕的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 的过程<br>    <span class="hljs-number">17</span> 表示创建对象，将对象引用入栈 <span class="hljs-comment">// new Singleton</span><br>    <span class="hljs-number">20</span> 表示复制一份对象引用 <span class="hljs-comment">// 引用地址</span><br>    <span class="hljs-number">21</span> 表示利用一个对象引用，调用构造方法<br>    <span class="hljs-number">24</span> 表示利用一个对象引用，赋值给 <span class="hljs-keyword">static</span> INSTANCE  <span class="hljs-comment">// 可能先执行  需要加volatile写屏障</span><br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// 问题1：解释为什么要加 volatile ?</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123; <br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <br>            <span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span><br>            <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2 </span><br>                <span class="hljs-keyword">return</span> INSTANCE;<br>            &#125;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/java/" class="category-chain-item">java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/">#java</a>
      
        <a href="/tags/%E5%B9%B6%E5%8F%91/">#并发</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" title="算法基础">
                        <span class="hidden-mobile">算法基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
